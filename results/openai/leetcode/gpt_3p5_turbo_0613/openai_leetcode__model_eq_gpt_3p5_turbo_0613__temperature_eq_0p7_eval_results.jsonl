{"task_id": "LeetCode/2818", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport math\n\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def getPrimeScore(num):\n            prime_score = 0\n            for i in range(2, int(math.sqrt(num))+1):\n                if num % i == 0:\n                    while num % i == 0:\n                        num //= i\n                    prime_score += 1\n            if num > 1:\n                prime_score += 1\n            return prime_score\n        \n        left = right = k\n        score = 1\n        max_score = 1\n        prime_scores = [getPrimeScore(num) for num in nums]\n        \n        while left >= 0 and right < len(nums):\n            score *= nums[left]\n            score *= nums[right]\n            max_score = max(max_score, score)\n            \n            if left == 0 and right == len(nums) - 1:\n                break\n            \n            if left > 0 and right < len(nums) - 1:\n                if prime_scores[left-1] > prime_scores[right+1]:\n                    left -= 1\n                else:\n                    right += 1\n            elif left > 0:\n                left -= 1\n            else:\n                right += 1\n                \n        return max_score % (10**9 + 7)\n```", "extracted_code": "\nimport math\n\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def getPrimeScore(num):\n            prime_score = 0\n            for i in range(2, int(math.sqrt(num))+1):\n                if num % i == 0:\n                    while num % i == 0:\n                        num //= i\n                    prime_score += 1\n            if num > 1:\n                prime_score += 1\n            return prime_score\n        \n        left = right = k\n        score = 1\n        max_score = 1\n        prime_scores = [getPrimeScore(num) for num in nums]\n        \n        while left >= 0 and right < len(nums):\n            score *= nums[left]\n            score *= nums[right]\n            max_score = max(max_score, score)\n            \n            if left == 0 and right == len(nums) - 1:\n                break\n            \n            if left > 0 and right < len(nums) - 1:\n                if prime_scores[left-1] > prime_scores[right+1]:\n                    left -= 1\n                else:\n                    right += 1\n            elif left > 0:\n                left -= 1\n            else:\n                right += 1\n                \n        return max_score % (10**9 + 7)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2813", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        categories = [[] for _ in range(n)]\n        for i, [profit, category] in enumerate(items):\n            categories[category-1].append(profit)\n        for i in range(n):\n            categories[i].sort(reverse=True)\n        max_elegance = 0\n        for i in range(n):\n            if len(categories[i]) < k:\n                continue\n            total_profit = sum(categories[i][:k])\n            distinct_categories = i + 1\n            elegance = total_profit + distinct_categories**2\n            max_elegance = max(max_elegance, elegance)\n        return max_elegance\n```", "extracted_code": "\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        categories = [[] for _ in range(n)]\n        for i, [profit, category] in enumerate(items):\n            categories[category-1].append(profit)\n        for i in range(n):\n            categories[i].sort(reverse=True)\n        max_elegance = 0\n        for i in range(n):\n            if len(categories[i]) < k:\n                continue\n            total_profit = sum(categories[i][:k])\n            distinct_categories = i + 1\n            elegance = total_profit + distinct_categories**2\n            max_elegance = max(max_elegance, elegance)\n        return max_elegance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2812", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        minDist = [[float('inf')] * n for _ in range(n)]\n        minDist[0][0] = 0\n        \n        queue = [(0, 0)]\n        while queue:\n            x, y = queue.pop(0)\n            dist = minDist[x][y]\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if nx >= 0 and nx < n and ny >= 0 and ny < n:\n                    if grid[nx][ny] == 0 and dist + 1 < minDist[nx][ny]:\n                        minDist[nx][ny] = dist + 1\n                        queue.append((nx, ny))\n        \n        return minDist[n-1][n-1]\n```", "extracted_code": "\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        minDist = [[float('inf')] * n for _ in range(n)]\n        minDist[0][0] = 0\n        \n        queue = [(0, 0)]\n        while queue:\n            x, y = queue.pop(0)\n            dist = minDist[x][y]\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if nx >= 0 and nx < n and ny >= 0 and ny < n:\n                    if grid[nx][ny] == 0 and dist + 1 < minDist[nx][ny]:\n                        minDist[nx][ny] = dist + 1\n                        queue.append((nx, ny))\n        \n        return minDist[n-1][n-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2811", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        def dfs(nums, m, curr_sum, curr_count, start, visited):\n            if curr_count == m:\n                return True\n            if curr_sum == 0:\n                return dfs(nums, m, 0, curr_count + 1, 0, visited)\n            for i in range(start, len(nums)):\n                if not visited[i] and curr_sum + nums[i] <= m:\n                    visited[i] = True\n                    if dfs(nums, m, curr_sum + nums[i], curr_count, i + 1, visited):\n                        return True\n                    visited[i] = False\n            return False\n        \n        if sum(nums) % m != 0:\n            return False\n        target_sum = sum(nums) // m\n        visited = [False] * len(nums)\n        return dfs(nums, target_sum, 0, 0, 0, visited)\n```", "extracted_code": "\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        def dfs(nums, m, curr_sum, curr_count, start, visited):\n            if curr_count == m:\n                return True\n            if curr_sum == 0:\n                return dfs(nums, m, 0, curr_count + 1, 0, visited)\n            for i in range(start, len(nums)):\n                if not visited[i] and curr_sum + nums[i] <= m:\n                    visited[i] = True\n                    if dfs(nums, m, curr_sum + nums[i], curr_count, i + 1, visited):\n                        return True\n                    visited[i] = False\n            return False\n        \n        if sum(nums) % m != 0:\n            return False\n        target_sum = sum(nums) // m\n        visited = [False] * len(nums)\n        return dfs(nums, target_sum, 0, 0, 0, visited)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2809", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        # Calculate the initial sum of nums1\n        initial_sum = sum(nums1)\n        \n        # If the initial sum is already less than or equal to x, return 0\n        if initial_sum <= x:\n            return 0\n        \n        # Initialize the minimum time to -1\n        min_time = -1\n        \n        # Iterate through each index i\n        for i in range(len(nums1)):\n            # Update nums1[i] using nums2[i]\n            nums1[i] += nums2[i]\n            \n            # Calculate the new sum of nums1\n            new_sum = sum(nums1)\n            \n            # If the new sum is less than or equal to x, update the minimum time\n            if new_sum <= x:\n                # If this is the first time the new sum is less than or equal to x, update min_time\n                if min_time == -1:\n                    min_time = i + 1\n                # Otherwise, update min_time only if the current time is smaller than the previous minimum time\n                else:\n                    min_time = min(min_time, i + 1)\n        \n        return min_time\n```", "extracted_code": "\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        # Calculate the initial sum of nums1\n        initial_sum = sum(nums1)\n        \n        # If the initial sum is already less than or equal to x, return 0\n        if initial_sum <= x:\n            return 0\n        \n        # Initialize the minimum time to -1\n        min_time = -1\n        \n        # Iterate through each index i\n        for i in range(len(nums1)):\n            # Update nums1[i] using nums2[i]\n            nums1[i] += nums2[i]\n            \n            # Calculate the new sum of nums1\n            new_sum = sum(nums1)\n            \n            # If the new sum is less than or equal to x, update the minimum time\n            if new_sum <= x:\n                # If this is the first time the new sum is less than or equal to x, update min_time\n                if min_time == -1:\n                    min_time = i + 1\n                # Otherwise, update min_time only if the current time is smaller than the previous minimum time\n                else:\n                    min_time = min(min_time, i + 1)\n        \n        return min_time\n", "difficulty": 3.0}
{"task_id": "LeetCode/2808", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_val = min(nums)\n        max_val = max(nums)\n        \n        if min_val == max_val:\n            return 0\n        \n        count_min = nums.count(min_val)\n        count_max = nums.count(max_val)\n        \n        if count_min == n or count_max == n:\n            return 1\n        \n        return 2\n```", "extracted_code": "\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_val = min(nums)\n        max_val = max(nums)\n        \n        if min_val == max_val:\n            return 0\n        \n        count_min = nums.count(min_val)\n        count_max = nums.count(max_val)\n        \n        if count_min == n or count_max == n:\n            return 1\n        \n        return 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2807", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def insertGreatestCommonDivisors(self, head):\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            a = prev.next.val\n            b = prev.next.next.val\n            div = gcd(a, b)\n            \n            newNode = ListNode(div)\n            newNode.next = prev.next.next\n            prev.next.next = newNode\n            prev = prev.next.next\n        \n        return dummy.next\n```", "extracted_code": "\nclass Solution:\n    def insertGreatestCommonDivisors(self, head):\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            a = prev.next.val\n            b = prev.next.next.val\n            div = gcd(a, b)\n            \n            newNode = ListNode(div)\n            newNode.next = prev.next.next\n            prev.next.next = newNode\n            prev = prev.next.next\n        \n        return dummy.next\n", "difficulty": 2.0}
{"task_id": "LeetCode/2806", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        # Rounding the purchase amount to the nearest multiple of 10\n        roundedAmount = round(purchaseAmount, -1)\n        \n        # Calculating the account balance after the purchase\n        accountBalance = 100 - roundedAmount\n        \n        return accountBalance\n```", "extracted_code": "\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        # Rounding the purchase amount to the nearest multiple of 10\n        roundedAmount = round(purchaseAmount, -1)\n        \n        # Calculating the account balance after the purchase\n        accountBalance = 100 - roundedAmount\n        \n        return accountBalance\n", "difficulty": 1.0}
{"task_id": "LeetCode/2801", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        count = 0\n        low_num = int(low)\n        high_num = int(high)\n        queue = []\n        \n        # If low is 0, then we need to start from 1 and add it to the queue\n        if low_num == 0:\n            queue.append(0)\n        \n        # Start BFS traversal from 1 to 9\n        for i in range(1, 10):\n            queue.append(i)\n            \n        # BFS traversal\n        while queue:\n            curr_num = queue.pop(0)\n            \n            # If the current number is within the range [low, high], increment the count\n            if low_num <= curr_num <= high_num:\n                count += 1\n                \n            # Get the last digit of the current number\n            last_digit = curr_num % 10\n            \n            # Check if we can append a stepping number by adding a digit to the left\n            if last_digit > 0:\n                new_num = curr_num * 10 + (last_digit - 1)\n                if new_num <= high_num:\n                    queue.append(new_num)\n                    \n            # Check if we can append a stepping number by adding a digit to the right\n            if last_digit < 9:\n                new_num = curr_num * 10 + (last_digit + 1)\n                if new_num <= high_num:\n                    queue.append(new_num)\n        \n        return count % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        count = 0\n        low_num = int(low)\n        high_num = int(high)\n        queue = []\n        \n        # If low is 0, then we need to start from 1 and add it to the queue\n        if low_num == 0:\n            queue.append(0)\n        \n        # Start BFS traversal from 1 to 9\n        for i in range(1, 10):\n            queue.append(i)\n            \n        # BFS traversal\n        while queue:\n            curr_num = queue.pop(0)\n            \n            # If the current number is within the range [low, high], increment the count\n            if low_num <= curr_num <= high_num:\n                count += 1\n                \n            # Get the last digit of the current number\n            last_digit = curr_num % 10\n            \n            # Check if we can append a stepping number by adding a digit to the left\n            if last_digit > 0:\n                new_num = curr_num * 10 + (last_digit - 1)\n                if new_num <= high_num:\n                    queue.append(new_num)\n                    \n            # Check if we can append a stepping number by adding a digit to the right\n            if last_digit < 9:\n                new_num = curr_num * 10 + (last_digit + 1)\n                if new_num <= high_num:\n                    queue.append(new_num)\n        \n        return count % (10**9 + 7)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2800", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        combined = a + b + c\n        sorted_combined = sorted(combined)\n        min_length = len(a) + len(b) + len(c)\n        result = ''\n        \n        for i in range(len(sorted_combined)):\n            if i + min_length > len(sorted_combined):\n                break\n            substring = ''.join(sorted_combined[i:i+min_length])\n            \n            if a in substring and b in substring and c in substring:\n                result = substring\n                break\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        combined = a + b + c\n        sorted_combined = sorted(combined)\n        min_length = len(a) + len(b) + len(c)\n        result = ''\n        \n        for i in range(len(sorted_combined)):\n            if i + min_length > len(sorted_combined):\n                break\n            substring = ''.join(sorted_combined[i:i+min_length])\n            \n            if a in substring and b in substring and c in substring:\n                result = substring\n                break\n        \n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2799", "status": "Time Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            distinct = set()\n            for j in range(i, n):\n                distinct.add(nums[j])\n                if len(distinct) == len(set(nums)):\n                    count += 1\n                    \n        return count\n```", "extracted_code": "\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            distinct = set()\n            for j in range(i, n):\n                distinct.add(nums[j])\n                if len(distinct) == len(set(nums)):\n                    count += 1\n                    \n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2791", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        def dfs(node, path):\n            nonlocal count\n            if node in path:\n                count += 1\n            path.append(node)\n            for child in graph[node]:\n                dfs(child, path)\n            path.pop()\n            \n        n = len(parent)\n        graph = {i: [] for i in range(n)}\n        count = 0\n        \n        for i in range(1, n):\n            graph[parent[i]].append(i)\n        \n        dfs(0, [])\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        def dfs(node, path):\n            nonlocal count\n            if node in path:\n                count += 1\n            path.append(node)\n            for child in graph[node]:\n                dfs(child, path)\n            path.pop()\n            \n        n = len(parent)\n        graph = {i: [] for i in range(n)}\n        count = 0\n        \n        for i in range(1, n):\n            graph[parent[i]].append(i)\n        \n        dfs(0, [])\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2790", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        groups = 0\n        curr_limit = 0\n        \n        for limit in usageLimits:\n            if limit > curr_limit:\n                groups += 1\n                curr_limit += 1\n            else:\n                curr_limit = limit\n        \n        return groups\n```", "extracted_code": "\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        groups = 0\n        curr_limit = 0\n        \n        for limit in usageLimits:\n            if limit > curr_limit:\n                groups += 1\n                curr_limit += 1\n            else:\n                curr_limit = limit\n        \n        return groups\n", "difficulty": 3.0}
{"task_id": "LeetCode/2788", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            splits = word.split(separator)\n            result.extend(splits)\n        return [s for s in result if s != '']\n```", "extracted_code": "\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            splits = word.split(separator)\n            result.extend(splits)\n        return [s for s in result if s != '']\n", "difficulty": 1.0}
{"task_id": "LeetCode/2787", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(1, x + 1):\n                if i - j**x >= 0:\n                    dp[i] = (dp[i] + dp[i - j**x]) % mod\n        \n        return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(1, x + 1):\n                if i - j**x >= 0:\n                    dp[i] = (dp[i] + dp[i - j**x]) % mod\n        \n        return dp[n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2785", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = []\n        \n        for i in range(len(s)):\n            if s[i] in vowels:\n                vowel_indices.append(i)\n        \n        sorted_vowels = sorted([s[i] for i in vowel_indices])\n        result = list(s)\n        \n        for i in range(len(sorted_vowels)):\n            result[vowel_indices[i]] = sorted_vowels[i]\n        \n        return ''.join(result)\n```", "extracted_code": "\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = []\n        \n        for i in range(len(s)):\n            if s[i] in vowels:\n                vowel_indices.append(i)\n        \n        sorted_vowels = sorted([s[i] for i in vowel_indices])\n        result = list(s)\n        \n        for i in range(len(sorted_vowels)):\n            result[vowel_indices[i]] = sorted_vowels[i]\n        \n        return ''.join(result)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2784", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = max(nums)\n        base = [i for i in range(1, n)] + [n, n]\n        return sorted(nums) == base\n```", "extracted_code": "\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = max(nums)\n        base = [i for i in range(1, n)] + [n, n]\n        return sorted(nums) == base\n", "difficulty": 1.0}
{"task_id": "LeetCode/2781", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        n = len(word)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + 1\n            for j in range(i - 1, -1, -1):\n                if word[j:i] in forbidden_set:\n                    dp[i] = 0\n                    break\n                dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n```", "extracted_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        n = len(word)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + 1\n            for j in range(i - 1, -1, -1):\n                if word[j:i] in forbidden_set:\n                    dp[i] = 0\n                    break\n                dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2772", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        min_val = min(nums)\n        max_val = max(nums)\n        if max_val - min_val > k:\n            return False\n        count = [0] * (max_val - min_val + 1)\n        for num in nums:\n            count[num - min_val] += 1\n        for i in range(len(count) - 1):\n            count[i + 1] += count[i]\n        for i in range(k - 1, n):\n            if (i >= k):\n                count[nums[i - k] - min_val] -= 1\n            if (count[-1] == i - k + 1 and max_val - min_val - i == 0):\n                return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        min_val = min(nums)\n        max_val = max(nums)\n        if max_val - min_val > k:\n            return False\n        count = [0] * (max_val - min_val + 1)\n        for num in nums:\n            count[num - min_val] += 1\n        for i in range(len(count) - 1):\n            count[i + 1] += count[i]\n        for i in range(k - 1, n):\n            if (i >= k):\n                count[nums[i - k] - min_val] -= 1\n            if (count[-1] == i - k + 1 and max_val - min_val - i == 0):\n                return True\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2771", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        \n        for i in range(1, n):\n            dp[i][0] = dp[i-1][0] + 1 if nums1[i] >= nums1[i-1] else 1\n            dp[i][0] = max(dp[i][0], dp[i-1][1] + 1 if nums1[i] >= nums2[i-1] else 1)\n            dp[i][1] = dp[i-1][0] + 1 if nums2[i] >= nums1[i-1] else 1\n            dp[i][1] = max(dp[i][1], dp[i-1][1] + 1 if nums2[i] >= nums2[i-1] else 1)\n        \n        return max(dp[n-1][0], dp[n-1][1])\n```", "extracted_code": "\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        \n        for i in range(1, n):\n            dp[i][0] = dp[i-1][0] + 1 if nums1[i] >= nums1[i-1] else 1\n            dp[i][0] = max(dp[i][0], dp[i-1][1] + 1 if nums1[i] >= nums2[i-1] else 1)\n            dp[i][1] = dp[i-1][0] + 1 if nums2[i] >= nums1[i-1] else 1\n            dp[i][1] = max(dp[i][1], dp[i-1][1] + 1 if nums2[i] >= nums2[i-1] else 1)\n        \n        return max(dp[n-1][0], dp[n-1][1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2770", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [float('inf')] * n\n        dp[0] = 0\n        \n        for i in range(1, n):\n            for j in range(i):\n                if abs(nums[i] - nums[j]) <= target:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        if dp[n-1] == float('inf'):\n            return -1\n        else:\n            return dp[n-1]\n```", "extracted_code": "\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [float('inf')] * n\n        dp[0] = 0\n        \n        for i in range(1, n):\n            for j in range(i):\n                if abs(nums[i] - nums[j]) <= target:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        if dp[n-1] == float('inf'):\n            return -1\n        else:\n            return dp[n-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2768", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        # Create a set to store the black cells\n        black_cells = set((x, y) for x, y in coordinates)\n        \n        # Initialize a list to store the count of blocks with i black cells\n        block_counts = [0] * 5\n        \n        # Iterate over all possible 2x2 blocks\n        for i in range(m-1):\n            for j in range(n-1):\n                # Count the number of black cells in the current block\n                count = sum((i+x, j+y) in black_cells for x in range(2) for y in range(2))\n                # Increment the count of blocks with count black cells\n                block_counts[count] += 1\n        \n        return block_counts\n```", "extracted_code": "\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        # Create a set to store the black cells\n        black_cells = set((x, y) for x, y in coordinates)\n        \n        # Initialize a list to store the count of blocks with i black cells\n        block_counts = [0] * 5\n        \n        # Iterate over all possible 2x2 blocks\n        for i in range(m-1):\n            for j in range(n-1):\n                # Count the number of black cells in the current block\n                count = sum((i+x, j+y) in black_cells for x in range(2) for y in range(2))\n                # Increment the count of blocks with count black cells\n                block_counts[count] += 1\n        \n        return block_counts\n", "difficulty": 2.0}
{"task_id": "LeetCode/2766", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        occupied_positions = set(nums)\n        \n        for i in range(len(moveFrom)):\n            occupied_positions.remove(moveFrom[i])\n            occupied_positions.add(moveTo[i])\n        \n        return sorted(occupied_positions)\n```", "extracted_code": "\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        occupied_positions = set(nums)\n        \n        for i in range(len(moveFrom)):\n            occupied_positions.remove(moveFrom[i])\n            occupied_positions.add(moveTo[i])\n        \n        return sorted(occupied_positions)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2763", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        result = 0\n        for i in range(n):\n            for j in range(i+1, n+1):\n                subarray = nums[i:j]\n                sorted_subarray = sorted(subarray)\n                imbalance = sum(sorted_subarray[i+1] - sorted_subarray[i] > 1 for i in range(len(sorted_subarray)-1))\n                result += imbalance\n        return result\n```", "extracted_code": "\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        result = 0\n        for i in range(n):\n            for j in range(i+1, n+1):\n                subarray = nums[i:j]\n                sorted_subarray = sorted(subarray)\n                imbalance = sum(sorted_subarray[i+1] - sorted_subarray[i] > 1 for i in range(len(sorted_subarray)-1))\n                result += imbalance\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2762", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i, n):\n                if abs(nums[i] - nums[j]) <= 2:\n                    count += 1\n                else:\n                    break\n        return count\n```", "extracted_code": "\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i, n):\n                if abs(nums[i] - nums[j]) <= 2:\n                    count += 1\n                else:\n                    break\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2751", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Initialize an empty stack to store the positions and healths of surviving robots\n        stack = []\n        \n        # Iterate through the robots\n        for i in range(len(positions)):\n            # Get the current position, health, and direction of the robot\n            position = positions[i]\n            health = healths[i]\n            direction = directions[i]\n            \n            # If the stack is empty, add the robot to the stack\n            if not stack:\n                stack.append((position, health))\n            else:\n                # Check if the current robot collides with any robot in the stack\n                while stack and stack[-1][0] < position and stack[-1][1] >= health:\n                    # Remove the robot with lower health from the stack\n                    stack.pop()\n                \n                # If the stack is empty or the current robot does not collide with any robot in the stack,\n                # add the current robot to the stack\n                if not stack or stack[-1][0] < position:\n                    stack.append((position, health))\n        \n        # Return the healths of the surviving robots in the same order as the input\n        return [health for _, health in stack]\n```", "extracted_code": "\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Initialize an empty stack to store the positions and healths of surviving robots\n        stack = []\n        \n        # Iterate through the robots\n        for i in range(len(positions)):\n            # Get the current position, health, and direction of the robot\n            position = positions[i]\n            health = healths[i]\n            direction = directions[i]\n            \n            # If the stack is empty, add the robot to the stack\n            if not stack:\n                stack.append((position, health))\n            else:\n                # Check if the current robot collides with any robot in the stack\n                while stack and stack[-1][0] < position and stack[-1][1] >= health:\n                    # Remove the robot with lower health from the stack\n                    stack.pop()\n                \n                # If the stack is empty or the current robot does not collide with any robot in the stack,\n                # add the current robot to the stack\n                if not stack or stack[-1][0] < position:\n                    stack.append((position, health))\n        \n        # Return the healths of the surviving robots in the same order as the input\n        return [health for _, health in stack]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2750", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        n = len(nums)\n        left = [0] * n\n        right = [0] * n\n        count = 0\n        \n        # Calculate the number of 1's on the left side of each element\n        for i in range(n):\n            if nums[i] == 1:\n                left[i] = 1\n            if i > 0:\n                left[i] += left[i-1]\n        \n        # Calculate the number of 1's on the right side of each element\n        for i in range(n-1, -1, -1):\n            if nums[i] == 1:\n                right[i] = 1\n            if i < n-1:\n                right[i] += right[i+1]\n        \n        # Count the number of good subarray splits\n        for i in range(n-1):\n            if left[i] > 0 and right[i+1] > 0:\n                count += left[i] * right[i+1]\n        \n        return count % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        n = len(nums)\n        left = [0] * n\n        right = [0] * n\n        count = 0\n        \n        # Calculate the number of 1's on the left side of each element\n        for i in range(n):\n            if nums[i] == 1:\n                left[i] = 1\n            if i > 0:\n                left[i] += left[i-1]\n        \n        # Calculate the number of 1's on the right side of each element\n        for i in range(n-1, -1, -1):\n            if nums[i] == 1:\n                right[i] = 1\n            if i < n-1:\n                right[i] += right[i+1]\n        \n        # Count the number of good subarray splits\n        for i in range(n-1):\n            if left[i] > 0 and right[i+1] > 0:\n                count += left[i] * right[i+1]\n        \n        return count % (10**9 + 7)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2749", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        # If num1 is already zero, return 0\n        if num1 == 0:\n            return 0\n        \n        # If num2 is positive or zero, it is impossible to make num1 equal to zero\n        if num2 >= 0:\n            return -1\n        \n        # If num2 is negative, find the minimum number of operations needed\n        operations = 0\n        while num1 != 0:\n            # Find the largest power of 2 that is less than or equal to num1\n            power = 0\n            while (2 ** power) + num2 <= num1:\n                power += 1\n            \n            # Subtract 2^power + num2 from num1\n            num1 -= (2 ** power) + num2\n            operations += 1\n        \n        return operations\n```", "extracted_code": "\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        # If num1 is already zero, return 0\n        if num1 == 0:\n            return 0\n        \n        # If num2 is positive or zero, it is impossible to make num1 equal to zero\n        if num2 >= 0:\n            return -1\n        \n        # If num2 is negative, find the minimum number of operations needed\n        operations = 0\n        while num1 != 0:\n            # Find the largest power of 2 that is less than or equal to num1\n            power = 0\n            while (2 ** power) + num2 <= num1:\n                power += 1\n            \n            # Subtract 2^power + num2 from num1\n            num1 -= (2 ** power) + num2\n            operations += 1\n        \n        return operations\n", "difficulty": 2.0}
{"task_id": "LeetCode/2747", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Create a list to store the count of requests received by each server at each time point\n        server_count = [0] * n\n        \n        # Iterate through the logs and increment the count for each server at the corresponding time point\n        for log in logs:\n            server_id, time = log\n            server_count[server_id - 1] += 1\n        \n        # Create a list to store the result\n        result = []\n        \n        # Iterate through the queries\n        for query in queries:\n            # Calculate the start and end time for the query interval\n            start_time = query - x\n            end_time = query\n            \n            # Initialize a count for servers that did not receive any requests during the query interval\n            no_request_count = 0\n            \n            # Iterate through the server counts\n            for count in server_count:\n                # If the count is 0 for the server at the start time and non-zero at the end time, increment the no_request_count\n                if count == 0 and server_count[query - 1] != 0:\n                    no_request_count += 1\n            \n            # Append the no_request_count to the result\n            result.append(no_request_count)\n        \n        # Return the result\n        return result\n```", "extracted_code": "\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Create a list to store the count of requests received by each server at each time point\n        server_count = [0] * n\n        \n        # Iterate through the logs and increment the count for each server at the corresponding time point\n        for log in logs:\n            server_id, time = log\n            server_count[server_id - 1] += 1\n        \n        # Create a list to store the result\n        result = []\n        \n        # Iterate through the queries\n        for query in queries:\n            # Calculate the start and end time for the query interval\n            start_time = query - x\n            end_time = query\n            \n            # Initialize a count for servers that did not receive any requests during the query interval\n            no_request_count = 0\n            \n            # Iterate through the server counts\n            for count in server_count:\n                # If the count is 0 for the server at the start time and non-zero at the end time, increment the no_request_count\n                if count == 0 and server_count[query - 1] != 0:\n                    no_request_count += 1\n            \n            # Append the no_request_count to the result\n            result.append(no_request_count)\n        \n        # Return the result\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2744", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        pairs = 0\n        word_dict = {}\n        \n        for word in words:\n            reverse_word = word[::-1]\n            if reverse_word in word_dict and word_dict[reverse_word] > 0:\n                pairs += 1\n                word_dict[reverse_word] -= 1\n            else:\n                if word in word_dict:\n                    word_dict[word] += 1\n                else:\n                    word_dict[word] = 1\n        \n        return pairs\n```", "extracted_code": "\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        pairs = 0\n        word_dict = {}\n        \n        for word in words:\n            reverse_word = word[::-1]\n            if reverse_word in word_dict and word_dict[reverse_word] > 0:\n                pairs += 1\n                word_dict[reverse_word] -= 1\n            else:\n                if word in word_dict:\n                    word_dict[word] += 1\n                else:\n                    word_dict[word] = 1\n        \n        return pairs\n", "difficulty": 1.0}
{"task_id": "LeetCode/2742", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, n + 1):\n            dp[i][0] = dp[i-1][0] + cost[i-1]\n            dp[i][i] = dp[i-1][i-1] + time[i-1]\n        \n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                dp[i][j] = min(dp[i-1][j] + cost[i-1], dp[i-1][j-1] + time[i-1])\n        \n        return min(dp[n])\n```", "extracted_code": "\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, n + 1):\n            dp[i][0] = dp[i-1][0] + cost[i-1]\n            dp[i][i] = dp[i-1][i-1] + time[i-1]\n        \n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                dp[i][j] = min(dp[i-1][j] + cost[i-1], dp[i-1][j-1] + time[i-1])\n        \n        return min(dp[n])\n", "difficulty": 3.0}
{"task_id": "LeetCode/2736", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        prefix_sum1 = [0] * (n+1)\n        prefix_sum2 = [0] * (n+1)\n        for i in range(1, n+1):\n            prefix_sum1[i] = prefix_sum1[i-1] + nums1[i-1]\n            prefix_sum2[i] = prefix_sum2[i-1] + nums2[i-1]\n        \n        result = []\n        for x, y in queries:\n            max_sum = -1\n            for i in range(n):\n                if nums1[i] >= x and nums2[i] >= y:\n                    max_sum = max(max_sum, prefix_sum1[i+1] + prefix_sum2[i+1])\n            result.append(max_sum)\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        prefix_sum1 = [0] * (n+1)\n        prefix_sum2 = [0] * (n+1)\n        for i in range(1, n+1):\n            prefix_sum1[i] = prefix_sum1[i-1] + nums1[i-1]\n            prefix_sum2[i] = prefix_sum2[i-1] + nums2[i-1]\n        \n        result = []\n        for x, y in queries:\n            max_sum = -1\n            for i in range(n):\n                if nums1[i] >= x and nums2[i] >= y:\n                    max_sum = max(max_sum, prefix_sum1[i+1] + prefix_sum2[i+1])\n            result.append(max_sum)\n        \n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2734", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        if n == 1:\n            return s\n        for i in range(n-1, -1, -1):\n            if i == 0:\n                if s[i] == 'a':\n                    s = s[:i] + 'z' + s[i+1:]\n                else:\n                    s = s[:i] + chr(ord(s[i])-1) + s[i+1:]\n            elif s[i] != 'a':\n                s = s[:i] + chr(ord(s[i])-1) + s[i+1:]\n                break\n        return s\n```", "extracted_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        if n == 1:\n            return s\n        for i in range(n-1, -1, -1):\n            if i == 0:\n                if s[i] == 'a':\n                    s = s[:i] + 'z' + s[i+1:]\n                else:\n                    s = s[:i] + chr(ord(s[i])-1) + s[i+1:]\n            elif s[i] != 'a':\n                s = s[:i] + chr(ord(s[i])-1) + s[i+1:]\n                break\n        return s\n", "difficulty": 2.0}
{"task_id": "LeetCode/2732", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m = len(grid)\n        n = len(grid[0])\n        \n        row_sums = [sum(row) for row in grid]\n        \n        good_subset = []\n        for i in range(m):\n            if row_sums[i] <= m // 2:\n                good_subset.append(i)\n        \n        return good_subset\n```", "extracted_code": "\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m = len(grid)\n        n = len(grid[0])\n        \n        row_sums = [sum(row) for row in grid]\n        \n        good_subset = []\n        for i in range(m):\n            if row_sums[i] <= m // 2:\n                good_subset.append(i)\n        \n        return good_subset\n", "difficulty": 3.0}
{"task_id": "LeetCode/2730", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        if len(s) < 3:\n            return len(s)\n        \n        max_length = 2\n        current_length = 2\n        for i in range(2, len(s)):\n            if s[i] == s[i-1] == s[i-2]:\n                current_length = 2\n            else:\n                current_length += 1\n            max_length = max(max_length, current_length)\n        \n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        if len(s) < 3:\n            return len(s)\n        \n        max_length = 2\n        current_length = 2\n        for i in range(2, len(s)):\n            if s[i] == s[i-1] == s[i-2]:\n                current_length = 2\n            else:\n                current_length += 1\n            max_length = max(max_length, current_length)\n        \n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2729", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Convert n to string\n        n_str = str(n)\n        \n        # Concatenate n, 2*n, and 3*n\n        concatenated = n_str + str(2 * n) + str(3 * n)\n        \n        # Check if concatenated contains all digits from 1 to 9 exactly once\n        return set(concatenated) == set('123456789')", "extracted_code": "\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Convert n to string\n        n_str = str(n)\n        \n        # Concatenate n, 2*n, and 3*n\n        concatenated = n_str + str(2 * n) + str(3 * n)\n        \n        # Check if concatenated contains all digits from 1 to 9 exactly once\n        return set(concatenated) == set('123456789')", "difficulty": 1.0}
{"task_id": "LeetCode/2719", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        def digit_sum(n):\n            return sum(map(int, str(n)))\n        \n        def is_good(n):\n            return min_sum <= digit_sum(n) <= max_sum\n        \n        count = 0\n        num = int(num1)\n        \n        while num <= int(num2):\n            if is_good(num):\n                count += 1\n            num += 1\n        \n        return count % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        def digit_sum(n):\n            return sum(map(int, str(n)))\n        \n        def is_good(n):\n            return min_sum <= digit_sum(n) <= max_sum\n        \n        count = 0\n        num = int(num1)\n        \n        while num <= int(num2):\n            if is_good(num):\n                count += 1\n            num += 1\n        \n        return count % (10**9 + 7)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2716", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        left_count = [0] * 26\n        right_count = [0] * 26\n        for i in range(len(s)):\n            right_count[ord(s[i]) - ord('a')] += 1\n        \n        ans = float('inf')\n        for i in range(len(s)):\n            right_count[ord(s[i]) - ord('a')] -= 1\n            \n            j = i - 1\n            while j >= 0 and s[j] != s[i]:\n                left_count[ord(s[j]) - ord('a')] += 1\n                j -= 1\n            \n            ans = min(ans, i - j - 1 + self.minimizedStringLengthHelper(s, j - 1, left_count, right_count))\n            \n            j = i - 1\n            while j >= 0 and s[j] != s[i]:\n                left_count[ord(s[j]) - ord('a')] -= 1\n                j -= 1\n        \n        return 0 if ans == float('inf') else ans\n    \n    def minimizedStringLengthHelper(self, s, start, left_count, right_count):\n        if start < 0:\n            return 0\n        \n        ans = float('inf')\n        for i in range(start + 1, len(s)):\n            if s[i] == s[start]:\n                ans = min(ans, 1 + self.minimizedStringLengthHelper(s, i - 1, left_count, right_count))\n                break\n        \n        ans = min(ans, left_count[ord(s[start]) - ord('a')] + right_count[ord(s[start]) - ord('a')])\n        \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        left_count = [0] * 26\n        right_count = [0] * 26\n        for i in range(len(s)):\n            right_count[ord(s[i]) - ord('a')] += 1\n        \n        ans = float('inf')\n        for i in range(len(s)):\n            right_count[ord(s[i]) - ord('a')] -= 1\n            \n            j = i - 1\n            while j >= 0 and s[j] != s[i]:\n                left_count[ord(s[j]) - ord('a')] += 1\n                j -= 1\n            \n            ans = min(ans, i - j - 1 + self.minimizedStringLengthHelper(s, j - 1, left_count, right_count))\n            \n            j = i - 1\n            while j >= 0 and s[j] != s[i]:\n                left_count[ord(s[j]) - ord('a')] -= 1\n                j -= 1\n        \n        return 0 if ans == float('inf') else ans\n    \n    def minimizedStringLengthHelper(self, s, start, left_count, right_count):\n        if start < 0:\n            return 0\n        \n        ans = float('inf')\n        for i in range(start + 1, len(s)):\n            if s[i] == s[start]:\n                ans = min(ans, 1 + self.minimizedStringLengthHelper(s, i - 1, left_count, right_count))\n                break\n        \n        ans = min(ans, left_count[ord(s[start]) - ord('a')] + right_count[ord(s[start]) - ord('a')])\n        \n        return ans\n", "difficulty": 1.0}
{"task_id": "LeetCode/2713", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        max_cells = 0\n        \n        # Initialize a 2D dp array to store the maximum number of cells that can be visited starting from each cell\n        dp = [[0] * n for _ in range(m)]\n        \n        # Iterate over each cell in the matrix\n        for i in range(m):\n            for j in range(n):\n                # If dp[i][j] is already calculated, skip this cell\n                if dp[i][j] != 0:\n                    continue\n                \n                # Recursively calculate the maximum number of cells that can be visited starting from this cell\n                self.dfs(mat, dp, i, j)\n                \n                # Update the maximum number of cells\n                max_cells = max(max_cells, dp[i][j])\n        \n        return max_cells\n    \n    \n    def dfs(self, mat, dp, i, j):\n        m = len(mat)\n        n = len(mat[0])\n        \n        # If dp[i][j] is already calculated, return the value\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        # Initialize the maximum number of cells to 1 (the current cell)\n        dp[i][j] = 1\n        \n        # Check all possible directions (up, down, left, right)\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            x = i + dx\n            y = j + dy\n            \n            # Check if the new cell is within the matrix boundaries and the value is strictly greater than the current cell\n            if 0 <= x < m and 0 <= y < n and mat[x][y] > mat[i][j]:\n                # Recursively calculate the maximum number of cells that can be visited starting from the new cell\n                dp[i][j] = max(dp[i][j], 1 + self.dfs(mat, dp, x, y))\n        \n        return dp[i][j]\n```", "extracted_code": "\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        max_cells = 0\n        \n        # Initialize a 2D dp array to store the maximum number of cells that can be visited starting from each cell\n        dp = [[0] * n for _ in range(m)]\n        \n        # Iterate over each cell in the matrix\n        for i in range(m):\n            for j in range(n):\n                # If dp[i][j] is already calculated, skip this cell\n                if dp[i][j] != 0:\n                    continue\n                \n                # Recursively calculate the maximum number of cells that can be visited starting from this cell\n                self.dfs(mat, dp, i, j)\n                \n                # Update the maximum number of cells\n                max_cells = max(max_cells, dp[i][j])\n        \n        return max_cells\n    \n    \n    def dfs(self, mat, dp, i, j):\n        m = len(mat)\n        n = len(mat[0])\n        \n        # If dp[i][j] is already calculated, return the value\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        # Initialize the maximum number of cells to 1 (the current cell)\n        dp[i][j] = 1\n        \n        # Check all possible directions (up, down, left, right)\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            x = i + dx\n            y = j + dy\n            \n            # Check if the new cell is within the matrix boundaries and the value is strictly greater than the current cell\n            if 0 <= x < m and 0 <= y < n and mat[x][y] > mat[i][j]:\n                # Recursively calculate the maximum number of cells that can be visited starting from the new cell\n                dp[i][j] = max(dp[i][j], 1 + self.dfs(mat, dp, x, y))\n        \n        return dp[i][j]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2712", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        count_0 = s.count('0')\n        count_1 = s.count('1')\n        cost_0 = 0\n        cost_1 = 0\n        \n        for i in range(n):\n            if s[i] == '0':\n                count_0 -= 1\n                cost_0 += i + 1\n            else:\n                count_1 -= 1\n                cost_1 += n - i\n        \n            cost = min(cost, cost_0 + count_1) if cost != 0 else cost_0 + count_1\n            cost = min(cost, cost_1 + count_0) if cost != 0 else cost_1 + count_0\n        \n        return cost\n```", "extracted_code": "\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        count_0 = s.count('0')\n        count_1 = s.count('1')\n        cost_0 = 0\n        cost_1 = 0\n        \n        for i in range(n):\n            if s[i] == '0':\n                count_0 -= 1\n                cost_0 += i + 1\n            else:\n                count_1 -= 1\n                cost_1 += n - i\n        \n            cost = min(cost, cost_0 + count_1) if cost != 0 else cost_0 + count_1\n            cost = min(cost, cost_1 + count_0) if cost != 0 else cost_1 + count_0\n        \n        return cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2709", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        \n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if gcd(nums[i], nums[j]) == 1:\n                    return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        \n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if gcd(nums[i], nums[j]) == 1:\n                    return False\n        return True\n", "difficulty": 3.0}
{"task_id": "LeetCode/2708", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_strength = float('-inf')\n        \n        def backtrack(start, curr_strength):\n            nonlocal max_strength\n            \n            if start == n:\n                max_strength = max(max_strength, curr_strength)\n                return\n            \n            for i in range(start, n):\n                curr_strength *= nums[i]\n                backtrack(i + 1, curr_strength)\n                curr_strength //= nums[i]  # backtrack\n                \n        backtrack(0, 1)\n        return max_strength\n```", "extracted_code": "\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_strength = float('-inf')\n        \n        def backtrack(start, curr_strength):\n            nonlocal max_strength\n            \n            if start == n:\n                max_strength = max(max_strength, curr_strength)\n                return\n            \n            for i in range(start, n):\n                curr_strength *= nums[i]\n                backtrack(i + 1, curr_strength)\n                curr_strength //= nums[i]  # backtrack\n                \n        backtrack(0, 1)\n        return max_strength\n", "difficulty": 2.0}
{"task_id": "LeetCode/2707", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        def isSubsequence(s1, s2):\n            i = 0\n            j = 0\n            while i < len(s1) and j < len(s2):\n                if s1[i] == s2[j]:\n                    j += 1\n                i += 1\n            return j == len(s2)\n        \n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in dictionary:\n                if isSubsequence(s[:i], word):\n                    dp[i] = min(dp[i], dp[i - len(word)] + (i - len(word)))\n        \n        return dp[-1]\n```", "extracted_code": "\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        def isSubsequence(s1, s2):\n            i = 0\n            j = 0\n            while i < len(s1) and j < len(s2):\n                if s1[i] == s2[j]:\n                    j += 1\n                i += 1\n            return j == len(s2)\n        \n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for word in dictionary:\n                if isSubsequence(s[:i], word):\n                    dp[i] = min(dp[i], dp[i - len(word)] + (i - len(word)))\n        \n        return dp[-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2699", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        # Step 1: Initialize the adjacency list\n        adjacency_list = [[] for _ in range(n)]\n        \n        # Step 2: Create the adjacency list from the given edges\n        for a, b, w in edges:\n            adjacency_list[a].append((b, w))\n            adjacency_list[b].append((a, w))\n        \n        # Step 3: Create a distance array and initialize it with infinity\n        distance = [float('inf')] * n\n        \n        # Step 4: Initialize the distance of the source node as 0\n        distance[source] = 0\n        \n        # Step 5: Create a queue and add the source node to it\n        queue = [source]\n        \n        # Step 6: Perform BFS to find the shortest path from source to destination\n        while queue:\n            node = queue.pop(0)\n            for neighbor, weight in adjacency_list[node]:\n                if distance[neighbor] == float('inf'):\n                    distance[neighbor] = distance[node] + weight\n                    queue.append(neighbor)\n        \n        # Step 7: Modify the edges with weight -1 to achieve the target distance\n        modified_edges = []\n        for a, b, w in edges:\n            if w == -1:\n                modified_edges.append([a, b, target - distance[a] + distance[b]])\n            else:\n                modified_edges.append([a, b, w])\n        \n        # Step 8: Return the modified edges\n        return modified_edges\n```", "extracted_code": "\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        # Step 1: Initialize the adjacency list\n        adjacency_list = [[] for _ in range(n)]\n        \n        # Step 2: Create the adjacency list from the given edges\n        for a, b, w in edges:\n            adjacency_list[a].append((b, w))\n            adjacency_list[b].append((a, w))\n        \n        # Step 3: Create a distance array and initialize it with infinity\n        distance = [float('inf')] * n\n        \n        # Step 4: Initialize the distance of the source node as 0\n        distance[source] = 0\n        \n        # Step 5: Create a queue and add the source node to it\n        queue = [source]\n        \n        # Step 6: Perform BFS to find the shortest path from source to destination\n        while queue:\n            node = queue.pop(0)\n            for neighbor, weight in adjacency_list[node]:\n                if distance[neighbor] == float('inf'):\n                    distance[neighbor] = distance[node] + weight\n                    queue.append(neighbor)\n        \n        # Step 7: Modify the edges with weight -1 to achieve the target distance\n        modified_edges = []\n        for a, b, w in edges:\n            if w == -1:\n                modified_edges.append([a, b, target - distance[a] + distance[b]])\n            else:\n                modified_edges.append([a, b, w])\n        \n        # Step 8: Return the modified edges\n        return modified_edges\n", "difficulty": 3.0}
{"task_id": "LeetCode/2698", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def is_valid(i):\n            num_str = str(i * i)\n            partitions = []\n            start = 0\n            for end in range(1, len(num_str) + 1):\n                if sum(int(num_str[start:end])) == i:\n                    partitions.append(num_str[start:end])\n                    start = end\n            return len(partitions) == i\n        \n        punishment = 0\n        for i in range(1, n+1):\n            if is_valid(i):\n                punishment += i * i\n        return punishment\n```", "extracted_code": "\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def is_valid(i):\n            num_str = str(i * i)\n            partitions = []\n            start = 0\n            for end in range(1, len(num_str) + 1):\n                if sum(int(num_str[start:end])) == i:\n                    partitions.append(num_str[start:end])\n                    start = end\n            return len(partitions) == i\n        \n        punishment = 0\n        for i in range(1, n+1):\n            if is_valid(i):\n                punishment += i * i\n        return punishment\n", "difficulty": 2.0}
{"task_id": "LeetCode/2697", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        s = list(s)\n        \n        # helper function to check if a string is palindrome\n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        # iterate over the string from both ends\n        # and replace characters if necessary\n        for i in range(n//2):\n            j = n - i - 1\n            \n            if s[i] != s[j]:\n                # check if we can make the string palindrome\n                if isPalindrome(s[:i] + [s[j]] + s[i+1:j] + [s[i]] + s[j+1:]):\n                    s[j] = s[i]\n                else:\n                    s[i] = s[j]\n        \n        return ''.join(s)\n```", "extracted_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        s = list(s)\n        \n        # helper function to check if a string is palindrome\n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        # iterate over the string from both ends\n        # and replace characters if necessary\n        for i in range(n//2):\n            j = n - i - 1\n            \n            if s[i] != s[j]:\n                # check if we can make the string palindrome\n                if isPalindrome(s[:i] + [s[j]] + s[i+1:j] + [s[i]] + s[j+1:]):\n                    s[j] = s[i]\n                else:\n                    s[i] = s[j]\n        \n        return ''.join(s)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2681", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = int(1e9) + 7\n        n = len(nums)\n        max_val = max(nums)\n        min_val = min(nums)\n        power = max_val**2 * min_val\n        total_power = power * n\n        \n        # calculate the sum of power for all non-empty groups\n        for i in range(2, n+1):\n            power = max_val**2 * min(nums[i-1:i+1])\n            total_power += power\n        \n        return total_power % MOD\n```", "extracted_code": "\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = int(1e9) + 7\n        n = len(nums)\n        max_val = max(nums)\n        min_val = min(nums)\n        power = max_val**2 * min_val\n        total_power = power * n\n        \n        # calculate the sum of power for all non-empty groups\n        for i in range(2, n+1):\n            power = max_val**2 * min(nums[i-1:i+1])\n            total_power += power\n        \n        return total_power % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2680", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        max_value = 0\n        \n        for i in range(30, -1, -1):\n            count = 0\n            for num in nums:\n                if num & (1 << i):\n                    count += 1\n            if count <= k:\n                max_value |= (1 << i)\n                k -= count\n            if k == 0:\n                break\n        \n        return max_value\n```", "extracted_code": "\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        max_value = 0\n        \n        for i in range(30, -1, -1):\n            count = 0\n            for num in nums:\n                if num & (1 << i):\n                    count += 1\n            if count <= k:\n                max_value |= (1 << i)\n                k -= count\n            if k == 0:\n                break\n        \n        return max_value\n", "difficulty": 2.0}
{"task_id": "LeetCode/2670", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix = [0] * n\n        suffix = [0] * n\n        seen = set()\n        \n        # Calculate the number of distinct elements in the prefix for each index\n        for i in range(n):\n            seen.add(nums[i])\n            prefix[i] = len(seen)\n        \n        seen = set()\n        \n        # Calculate the number of distinct elements in the suffix for each index\n        for i in range(n-1, -1, -1):\n            seen.add(nums[i])\n            suffix[i] = len(seen)\n        \n        # Calculate the distinct difference array\n        diff = [prefix[i] - suffix[i+1] if i+1 < n else prefix[i] for i in range(n)]\n        \n        return diff\n```", "extracted_code": "\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix = [0] * n\n        suffix = [0] * n\n        seen = set()\n        \n        # Calculate the number of distinct elements in the prefix for each index\n        for i in range(n):\n            seen.add(nums[i])\n            prefix[i] = len(seen)\n        \n        seen = set()\n        \n        # Calculate the number of distinct elements in the suffix for each index\n        for i in range(n-1, -1, -1):\n            seen.add(nums[i])\n            suffix[i] = len(seen)\n        \n        # Calculate the distinct difference array\n        diff = [prefix[i] - suffix[i+1] if i+1 < n else prefix[i] for i in range(n)]\n        \n        return diff\n", "difficulty": 1.0}
{"task_id": "LeetCode/2663", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        n = len(s)\n        idx = -1\n        for i in range(n-1, -1, -1):\n            if ord(s[i]) - ord('a') + 1 < k:\n                idx = i\n                break\n        if idx == -1:\n            return \"\"\n        else:\n            new_s = s[:idx] + chr(ord(s[idx]) + 1) + 'a' * (n-idx-1)\n            return new_s\n```", "extracted_code": "\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        n = len(s)\n        idx = -1\n        for i in range(n-1, -1, -1):\n            if ord(s[i]) - ord('a') + 1 < k:\n                idx = i\n                break\n        if idx == -1:\n            return \"\"\n        else:\n            new_s = s[:idx] + chr(ord(s[idx]) + 1) + 'a' * (n-idx-1)\n            return new_s\n", "difficulty": 3.0}
{"task_id": "LeetCode/2659", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_val = min(nums)\n        min_idx = nums.index(min_val)\n        return min(min_idx, n - min_idx)\n```", "extracted_code": "\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_val = min(nums)\n        min_idx = nums.index(min_val)\n        return min(min_idx, n - min_idx)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2658", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        maxFish = 0\n        \n        def dfs(row, col):\n            nonlocal maxFish\n            \n            if row < 0 or row >= m or col < 0 or col >= n or grid[row][col] <= 0:\n                return\n            \n            fish = grid[row][col]\n            maxFish = max(maxFish, fish)\n            grid[row][col] = -1\n            \n            dfs(row+1, col)\n            dfs(row-1, col)\n            dfs(row, col+1)\n            dfs(row, col-1)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    dfs(i, j)\n        \n        return maxFish\n```", "extracted_code": "\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        maxFish = 0\n        \n        def dfs(row, col):\n            nonlocal maxFish\n            \n            if row < 0 or row >= m or col < 0 or col >= n or grid[row][col] <= 0:\n                return\n            \n            fish = grid[row][col]\n            maxFish = max(maxFish, fish)\n            grid[row][col] = -1\n            \n            dfs(row+1, col)\n            dfs(row-1, col)\n            dfs(row, col+1)\n            dfs(row, col-1)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    dfs(i, j)\n        \n        return maxFish\n", "difficulty": 2.0}
{"task_id": "LeetCode/2657", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        n = len(A)\n        prefix_common = [0] * n\n        \n        A_set = set()\n        B_set = set()\n        \n        for i in range(n):\n            A_set.add(A[i])\n            B_set.add(B[i])\n            \n            if A_set == B_set:\n                prefix_common[i] = i + 1\n                \n        return prefix_common\n```", "extracted_code": "\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        n = len(A)\n        prefix_common = [0] * n\n        \n        A_set = set()\n        B_set = set()\n        \n        for i in range(n):\n            A_set.add(A[i])\n            B_set.add(B[i])\n            \n            if A_set == B_set:\n                prefix_common[i] = i + 1\n                \n        return prefix_common\n", "difficulty": 2.0}
{"task_id": "LeetCode/2653", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        subarray_beauty = []\n        negatives = []\n        for i in range(k):\n            if nums[i] < 0:\n                negatives.append(nums[i])\n        negatives.sort()\n        if len(negatives) >= x:\n            subarray_beauty.append(negatives[x-1])\n        else:\n            subarray_beauty.append(0)\n        for i in range(k, len(nums)):\n            if nums[i] < 0:\n                negatives.append(nums[i])\n            if nums[i-k] < 0:\n                negatives.remove(nums[i-k])\n            negatives.sort()\n            if len(negatives) >= x:\n                subarray_beauty.append(negatives[x-1])\n            else:\n                subarray_beauty.append(0)\n        return subarray_beauty\n```", "extracted_code": "\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        subarray_beauty = []\n        negatives = []\n        for i in range(k):\n            if nums[i] < 0:\n                negatives.append(nums[i])\n        negatives.sort()\n        if len(negatives) >= x:\n            subarray_beauty.append(negatives[x-1])\n        else:\n            subarray_beauty.append(0)\n        for i in range(k, len(nums)):\n            if nums[i] < 0:\n                negatives.append(nums[i])\n            if nums[i-k] < 0:\n                negatives.remove(nums[i-k])\n            negatives.sort()\n            if len(negatives) >= x:\n                subarray_beauty.append(negatives[x-1])\n            else:\n                subarray_beauty.append(0)\n        return subarray_beauty\n", "difficulty": 2.0}
{"task_id": "LeetCode/2652", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n```", "extracted_code": "\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2651", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24\n```", "extracted_code": "\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24\n", "difficulty": 1.0}
{"task_id": "LeetCode/2646", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        # Create an adjacency list to represent the tree\n        adj_list = [[] for _ in range(n)]\n        for edge in edges:\n            u, v = edge\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        # Create a 2D array to store the price sums for each trip\n        dp = [[0] * n for _ in range(len(trips))]\n        \n        # Perform bottom-up dynamic programming\n        for i in range(len(trips)-1, -1, -1):\n            start, end = trips[i]\n            for j in range(n):\n                # If the current node is the end of the trip, set its price sum to the price of the node\n                if j == end:\n                    dp[i][j] = price[j]\n                else:\n                    # Iterate through the neighbors of the current node\n                    for neighbor in adj_list[j]:\n                        # If the neighbor is not the parent of the current node, add the price sum of the neighbor to the price sum of the current node\n                        if neighbor != start:\n                            dp[i][j] += dp[i+1][neighbor]\n        \n        # Return the minimum total price sum\n        return min(dp[0])\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        # Create an adjacency list to represent the tree\n        adj_list = [[] for _ in range(n)]\n        for edge in edges:\n            u, v = edge\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        # Create a 2D array to store the price sums for each trip\n        dp = [[0] * n for _ in range(len(trips))]\n        \n        # Perform bottom-up dynamic programming\n        for i in range(len(trips)-1, -1, -1):\n            start, end = trips[i]\n            for j in range(n):\n                # If the current node is the end of the trip, set its price sum to the price of the node\n                if j == end:\n                    dp[i][j] = price[j]\n                else:\n                    # Iterate through the neighbors of the current node\n                    for neighbor in adj_list[j]:\n                        # If the neighbor is not the parent of the current node, add the price sum of the neighbor to the price sum of the current node\n                        if neighbor != start:\n                            dp[i][j] += dp[i+1][neighbor]\n        \n        # Return the minimum total price sum\n        return min(dp[0])\n", "difficulty": 3.0}
{"task_id": "LeetCode/2645", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count_a = 0\n        count_b = 0\n        count_c = 0\n        \n        for char in word:\n            if char == 'a':\n                count_a += 1\n            elif char == 'b':\n                count_b += 1\n            elif char == 'c':\n                count_c += 1\n        \n        max_count = max(count_a, count_b, count_c)\n        \n        return len(word) - max_count * 3\n```", "extracted_code": "\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count_a = 0\n        count_b = 0\n        count_c = 0\n        \n        for char in word:\n            if char == 'a':\n                count_a += 1\n            elif char == 'b':\n                count_b += 1\n            elif char == 'c':\n                count_c += 1\n        \n        max_count = max(count_a, count_b, count_c)\n        \n        return len(word) - max_count * 3\n", "difficulty": 2.0}
{"task_id": "LeetCode/2642", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Graph:\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.adj_list = [[] for _ in range(n)]\n        for edge in edges:\n            from_node, to_node, cost = edge\n            self.adj_list[from_node].append((to_node, cost))\n\n    def addEdge(self, edge: List[int]) -> None:\n        from_node, to_node, cost = edge\n        self.adj_list[from_node].append((to_node, cost))\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        n = len(self.adj_list)\n        min_dist = [float('inf')] * n\n        min_dist[node1] = 0\n        min_heap = [(0, node1)]\n        \n        while min_heap:\n            dist, node = heapq.heappop(min_heap)\n            if dist > min_dist[node]:\n                continue\n            for neighbor, cost in self.adj_list[node]:\n                new_dist = dist + cost\n                if new_dist < min_dist[neighbor]:\n                    min_dist[neighbor] = new_dist\n                    heapq.heappush(min_heap, (new_dist, neighbor))\n        \n        if min_dist[node2] == float('inf'):\n            return -1\n        else:\n            return min_dist[node2]\n```", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Graph:\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.adj_list = [[] for _ in range(n)]\n        for edge in edges:\n            from_node, to_node, cost = edge\n            self.adj_list[from_node].append((to_node, cost))\n\n    def addEdge(self, edge: List[int]) -> None:\n        from_node, to_node, cost = edge\n        self.adj_list[from_node].append((to_node, cost))\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        n = len(self.adj_list)\n        min_dist = [float('inf')] * n\n        min_dist[node1] = 0\n        min_heap = [(0, node1)]\n        \n        while min_heap:\n            dist, node = heapq.heappop(min_heap)\n            if dist > min_dist[node]:\n                continue\n            for neighbor, cost in self.adj_list[node]:\n                new_dist = dist + cost\n                if new_dist < min_dist[neighbor]:\n                    min_dist[neighbor] = new_dist\n                    heapq.heappush(min_heap, (new_dist, neighbor))\n        \n        if min_dist[node2] == float('inf'):\n            return -1\n        else:\n            return min_dist[node2]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2640", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        \n        prefix_max = nums[0]\n        ans[0] = nums[0]\n        \n        for i in range(1, n):\n            prefix_max = max(prefix_max, nums[i])\n            ans[i] = nums[i] + prefix_max\n        \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        \n        prefix_max = nums[0]\n        ans[0] = nums[0]\n        \n        for i in range(1, n):\n            prefix_max = max(prefix_max, nums[i])\n            ans[i] = nums[i] + prefix_max\n        \n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2617", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                for k in range(i - grid[i][j], i):\n                    if k >= 0:\n                        dp[i][j] = min(dp[i][j], dp[k][j] + 1)\n                for k in range(j - grid[i][j], j):\n                    if k >= 0:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + 1)\n        \n        return dp[m-1][n-1] if dp[m-1][n-1] != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                for k in range(i - grid[i][j], i):\n                    if k >= 0:\n                        dp[i][j] = min(dp[i][j], dp[k][j] + 1)\n                for k in range(j - grid[i][j], j):\n                    if k >= 0:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + 1)\n        \n        return dp[m-1][n-1] if dp[m-1][n-1] != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2616", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums.sort()\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n        \n        def possible(max_diff):\n            min_moves = float('inf')\n            for i in range(p, n + 1):\n                min_moves = min(min_moves, prefix_sum[i] - prefix_sum[i - p] - max_diff * p)\n            return min_moves <= 0\n        \n        left = 0\n        right = nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n```", "extracted_code": "\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums.sort()\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n        \n        def possible(max_diff):\n            min_moves = float('inf')\n            for i in range(p, n + 1):\n                min_moves = min(min_moves, prefix_sum[i] - prefix_sum[i - p] - max_diff * p)\n            return min_moves <= 0\n        \n        left = 0\n        right = nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n", "difficulty": 2.0}
{"task_id": "LeetCode/2615", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [0] * n\n        \n        indices = {}\n        for i, num in enumerate(nums):\n            if num not in indices:\n                indices[num] = [i]\n            else:\n                indices[num].append(i)\n        \n        for i, num in enumerate(nums):\n            if len(indices[num]) == 1:\n                arr[i] = 0\n            else:\n                for j in indices[num]:\n                    if i != j:\n                        arr[i] += abs(i - j)\n        \n        return arr\n```", "extracted_code": "\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [0] * n\n        \n        indices = {}\n        for i, num in enumerate(nums):\n            if num not in indices:\n                indices[num] = [i]\n            else:\n                indices[num].append(i)\n        \n        for i, num in enumerate(nums):\n            if len(indices[num]) == 1:\n                arr[i] = 0\n            else:\n                for j in indices[num]:\n                    if i != j:\n                        arr[i] += abs(i - j)\n        \n        return arr\n", "difficulty": 2.0}
{"task_id": "LeetCode/2612", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        # Initialize the result array with -1s\n        ans = [-1] * n\n        \n        # Set the initial position to 0\n        ans[p] = 0\n        \n        # Iterate through the banned positions\n        for b in banned:\n            # If the banned position is within the reverse range, it is impossible to reach that position\n            if b >= p - k + 1 and b <= p + k - 1:\n                ans[b] = -1\n        \n        # Iterate through the array to find the minimum number of reverse operations needed for each position\n        for i in range(n):\n            # Skip the already set positions\n            if ans[i] != -1:\n                continue\n            \n            # Calculate the number of operations needed to bring the 1 to position i\n            operations = abs(p - i) // k\n            \n            # Check if the number of operations is even or odd\n            if operations % 2 == 0:\n                ans[i] = operations\n            else:\n                ans[i] = operations + 1\n        \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        # Initialize the result array with -1s\n        ans = [-1] * n\n        \n        # Set the initial position to 0\n        ans[p] = 0\n        \n        # Iterate through the banned positions\n        for b in banned:\n            # If the banned position is within the reverse range, it is impossible to reach that position\n            if b >= p - k + 1 and b <= p + k - 1:\n                ans[b] = -1\n        \n        # Iterate through the array to find the minimum number of reverse operations needed for each position\n        for i in range(n):\n            # Skip the already set positions\n            if ans[i] != -1:\n                continue\n            \n            # Calculate the number of operations needed to bring the 1 to position i\n            operations = abs(p - i) // k\n            \n            # Check if the number of operations is even or odd\n            if operations % 2 == 0:\n                ans[i] = operations\n            else:\n                ans[i] = operations + 1\n        \n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2608", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        # Initialize adjacency list\n        graph = [[] for _ in range(n)]\n        \n        # Build adjacency list from edges\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Initialize shortest cycle length\n        shortest_cycle = float('inf')\n        \n        # Perform BFS for each vertex\n        for start in range(n):\n            queue = [(start, 0)]\n            visited = set([start])\n            \n            while queue:\n                node, dist = queue.pop(0)\n                \n                # Check if current node is connected back to start\n                if node == start and dist > 0:\n                    shortest_cycle = min(shortest_cycle, dist)\n                    break\n                \n                # Enqueue unvisited neighbors\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, dist + 1))\n        \n        if shortest_cycle == float('inf'):\n            return -1\n        else:\n            return shortest_cycle\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        # Initialize adjacency list\n        graph = [[] for _ in range(n)]\n        \n        # Build adjacency list from edges\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Initialize shortest cycle length\n        shortest_cycle = float('inf')\n        \n        # Perform BFS for each vertex\n        for start in range(n):\n            queue = [(start, 0)]\n            visited = set([start])\n            \n            while queue:\n                node, dist = queue.pop(0)\n                \n                # Check if current node is connected back to start\n                if node == start and dist > 0:\n                    shortest_cycle = min(shortest_cycle, dist)\n                    break\n                \n                # Enqueue unvisited neighbors\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, dist + 1))\n        \n        if shortest_cycle == float('inf'):\n            return -1\n        else:\n            return shortest_cycle\n", "difficulty": 3.0}
{"task_id": "LeetCode/2603", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        # Create an adjacency list to represent the tree\n        adj_list = [[] for _ in range(len(coins))]\n        for edge in edges:\n            u, v = edge[0], edge[1]\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        # Initialize a visited array to keep track of visited nodes\n        visited = [False] * len(coins)\n        \n        # Start the DFS traversal from any node\n        start_node = 0\n        return self.dfs(adj_list, coins, visited, start_node)\n        \n    def dfs(self, adj_list, coins, visited, node):\n        # Mark the current node as visited\n        visited[node] = True\n        \n        # Initialize the number of edges required to collect all coins from the current node\n        edges_required = 0\n        \n        # Initialize the number of coins in the current node\n        coins_in_node = coins[node]\n        \n        # Traverse all adjacent nodes\n        for adj_node in adj_list[node]:\n            # If the adjacent node is not visited, perform DFS on it\n            if not visited[adj_node]:\n                edges_required += self.dfs(adj_list, coins, visited, adj_node)\n                \n                # Update the number of coins in the current node\n                coins_in_node += coins[adj_node]\n                \n                # Update the number of edges required if there are more than 2 coins in the current node\n                if coins_in_node >= 2:\n                    edges_required += 2\n                    coins_in_node -= 2\n        \n        # Return the number of edges required to collect all coins from the current node\n        return edges_required\n```", "extracted_code": "\nclass Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        # Create an adjacency list to represent the tree\n        adj_list = [[] for _ in range(len(coins))]\n        for edge in edges:\n            u, v = edge[0], edge[1]\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        # Initialize a visited array to keep track of visited nodes\n        visited = [False] * len(coins)\n        \n        # Start the DFS traversal from any node\n        start_node = 0\n        return self.dfs(adj_list, coins, visited, start_node)\n        \n    def dfs(self, adj_list, coins, visited, node):\n        # Mark the current node as visited\n        visited[node] = True\n        \n        # Initialize the number of edges required to collect all coins from the current node\n        edges_required = 0\n        \n        # Initialize the number of coins in the current node\n        coins_in_node = coins[node]\n        \n        # Traverse all adjacent nodes\n        for adj_node in adj_list[node]:\n            # If the adjacent node is not visited, perform DFS on it\n            if not visited[adj_node]:\n                edges_required += self.dfs(adj_list, coins, visited, adj_node)\n                \n                # Update the number of coins in the current node\n                coins_in_node += coins[adj_node]\n                \n                # Update the number of edges required if there are more than 2 coins in the current node\n                if coins_in_node >= 2:\n                    edges_required += 2\n                    coins_in_node -= 2\n        \n        # Return the number of edges required to collect all coins from the current node\n        return edges_required\n", "difficulty": 3.0}
{"task_id": "LeetCode/2601", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        for i in range(1, len(nums)):\n            if nums[i] <= nums[i-1]:\n                diff = nums[i-1] - nums[i] + 1\n                found_prime = False\n                for j in range(2, nums[i]):\n                    if is_prime(j) and nums[i-1] - j + 1 > nums[i]:\n                        found_prime = True\n                        break\n                if not found_prime:\n                    return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        for i in range(1, len(nums)):\n            if nums[i] <= nums[i-1]:\n                diff = nums[i-1] - nums[i] + 1\n                found_prime = False\n                for j in range(2, nums[i]):\n                    if is_prime(j) and nums[i-1] - j + 1 > nums[i]:\n                        found_prime = True\n                        break\n                if not found_prime:\n                    return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2592", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        count = 0\n        \n        for i in range(n):\n            if nums[i] > i:\n                count += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        count = 0\n        \n        for i in range(n):\n            if nums[i] > i:\n                count += 1\n        \n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2591", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        # If there are less than 8 dollars per child, return -1\n        if money // children < 8:\n            return -1\n       \n        # If the money can be evenly divided among the children, return the number of children\n        if money % children == 0:\n            return children\n        \n        # If there is enough money to give 8 dollars to at least one child, return 1\n        if money >= 8:\n            return 1\n        \n        # Otherwise, no distribution is possible\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        # If there are less than 8 dollars per child, return -1\n        if money // children < 8:\n            return -1\n       \n        # If the money can be evenly divided among the children, return the number of children\n        if money % children == 0:\n            return children\n        \n        # If there is enough money to give 8 dollars to at least one child, return 1\n        if money >= 8:\n            return 1\n        \n        # Otherwise, no distribution is possible\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2589", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        # Sort the tasks based on the end time in ascending order\n        tasks.sort(key=lambda x: x[1])\n        \n        # Initialize the current time and the total time\n        curr_time = 0\n        total_time = 0\n        \n        # Iterate through each task\n        for task in tasks:\n            # If the task start time is after the current time, update the current time\n            if task[0] > curr_time:\n                curr_time = task[0]\n            \n            # Update the current time and total time\n            curr_time += task[2]\n            total_time += task[2]\n        \n        return total_time\n```", "extracted_code": "\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        # Sort the tasks based on the end time in ascending order\n        tasks.sort(key=lambda x: x[1])\n        \n        # Initialize the current time and the total time\n        curr_time = 0\n        total_time = 0\n        \n        # Iterate through each task\n        for task in tasks:\n            # If the task start time is after the current time, update the current time\n            if task[0] > curr_time:\n                curr_time = task[0]\n            \n            # Update the current time and total time\n            curr_time += task[2]\n            total_time += task[2]\n        \n        return total_time\n", "difficulty": 3.0}
{"task_id": "LeetCode/2587", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        # Count the number of positive and negative integers\n        positives = [num for num in nums if num > 0]\n        negatives = [num for num in nums if num < 0]\n        \n        # Sort the positive integers in descending order\n        positives.sort(reverse=True)\n        \n        # Sort the negative integers in ascending order\n        negatives.sort()\n        \n        # Calculate the prefix sum array\n        prefix = [0] * len(nums)\n        prefix[0] = nums[0]\n        for i in range(1, len(nums)):\n            prefix[i] = prefix[i-1] + nums[i]\n        \n        # Calculate the maximum score\n        max_score = 0\n        for i in range(len(positives)):\n            score = i + 1\n            if i < len(negatives):\n                score += len(negatives) - i\n            if score > max_score:\n                max_score = score\n        \n        return max_score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        # Count the number of positive and negative integers\n        positives = [num for num in nums if num > 0]\n        negatives = [num for num in nums if num < 0]\n        \n        # Sort the positive integers in descending order\n        positives.sort(reverse=True)\n        \n        # Sort the negative integers in ascending order\n        negatives.sort()\n        \n        # Calculate the prefix sum array\n        prefix = [0] * len(nums)\n        prefix[0] = nums[0]\n        for i in range(1, len(nums)):\n            prefix[i] = prefix[i-1] + nums[i]\n        \n        # Calculate the maximum score\n        max_score = 0\n        for i in range(len(positives)):\n            score = i + 1\n            if i < len(negatives):\n                score += len(negatives) - i\n            if score > max_score:\n                max_score = score\n        \n        return max_score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2585", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        # Initializing a 2D dp array with 0s\n        dp = [[0] * (target+1) for _ in range(len(types))]\n        \n        # Base case: If the target is 0, there is 1 way to reach it (by not answering any questions)\n        for i in range(len(types)):\n            dp[i][0] = 1\n        \n        # Filling up the dp array\n        for i in range(len(types)):\n            for j in range(1, target+1):\n                count, marks = types[i]\n                for k in range(count+1):\n                    if j - k * marks >= 0:\n                        dp[i][j] += dp[i-1][j - k * marks]\n        \n        # Returning the result\n        return dp[-1][-1] % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        # Initializing a 2D dp array with 0s\n        dp = [[0] * (target+1) for _ in range(len(types))]\n        \n        # Base case: If the target is 0, there is 1 way to reach it (by not answering any questions)\n        for i in range(len(types)):\n            dp[i][0] = 1\n        \n        # Filling up the dp array\n        for i in range(len(types)):\n            for j in range(1, target+1):\n                count, marks = types[i]\n                for k in range(count+1):\n                    if j - k * marks >= 0:\n                        dp[i][j] += dp[i-1][j - k * marks]\n        \n        # Returning the result\n        return dp[-1][-1] % (10**9 + 7)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2584", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        import math\n        \n        n = len(nums)\n        \n        # Calculate the product of all elements in nums\n        product = math.prod(nums)\n        \n        # Initialize prefix and suffix arrays with 1\n        prefix = [1] * n\n        suffix = [1] * n\n        \n        # Calculate the prefix product\n        prefix[0] = nums[0]\n        for i in range(1, n):\n            prefix[i] = prefix[i-1] * nums[i]\n        \n        # Calculate the suffix product\n        suffix[n-1] = nums[n-1]\n        for i in range(n-2, -1, -1):\n            suffix[i] = suffix[i+1] * nums[i]\n        \n        # Check for valid splits\n        for i in range(n-1):\n            # Check if the product of the prefix and suffix is coprime with the total product\n            if math.gcd(prefix[i], suffix[i+1]) == 1:\n                return i\n        \n        return -1\n```", "extracted_code": "\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        import math\n        \n        n = len(nums)\n        \n        # Calculate the product of all elements in nums\n        product = math.prod(nums)\n        \n        # Initialize prefix and suffix arrays with 1\n        prefix = [1] * n\n        suffix = [1] * n\n        \n        # Calculate the prefix product\n        prefix[0] = nums[0]\n        for i in range(1, n):\n            prefix[i] = prefix[i-1] * nums[i]\n        \n        # Calculate the suffix product\n        suffix[n-1] = nums[n-1]\n        for i in range(n-2, -1, -1):\n            suffix[i] = suffix[i+1] * nums[i]\n        \n        # Check for valid splits\n        for i in range(n-1):\n            # Check if the product of the prefix and suffix is coprime with the total product\n            if math.gcd(prefix[i], suffix[i+1]) == 1:\n                return i\n        \n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2581", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = [[] for _ in range(n)]\n        \n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        indegree = [0] * n\n        for u, v in guesses:\n            indegree[v] += 1\n        \n        count = 0\n        for i in range(n):\n            if indegree[i] >= k:\n                count += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = [[] for _ in range(n)]\n        \n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        indegree = [0] * n\n        for u, v in guesses:\n            indegree[v] += 1\n        \n        count = 0\n        for i in range(n):\n            if indegree[i] >= k:\n                count += 1\n        \n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2579", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        if n == 1:\n            return 1\n        elif n == 2:\n            return 5\n        else:\n            return 5 * (n - 2) + 1\n```", "extracted_code": "\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        if n == 1:\n            return 1\n        elif n == 2:\n            return 5\n        else:\n            return 5 * (n - 2) + 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2577", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        # Create a 2D array to store the minimum time to reach each cell\n        dp = [[float('inf')] * n for _ in range(m)]\n        \n        # Set the minimum time for the starting cell to 0\n        dp[0][0] = 0\n        \n        # Iterate over each cell in the grid\n        for i in range(m):\n            for j in range(n):\n                # Check the minimum time to reach the current cell\n                # from the adjacent cells and update dp[i][j]\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], max(dp[i-1][j], grid[i][j]))\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], max(dp[i][j-1], grid[i][j]))\n        \n        # Check if it is possible to reach the bottom-right cell\n        # If not, return -1\n        if dp[m-1][n-1] == float('inf'):\n            return -1\n        \n        return dp[m-1][n-1]\n```", "extracted_code": "\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        # Create a 2D array to store the minimum time to reach each cell\n        dp = [[float('inf')] * n for _ in range(m)]\n        \n        # Set the minimum time for the starting cell to 0\n        dp[0][0] = 0\n        \n        # Iterate over each cell in the grid\n        for i in range(m):\n            for j in range(n):\n                # Check the minimum time to reach the current cell\n                # from the adjacent cells and update dp[i][j]\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], max(dp[i-1][j], grid[i][j]))\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], max(dp[i][j-1], grid[i][j]))\n        \n        # Check if it is possible to reach the bottom-right cell\n        # If not, return -1\n        if dp[m-1][n-1] == float('inf'):\n            return -1\n        \n        return dp[m-1][n-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2576", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        marked = set()\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if 2 * nums[i] <= nums[j] and i not in marked and j not in marked:\n                    marked.add(i)\n                    marked.add(j)\n                    break\n                    \n        return len(marked)\n```", "extracted_code": "\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        marked = set()\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if 2 * nums[i] <= nums[j] and i not in marked and j not in marked:\n                    marked.add(i)\n                    marked.add(j)\n                    break\n                    \n        return len(marked)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2573", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        word = \"\"\n        \n        for i in range(n):\n            # Check if lcp[i][i] is equal to n-i\n            if lcp[i][i] != n - i:\n                return \"\"\n            \n            # Find the next character in the word\n            char_index = lcp[i].index(n - i)\n            word += alphabet[char_index]\n            \n        return word\n```", "extracted_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        word = \"\"\n        \n        for i in range(n):\n            # Check if lcp[i][i] is equal to n-i\n            if lcp[i][i] != n - i:\n                return \"\"\n            \n            # Find the next character in the word\n            char_index = lcp[i].index(n - i)\n            word += alphabet[char_index]\n            \n        return word\n", "difficulty": 3.0}
{"task_id": "LeetCode/2570", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        merged = []\n        i, j = 0, 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i][0] < nums2[j][0]:\n                merged.append(nums1[i])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                merged.append(nums2[j])\n                j += 1\n            else:\n                merged.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n        \n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        \n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        return merged\n```", "extracted_code": "\nclass Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        merged = []\n        i, j = 0, 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i][0] < nums2[j][0]:\n                merged.append(nums1[i])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                merged.append(nums2[j])\n                j += 1\n            else:\n                merged.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n        \n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        \n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        return merged\n", "difficulty": 1.0}
{"task_id": "LeetCode/2569", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                for i in range(l, r+1):\n                    nums1[i] = 1 - nums1[i]\n            elif query[0] == 2:\n                p = query[1]\n                for i in range(len(nums1)):\n                    nums2[i] += nums1[i] * p\n            elif query[0] == 3:\n                result.append(sum(nums2))\n        return result\n```", "extracted_code": "\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                for i in range(l, r+1):\n                    nums1[i] = 1 - nums1[i]\n            elif query[0] == 2:\n                p = query[1]\n                for i in range(len(nums1)):\n                    nums2[i] += nums1[i] * p\n            elif query[0] == 3:\n                result.append(sum(nums2))\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2568", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        # Sort the array in non-decreasing order\n        nums.sort()\n        \n        # Initialize the minimum impossible number as 1\n        min_impossible = 1\n        \n        # Iterate through the sorted array\n        for num in nums:\n            # If the current number is greater than or equal to the minimum impossible number,\n            # update the minimum impossible number to be the bitwise OR of the current number and the minimum impossible number\n            if num >= min_impossible:\n                min_impossible |= num\n            # Otherwise, we have found the smallest positive non-zero integer that is not expressible from nums\n            else:\n                break\n        \n        return min_impossible\n```", "extracted_code": "\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        # Sort the array in non-decreasing order\n        nums.sort()\n        \n        # Initialize the minimum impossible number as 1\n        min_impossible = 1\n        \n        # Iterate through the sorted array\n        for num in nums:\n            # If the current number is greater than or equal to the minimum impossible number,\n            # update the minimum impossible number to be the bitwise OR of the current number and the minimum impossible number\n            if num >= min_impossible:\n                min_impossible |= num\n            # Otherwise, we have found the smallest positive non-zero integer that is not expressible from nums\n            else:\n                break\n        \n        return min_impossible\n", "difficulty": 2.0}
{"task_id": "LeetCode/2565", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            dp[i][0] = 0\n            \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n                    \n        score = float('inf')\n        \n        for j in range(1, n + 1):\n            if dp[m][j] != float('inf'):\n                left = dp[m][j]\n                right = n - j\n                score = min(score, right - left + 1)\n                \n        return score\n```", "extracted_code": "\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            dp[i][0] = 0\n            \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n                    \n        score = float('inf')\n        \n        for j in range(1, n + 1):\n            if dp[m][j] != float('inf'):\n                left = dp[m][j]\n                right = n - j\n                score = min(score, right - left + 1)\n                \n        return score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2564", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        ans = []\n        n = len(s)\n        \n        # Calculate the prefix XOR of the binary string\n        prefix_xor = [0]\n        for i in range(n):\n            prefix_xor.append(prefix_xor[-1] ^ int(s[i]))\n        \n        # For each query, find the leftmost occurrence of XOR value\n        # and the rightmost occurrence of XOR value + query[1]\n        for query in queries:\n            xor_val = query[0] ^ query[1]\n            left = -1\n            right = -1\n            \n            # Find the leftmost occurrence\n            for i in range(n+1):\n                if prefix_xor[i] == xor_val:\n                    left = i\n                    break\n            \n            # Find the rightmost occurrence\n            for i in range(n, left, -1):\n                if prefix_xor[i] == xor_val:\n                    right = i - 1\n                    break\n            \n            ans.append([left, right])\n        \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        ans = []\n        n = len(s)\n        \n        # Calculate the prefix XOR of the binary string\n        prefix_xor = [0]\n        for i in range(n):\n            prefix_xor.append(prefix_xor[-1] ^ int(s[i]))\n        \n        # For each query, find the leftmost occurrence of XOR value\n        # and the rightmost occurrence of XOR value + query[1]\n        for query in queries:\n            xor_val = query[0] ^ query[1]\n            left = -1\n            right = -1\n            \n            # Find the leftmost occurrence\n            for i in range(n+1):\n                if prefix_xor[i] == xor_val:\n                    left = i\n                    break\n            \n            # Find the rightmost occurrence\n            for i in range(n, left, -1):\n                if prefix_xor[i] == xor_val:\n                    right = i - 1\n                    break\n            \n            ans.append([left, right])\n        \n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2563", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        count = 0\n        prefix_sums = [0]\n        n = len(nums)\n        \n        # Calculate the prefix sums of the array\n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n        \n        # Count the fair pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                pair_sum = prefix_sums[j + 1] - prefix_sums[i]\n                if lower <= pair_sum <= upper:\n                    count += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        count = 0\n        prefix_sums = [0]\n        n = len(nums)\n        \n        # Calculate the prefix sums of the array\n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n        \n        # Count the fair pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                pair_sum = prefix_sums[j + 1] - prefix_sums[i]\n                if lower <= pair_sum <= upper:\n                    count += 1\n        \n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2561", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        m = len(basket1)\n        n = len(basket2)\n        total_cost = sum(basket1) + sum(basket2)\n        \n        if total_cost % m != 0 or total_cost % n != 0:\n            return -1\n        \n        target_cost = total_cost // (m + n)\n        cost1 = [0] * (target_cost + 1)\n        cost2 = [0] * (target_cost + 1)\n        \n        for i in range(m):\n            for j in range(target_cost, basket1[i] - 1, -1):\n                cost1[j] = max(cost1[j], cost1[j - basket1[i]] + basket1[i])\n            \n        for i in range(n):\n            for j in range(target_cost, basket2[i] - 1, -1):\n                cost2[j] = max(cost2[j], cost2[j - basket2[i]] + basket2[i])\n                \n        min_cost = float('inf')\n        for i in range(target_cost + 1):\n            min_cost = min(min_cost, max(cost1[i], cost2[target_cost - i]))\n            \n        return total_cost - min_cost\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        m = len(basket1)\n        n = len(basket2)\n        total_cost = sum(basket1) + sum(basket2)\n        \n        if total_cost % m != 0 or total_cost % n != 0:\n            return -1\n        \n        target_cost = total_cost // (m + n)\n        cost1 = [0] * (target_cost + 1)\n        cost2 = [0] * (target_cost + 1)\n        \n        for i in range(m):\n            for j in range(target_cost, basket1[i] - 1, -1):\n                cost1[j] = max(cost1[j], cost1[j - basket1[i]] + basket1[i])\n            \n        for i in range(n):\n            for j in range(target_cost, basket2[i] - 1, -1):\n                cost2[j] = max(cost2[j], cost2[j - basket2[i]] + basket2[i])\n                \n        min_cost = float('inf')\n        for i in range(target_cost + 1):\n            min_cost = min(min_cost, max(cost1[i], cost2[target_cost - i]))\n            \n        return total_cost - min_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2560", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = nums[0]\n        \n        for i in range(1, n):\n            dp[i][0] = max(nums[i], dp[i-1][1] + nums[i])\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1])\n        \n        return min(dp[n-1][0], dp[n-1][1])\n```", "extracted_code": "\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = nums[0]\n        \n        for i in range(1, n):\n            dp[i][0] = max(nums[i], dp[i-1][1] + nums[i])\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1])\n        \n        return min(dp[n-1][0], dp[n-1][1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2556", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        def dfs(row, col):\n            if row == m - 1 and col == n - 1:\n                return True\n            visited[row][col] = True\n            \n            if row + 1 < m and grid[row + 1][col] == 1 and not visited[row + 1][col]:\n                if dfs(row + 1, col):\n                    return True\n            if col + 1 < n and grid[row][col + 1] == 1 and not visited[row][col + 1]:\n                if dfs(row, col + 1):\n                    return True\n                    \n            return False\n        \n        if not dfs(0, 0):\n            return False\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    visited = [[False] * n for _ in range(m)]\n                    if not dfs(0, 0):\n                        return True\n        \n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        def dfs(row, col):\n            if row == m - 1 and col == n - 1:\n                return True\n            visited[row][col] = True\n            \n            if row + 1 < m and grid[row + 1][col] == 1 and not visited[row + 1][col]:\n                if dfs(row + 1, col):\n                    return True\n            if col + 1 < n and grid[row][col + 1] == 1 and not visited[row][col + 1]:\n                if dfs(row, col + 1):\n                    return True\n                    \n            return False\n        \n        if not dfs(0, 0):\n            return False\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    visited = [[False] * n for _ in range(m)]\n                    if not dfs(0, 0):\n                        return True\n        \n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2555", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        size = len(prizePositions)\n        left = [0] * size\n        right = [0] * size\n        \n        # Calculate the number of prizes on the left segment for each position\n        left[0] = 1\n        for i in range(1, size):\n            if prizePositions[i] - prizePositions[i-1] <= k:\n                left[i] = left[i-1] + 1\n            else:\n                left[i] = 1\n        \n        # Calculate the number of prizes on the right segment for each position\n        right[size-1] = 1\n        for i in range(size-2, -1, -1):\n            if prizePositions[i+1] - prizePositions[i] <= k:\n                right[i] = right[i+1] + 1\n            else:\n                right[i] = 1\n        \n        max_prizes = max(left[size-1], right[0])  # Initialize the maximum number of prizes\n        \n        # Iterate over each possible middle segment\n        for i in range(size-1):\n            # Check if the middle segment is valid\n            if prizePositions[i+1] - prizePositions[i] <= 2 * k:\n                # Calculate the number of prizes if the middle segment is selected\n                temp = left[i] + right[i+1]\n                max_prizes = max(max_prizes, temp)\n        \n        return max_prizes\n```", "extracted_code": "\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        size = len(prizePositions)\n        left = [0] * size\n        right = [0] * size\n        \n        # Calculate the number of prizes on the left segment for each position\n        left[0] = 1\n        for i in range(1, size):\n            if prizePositions[i] - prizePositions[i-1] <= k:\n                left[i] = left[i-1] + 1\n            else:\n                left[i] = 1\n        \n        # Calculate the number of prizes on the right segment for each position\n        right[size-1] = 1\n        for i in range(size-2, -1, -1):\n            if prizePositions[i+1] - prizePositions[i] <= k:\n                right[i] = right[i+1] + 1\n            else:\n                right[i] = 1\n        \n        max_prizes = max(left[size-1], right[0])  # Initialize the maximum number of prizes\n        \n        # Iterate over each possible middle segment\n        for i in range(size-1):\n            # Check if the middle segment is valid\n            if prizePositions[i+1] - prizePositions[i] <= 2 * k:\n                # Calculate the number of prizes if the middle segment is selected\n                temp = left[i] + right[i+1]\n                max_prizes = max(max_prizes, temp)\n        \n        return max_prizes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2554", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        # Sort the banned array in ascending order\n        banned.sort()\n        \n        # Initialize variables\n        count = 0\n        i = 1\n        currentSum = 0\n        \n        # Iterate through the range [1, n]\n        while i <= n and currentSum + i <= maxSum:\n            # If i is not in the banned array, increment count and add i to currentSum\n            if i not in banned:\n                count += 1\n                currentSum += i\n            i += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        # Sort the banned array in ascending order\n        banned.sort()\n        \n        # Initialize variables\n        count = 0\n        i = 1\n        currentSum = 0\n        \n        # Iterate through the range [1, n]\n        while i <= n and currentSum + i <= maxSum:\n            # If i is not in the banned array, increment count and add i to currentSum\n            if i not in banned:\n                count += 1\n                currentSum += i\n            i += 1\n        \n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2552", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n-3):\n            for j in range(i+1, n-2):\n                for k in range(j+1, n-1):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n-3):\n            for j in range(i+1, n-2):\n                for k in range(j+1, n-1):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2551", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        # Sort the weights in descending order\n        weights.sort(reverse=True)\n        \n        # Initialize the maximum and minimum scores as 0\n        max_score = 0\n        min_score = 0\n        \n        # Calculate the maximum score\n        for i in range(k):\n            max_score += weights[i] + weights[-i-1]\n        \n        # Calculate the minimum score\n        for i in range(len(weights) - k):\n            min_score += weights[i] + weights[i+k]\n        \n        # Return the difference between the maximum and minimum scores\n        return max_score - min_score\n```", "extracted_code": "\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        # Sort the weights in descending order\n        weights.sort(reverse=True)\n        \n        # Initialize the maximum and minimum scores as 0\n        max_score = 0\n        min_score = 0\n        \n        # Calculate the maximum score\n        for i in range(k):\n            max_score += weights[i] + weights[-i-1]\n        \n        # Calculate the minimum score\n        for i in range(len(weights) - k):\n            min_score += weights[i] + weights[i+k]\n        \n        # Return the difference between the maximum and minimum scores\n        return max_score - min_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2550", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        # if n is less than or equal to 3, there is no way for the monkeys to collide\n        if n <= 3:\n            return 0\n        \n        # calculate the total number of movements\n        total_movements = pow(2, n, 10**9 + 7) - n - 1\n        \n        return total_movements % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        # if n is less than or equal to 3, there is no way for the monkeys to collide\n        if n <= 3:\n            return 0\n        \n        # calculate the total number of movements\n        total_movements = pow(2, n, 10**9 + 7) - n - 1\n        \n        return total_movements % (10**9 + 7)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2547", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n        \n        unique_nums = []\n        for num in counts:\n            if counts[num] == 1:\n                unique_nums.append(num)\n        \n        min_cost = float('inf')\n        for i in range(1, len(nums)):\n            left_subarray = nums[:i]\n            right_subarray = nums[i:]\n            \n            left_cost = k + len([num for num in left_subarray if num not in unique_nums])\n            right_cost = k + len([num for num in right_subarray if num not in unique_nums])\n            \n            total_cost = left_cost + right_cost\n            min_cost = min(min_cost, total_cost)\n        \n        return min_cost\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        counts = {}\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n        \n        unique_nums = []\n        for num in counts:\n            if counts[num] == 1:\n                unique_nums.append(num)\n        \n        min_cost = float('inf')\n        for i in range(1, len(nums)):\n            left_subarray = nums[:i]\n            right_subarray = nums[i:]\n            \n            left_cost = k + len([num for num in left_subarray if num not in unique_nums])\n            right_cost = k + len([num for num in right_subarray if num not in unique_nums])\n            \n            total_cost = left_cost + right_cost\n            min_cost = min(min_cost, total_cost)\n        \n        return min_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2546", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        # Check if the count of '1' in s is greater than or equal to the count of '1' in target\n        # If so, we can make s equal to target by performing the operations\n        return s.count('1') >= target.count('1')\n```", "extracted_code": "\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        # Check if the count of '1' in s is greater than or equal to the count of '1' in target\n        # If so, we can make s equal to target by performing the operations\n        return s.count('1') >= target.count('1')\n", "difficulty": 2.0}
{"task_id": "LeetCode/2545", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        score.sort(key=lambda x: x[k], reverse=True)\n        return score\n```", "extracted_code": "\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        score.sort(key=lambda x: x[k], reverse=True)\n        return score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2543", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        # Base case: if targetX and targetY are both less than 1, return False\n        if targetX < 1 or targetY < 1:\n            return False\n        \n        # Recursive Case:\n        # Check if targetX is divisible by targetY\n        if targetY != 1 and targetX % targetY == 0:\n            return self.isReachable(targetX // targetY, targetY)\n        \n        # Check if targetY is divisible by targetX\n        if targetX != 1 and targetY % targetX == 0:\n            return self.isReachable(targetX, targetY // targetX)\n        \n        # Check if targetX and targetY are both odd\n        if targetX % 2 == 1 and targetY % 2 == 1:\n            return False\n        \n        # Check if targetX and targetY are both even\n        if targetX % 2 == 0 and targetY % 2 == 0:\n            return self.isReachable(targetX // 2, targetY // 2)\n        \n        # If none of the above conditions are met, return False\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        # Base case: if targetX and targetY are both less than 1, return False\n        if targetX < 1 or targetY < 1:\n            return False\n        \n        # Recursive Case:\n        # Check if targetX is divisible by targetY\n        if targetY != 1 and targetX % targetY == 0:\n            return self.isReachable(targetX // targetY, targetY)\n        \n        # Check if targetY is divisible by targetX\n        if targetX != 1 and targetY % targetX == 0:\n            return self.isReachable(targetX, targetY // targetX)\n        \n        # Check if targetX and targetY are both odd\n        if targetX % 2 == 1 and targetY % 2 == 1:\n            return False\n        \n        # Check if targetX and targetY are both even\n        if targetX % 2 == 0 and targetY % 2 == 0:\n            return self.isReachable(targetX // 2, targetY // 2)\n        \n        # If none of the above conditions are met, return False\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2538", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        # Create an adjacency list to represent the tree\n        tree = [[] for _ in range(n)]\n        for edge in edges:\n            u, v = edge\n            tree[u].append(v)\n            tree[v].append(u)\n        \n        # Helper function to calculate the price sum of a path\n        def calculatePriceSum(node, parent):\n            curr_sum = price[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    curr_sum += calculatePriceSum(neighbor, node)\n            return curr_sum\n        \n        # Helper function to find the maximum and minimum price sum starting from a given node\n        def dfs(node, parent):\n            max_sum = price[node]\n            min_sum = price[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    neighbor_sum = calculatePriceSum(neighbor, node)\n                    max_sum = max(max_sum, neighbor_sum)\n                    min_sum = min(min_sum, neighbor_sum)\n            return max_sum - min_sum\n        \n        # Iterate through all possible root nodes and find the maximum cost\n        max_cost = 0\n        for i in range(n):\n            max_cost = max(max_cost, dfs(i, -1))\n        \n        return max_cost\n```", "extracted_code": "\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        # Create an adjacency list to represent the tree\n        tree = [[] for _ in range(n)]\n        for edge in edges:\n            u, v = edge\n            tree[u].append(v)\n            tree[v].append(u)\n        \n        # Helper function to calculate the price sum of a path\n        def calculatePriceSum(node, parent):\n            curr_sum = price[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    curr_sum += calculatePriceSum(neighbor, node)\n            return curr_sum\n        \n        # Helper function to find the maximum and minimum price sum starting from a given node\n        def dfs(node, parent):\n            max_sum = price[node]\n            min_sum = price[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    neighbor_sum = calculatePriceSum(neighbor, node)\n                    max_sum = max(max_sum, neighbor_sum)\n                    min_sum = min(min_sum, neighbor_sum)\n            return max_sum - min_sum\n        \n        # Iterate through all possible root nodes and find the maximum cost\n        max_cost = 0\n        for i in range(n):\n            max_cost = max(max_cost, dfs(i, -1))\n        \n        return max_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2532", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # Sort the workers based on their efficiency\n        time.sort(key=lambda x: (x[0] + x[2], x[1]))\n        \n        # Initialize variables\n        left_to_right = []\n        right_to_left = []\n        \n        # Iterate through the workers\n        for i in range(k):\n            # Check if the bridge is free\n            if len(right_to_left) == 0:\n                # Check if there are boxes remaining\n                if n > 0:\n                    # Worker crosses the bridge from left to right\n                    left_to_right.append(time[i][0])\n                    # Worker picks up a box\n                    left_to_right.append(time[i][1])\n                    # Update the remaining boxes\n                    n -= 1\n                else:\n                    # Worker crosses the bridge from left to right\n                    left_to_right.append(time[i][0])\n                    # Worker crosses the bridge from right to left\n                    left_to_right.append(time[i][2])\n                    # Worker puts a box\n                    left_to_right.append(time[i][3])\n                    # Worker crosses the bridge from left to right\n                    left_to_right.append(time[i][0])\n            else:\n                # Worker waits on the right side of the bridge\n                right_to_left.append(time[i][2])\n        \n        # Calculate the total time\n        total_time = max(sum(left_to_right), sum(right_to_left))\n        \n        return total_time\n```", "extracted_code": "\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        # Sort the workers based on their efficiency\n        time.sort(key=lambda x: (x[0] + x[2], x[1]))\n        \n        # Initialize variables\n        left_to_right = []\n        right_to_left = []\n        \n        # Iterate through the workers\n        for i in range(k):\n            # Check if the bridge is free\n            if len(right_to_left) == 0:\n                # Check if there are boxes remaining\n                if n > 0:\n                    # Worker crosses the bridge from left to right\n                    left_to_right.append(time[i][0])\n                    # Worker picks up a box\n                    left_to_right.append(time[i][1])\n                    # Update the remaining boxes\n                    n -= 1\n                else:\n                    # Worker crosses the bridge from left to right\n                    left_to_right.append(time[i][0])\n                    # Worker crosses the bridge from right to left\n                    left_to_right.append(time[i][2])\n                    # Worker puts a box\n                    left_to_right.append(time[i][3])\n                    # Worker crosses the bridge from left to right\n                    left_to_right.append(time[i][0])\n            else:\n                # Worker waits on the right side of the bridge\n                right_to_left.append(time[i][2])\n        \n        # Calculate the total time\n        total_time = max(sum(left_to_right), sum(right_to_left))\n        \n        return total_time\n", "difficulty": 3.0}
{"task_id": "LeetCode/2531", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n        \n        count1 = [0] * 26\n        count2 = [0] * 26\n        \n        for ch in word1:\n            count1[ord(ch) - ord('a')] += 1\n        \n        for ch in word2:\n            count2[ord(ch) - ord('a')] += 1\n        \n        diffCount = 0\n        for i in range(26):\n            if count1[i] != count2[i]:\n                diffCount += 1\n                if diffCount > 1:\n                    return False\n        \n        return True\n```", "extracted_code": "\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n        \n        count1 = [0] * 26\n        count2 = [0] * 26\n        \n        for ch in word1:\n            count1[ord(ch) - ord('a')] += 1\n        \n        for ch in word2:\n            count2[ord(ch) - ord('a')] += 1\n        \n        diffCount = 0\n        for i in range(26):\n            if count1[i] != count2[i]:\n                diffCount += 1\n                if diffCount > 1:\n                    return False\n        \n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2528", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        max_powers = [0] * n\n        \n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + stations[i]\n        \n        for i in range(n):\n            left = max(0, i - r)\n            right = min(n-1, i + r)\n            max_powers[i] = prefix_sum[right+1] - prefix_sum[left]\n        \n        max_powers.sort(reverse=True)\n        total_power = prefix_sum[n]\n        \n        for i in range(k):\n            if max_powers[i] >= max_powers[0]:\n                break\n            total_power += max_powers[i] - max_powers[0]\n        \n        return max_powers[0] + (total_power + k) // (k+1)\n```", "extracted_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        max_powers = [0] * n\n        \n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + stations[i]\n        \n        for i in range(n):\n            left = max(0, i - r)\n            right = min(n-1, i + r)\n            max_powers[i] = prefix_sum[right+1] - prefix_sum[left]\n        \n        max_powers.sort(reverse=True)\n        total_power = prefix_sum[n]\n        \n        for i in range(k):\n            if max_powers[i] >= max_powers[0]:\n                break\n            total_power += max_powers[i] - max_powers[0]\n        \n        return max_powers[0] + (total_power + k) // (k+1)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2523", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        primes = []\n        for num in range(left, right + 1):\n            if is_prime(num):\n                primes.append(num)\n                \n        if len(primes) < 2:\n            return [-1, -1]\n        \n        min_diff = float('inf')\n        ans = [-1, -1]\n        for i in range(len(primes) - 1):\n            diff = primes[i+1] - primes[i]\n            if diff < min_diff:\n                min_diff = diff\n                ans = [primes[i], primes[i+1]]\n                \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        primes = []\n        for num in range(left, right + 1):\n            if is_prime(num):\n                primes.append(num)\n                \n        if len(primes) < 2:\n            return [-1, -1]\n        \n        min_diff = float('inf')\n        ans = [-1, -1]\n        for i in range(len(primes) - 1):\n            diff = primes[i+1] - primes[i]\n            if diff < min_diff:\n                min_diff = diff\n                ans = [primes[i], primes[i+1]]\n                \n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2521", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**(0.5))+1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        prime_factors = set()\n        for num in nums:\n            for i in range(2, int(num**(0.5))+1):\n                if num % i == 0 and is_prime(i):\n                    prime_factors.add(i)\n                    while num % i == 0:\n                        num //= i\n            if num > 1 and is_prime(num):\n                prime_factors.add(num)\n                \n        return len(prime_factors)\n```", "extracted_code": "\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**(0.5))+1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        prime_factors = set()\n        for num in nums:\n            for i in range(2, int(num**(0.5))+1):\n                if num % i == 0 and is_prime(i):\n                    prime_factors.add(i)\n                    while num % i == 0:\n                        num //= i\n            if num > 1 and is_prime(num):\n                prime_factors.add(num)\n                \n        return len(prime_factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2518", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i - 1]]\n                dp[i][j] %= (10**9 + 7)\n        \n        return dp[n][k]\n```", "extracted_code": "\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i - 1]]\n                dp[i][j] %= (10**9 + 7)\n        \n        return dp[n][k]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2517", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        left, right = 0, k - 1\n        max_tastiness = 0\n        \n        while right < len(price):\n            max_tastiness = max(max_tastiness, price[right] - price[left])\n            left += 1\n            right += 1\n        \n        return max_tastiness\n```", "extracted_code": "\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        left, right = 0, k - 1\n        max_tastiness = 0\n        \n        while right < len(price):\n            max_tastiness = max(max_tastiness, price[right] - price[left])\n            left += 1\n            right += 1\n        \n        return max_tastiness\n", "difficulty": 2.0}
{"task_id": "LeetCode/2516", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        # Count the occurrences of each character in the string\n        counts = {char: s.count(char) for char in set(s)}\n        \n        # Check if it is possible to take k of each character\n        if any(count < k for count in counts.values()):\n            return -1\n        \n        # Initialize the left and right pointers\n        left = 0\n        right = len(s) - 1\n        \n        # Initialize the number of minutes\n        minutes = 0\n        \n        # Take characters from the left and right until we have at least k of each character\n        while True:\n            # Check if we have at least k of each character\n            if all(count >= k for count in counts.values()):\n                return minutes\n            \n            # Take the character from the left if it is needed\n            if counts[s[left]] < k:\n                counts[s[left]] += 1\n                left += 1\n                minutes += 1\n            \n            # Take the character from the right if it is needed\n            elif counts[s[right]] < k:\n                counts[s[right]] += 1\n                right -= 1\n                minutes += 1\n            \n            # If we can't take any more characters from the left or right, return -1\n            else:\n                return -1\n```", "extracted_code": "\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        # Count the occurrences of each character in the string\n        counts = {char: s.count(char) for char in set(s)}\n        \n        # Check if it is possible to take k of each character\n        if any(count < k for count in counts.values()):\n            return -1\n        \n        # Initialize the left and right pointers\n        left = 0\n        right = len(s) - 1\n        \n        # Initialize the number of minutes\n        minutes = 0\n        \n        # Take characters from the left and right until we have at least k of each character\n        while True:\n            # Check if we have at least k of each character\n            if all(count >= k for count in counts.values()):\n                return minutes\n            \n            # Take the character from the left if it is needed\n            if counts[s[left]] < k:\n                counts[s[left]] += 1\n                left += 1\n                minutes += 1\n            \n            # Take the character from the right if it is needed\n            elif counts[s[right]] < k:\n                counts[s[right]] += 1\n                right -= 1\n                minutes += 1\n            \n            # If we can't take any more characters from the left or right, return -1\n            else:\n                return -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2514", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        word_list = s.split()\n        word_counts = {}\n        \n        for word in word_list:\n            sorted_word = ''.join(sorted(word))\n            if sorted_word in word_counts:\n                word_counts[sorted_word] += 1\n            else:\n                word_counts[sorted_word] = 1\n        \n        total_anagrams = 1\n        for count in word_counts.values():\n            total_anagrams = (total_anagrams * count) % (10**9 + 7)\n        \n        return total_anagrams\n```", "extracted_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        word_list = s.split()\n        word_counts = {}\n        \n        for word in word_list:\n            sorted_word = ''.join(sorted(word))\n            if sorted_word in word_counts:\n                word_counts[sorted_word] += 1\n            else:\n                word_counts[sorted_word] = 1\n        \n        total_anagrams = 1\n        for count in word_counts.values():\n            total_anagrams = (total_anagrams * count) % (10**9 + 7)\n        \n        return total_anagrams\n", "difficulty": 3.0}
{"task_id": "LeetCode/2513", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        # Find the maximum number of unique integers that can be added to arr1 and arr2\n        max_unique = uniqueCnt1 + uniqueCnt2\n        \n        # Find the minimum possible maximum integer\n        # Start with the maximum possible value (divisor1 * uniqueCnt1 + divisor2 * uniqueCnt2)\n        # Then iterate through all possible values from 1 to the maximum possible value\n        # and check if each value satisfies the conditions\n        for i in range(1, divisor1 * uniqueCnt1 + divisor2 * uniqueCnt2 + 1):\n            # Check if i is not divisible by divisor1 and divisor2\n            if i % divisor1 != 0 and i % divisor2 != 0:\n                # Check if adding i to arr1 and arr2 results in the maximum number of unique integers\n                if len(set(range(1, i + 1)) - set(range(1, i + 1, divisor1))) >= uniqueCnt1 and len(set(range(1, i + 1)) - set(range(1, i + 1, divisor2))) >= uniqueCnt2:\n                    return i\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        # Find the maximum number of unique integers that can be added to arr1 and arr2\n        max_unique = uniqueCnt1 + uniqueCnt2\n        \n        # Find the minimum possible maximum integer\n        # Start with the maximum possible value (divisor1 * uniqueCnt1 + divisor2 * uniqueCnt2)\n        # Then iterate through all possible values from 1 to the maximum possible value\n        # and check if each value satisfies the conditions\n        for i in range(1, divisor1 * uniqueCnt1 + divisor2 * uniqueCnt2 + 1):\n            # Check if i is not divisible by divisor1 and divisor2\n            if i % divisor1 != 0 and i % divisor2 != 0:\n                # Check if adding i to arr1 and arr2 results in the maximum number of unique integers\n                if len(set(range(1, i + 1)) - set(range(1, i + 1, divisor1))) >= uniqueCnt1 and len(set(range(1, i + 1)) - set(range(1, i + 1, divisor2))) >= uniqueCnt2:\n                    return i\n        return -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2512", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        # Create a dictionary to store the points of each student\n        points = {}\n        \n        # Initialize the points of each student to 0\n        for id in student_id:\n            points[id] = 0\n        \n        # Calculate the points for each student based on the feedback reports\n        for i in range(len(report)):\n            words = report[i].split()\n            for word in words:\n                if word in positive_feedback:\n                    points[student_id[i]] += 3\n                elif word in negative_feedback:\n                    points[student_id[i]] -= 1\n        \n        # Sort the students based on their points in non-increasing order\n        sorted_students = sorted(points.items(), key=lambda x: (-x[1], x[0]))\n        \n        # Return the top k students\n        return [student[0] for student in sorted_students[:k]]\n```", "extracted_code": "\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        # Create a dictionary to store the points of each student\n        points = {}\n        \n        # Initialize the points of each student to 0\n        for id in student_id:\n            points[id] = 0\n        \n        # Calculate the points for each student based on the feedback reports\n        for i in range(len(report)):\n            words = report[i].split()\n            for word in words:\n                if word in positive_feedback:\n                    points[student_id[i]] += 3\n                elif word in negative_feedback:\n                    points[student_id[i]] -= 1\n        \n        # Sort the students based on their points in non-increasing order\n        sorted_students = sorted(points.items(), key=lambda x: (-x[1], x[0]))\n        \n        # Return the top k students\n        return [student[0] for student in sorted_students[:k]]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2509", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def findRoot(x):\n            while x != parent[x]:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n        \n        def union(x, y):\n            rootX = findRoot(x)\n            rootY = findRoot(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n        \n        def findCycleLength(x):\n            cycleLength = 0\n            while x != parent[x]:\n                cycleLength += 1\n                x = parent[x]\n            return cycleLength\n        \n        parent = [i for i in range(2 ** n)]\n        answer = []\n        \n        for query in queries:\n            a, b = query[0], query[1]\n            rootA = findRoot(a)\n            rootB = findRoot(b)\n            if rootA != rootB:\n                union(a, b)\n                answer.append(findCycleLength(a) + 2)\n            else:\n                answer.append(findCycleLength(a) + 1)\n                \n        return answer\n```", "extracted_code": "\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def findRoot(x):\n            while x != parent[x]:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n        \n        def union(x, y):\n            rootX = findRoot(x)\n            rootY = findRoot(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n        \n        def findCycleLength(x):\n            cycleLength = 0\n            while x != parent[x]:\n                cycleLength += 1\n                x = parent[x]\n            return cycleLength\n        \n        parent = [i for i in range(2 ** n)]\n        answer = []\n        \n        for query in queries:\n            a, b = query[0], query[1]\n            rootA = findRoot(a)\n            rootB = findRoot(b)\n            if rootA != rootB:\n                union(a, b)\n                answer.append(findCycleLength(a) + 2)\n            else:\n                answer.append(findCycleLength(a) + 1)\n                \n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2508", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degrees = [0] * (n+1)\n        for edge in edges:\n            degrees[edge[0]] += 1\n            degrees[edge[1]] += 1\n        odd_count = 0\n        for degree in degrees:\n            if degree % 2 != 0:\n                odd_count += 1\n        if odd_count == 0 or odd_count == 2:\n            return True\n        return False\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degrees = [0] * (n+1)\n        for edge in edges:\n            degrees[edge[0]] += 1\n            degrees[edge[1]] += 1\n        odd_count = 0\n        for degree in degrees:\n            if degree % 2 != 0:\n                odd_count += 1\n        if odd_count == 0 or odd_count == 2:\n            return True\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2507", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        def get_prime_factors(num):\n            factors = []\n            i = 2\n            while i * i <= num:\n                if num % i:\n                    i += 1\n                else:\n                    num //= i\n                    factors.append(i)\n            if num > 1:\n                factors.append(num)\n            return factors\n        \n        while True:\n            prime_factors = get_prime_factors(n)\n            if len(prime_factors) == 1:\n                return prime_factors[0]\n            n = sum(prime_factors)\n```", "extracted_code": "\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        def get_prime_factors(num):\n            factors = []\n            i = 2\n            while i * i <= num:\n                if num % i:\n                    i += 1\n                else:\n                    num //= i\n                    factors.append(i)\n            if num > 1:\n                factors.append(num)\n            return factors\n        \n        while True:\n            prime_factors = get_prime_factors(n)\n            if len(prime_factors) == 1:\n                return prime_factors[0]\n            n = sum(prime_factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2503", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + grid[i - 1][j - 1]\n        \n        answer = []\n        for q in queries:\n            count = 0\n            for i in range(1, m - q + 2):\n                for j in range(1, n - q + 2):\n                    total = prefix_sum[i + q - 1][j + q - 1] - prefix_sum[i - 1][j + q - 1] - prefix_sum[i + q - 1][j - 1] + prefix_sum[i - 1][j - 1]\n                    if total == q * q:\n                        count += 1\n            answer.append(count)\n        \n        return answer\n```", "extracted_code": "\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + grid[i - 1][j - 1]\n        \n        answer = []\n        for q in queries:\n            count = 0\n            for i in range(1, m - q + 2):\n                for j in range(1, n - q + 2):\n                    total = prefix_sum[i + q - 1][j + q - 1] - prefix_sum[i - 1][j + q - 1] - prefix_sum[i + q - 1][j - 1] + prefix_sum[i - 1][j - 1]\n                    if total == q * q:\n                        count += 1\n            answer.append(count)\n        \n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2501", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        squares = set([num**2 for num in nums])\n        max_length = -1\n        \n        for num in nums:\n            if num * num not in squares:\n                continue\n            \n            length = 2\n            prev = num\n            curr = num * num\n            \n            while curr in squares:\n                length += 1\n                temp = curr\n                curr = curr * curr\n                prev = temp\n                \n            max_length = max(max_length, length)\n            \n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        squares = set([num**2 for num in nums])\n        max_length = -1\n        \n        for num in nums:\n            if num * num not in squares:\n                continue\n            \n            length = 2\n            prev = num\n            curr = num * num\n            \n            while curr in squares:\n                length += 1\n                temp = curr\n                curr = curr * curr\n                prev = temp\n                \n            max_length = max(max_length, length)\n            \n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2499", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        cost = 0\n        diff_count = 0\n        \n        for i in range(n):\n            if nums1[i] == nums2[i]:\n                continue\n            elif i < n-1 and nums1[i] == nums2[i+1] and nums1[i+1] == nums2[i]:\n                cost += 2\n                nums1[i], nums1[i+1] = nums1[i+1], nums1[i]\n            else:\n                diff_count += 1\n        \n        if diff_count % 2 != 0:\n            return -1\n        \n        return cost + diff_count // 2\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        cost = 0\n        diff_count = 0\n        \n        for i in range(n):\n            if nums1[i] == nums2[i]:\n                continue\n            elif i < n-1 and nums1[i] == nums2[i+1] and nums1[i+1] == nums2[i]:\n                cost += 2\n                nums1[i], nums1[i+1] = nums1[i+1], nums1[i]\n            else:\n                diff_count += 1\n        \n        if diff_count % 2 != 0:\n            return -1\n        \n        return cost + diff_count // 2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2498", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [float('inf')] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                jump = stones[j] - stones[i]\n                \n                if jump <= 2 * (j - i):\n                    dp[j] = min(dp[j], max(jump, dp[i]))\n                else:\n                    break\n        \n        return dp[-1]\n```", "extracted_code": "\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [float('inf')] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                jump = stones[j] - stones[i]\n                \n                if jump <= 2 * (j - i):\n                    dp[j] = min(dp[j], max(jump, dp[i]))\n                else:\n                    break\n        \n        return dp[-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2497", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        # Create a dictionary to store the neighbors of each node\n        graph = {}\n        for edge in edges:\n            node1, node2 = edge\n            if node1 not in graph:\n                graph[node1] = []\n            if node2 not in graph:\n                graph[node2] = []\n            graph[node1].append(node2)\n            graph[node2].append(node1)\n        \n        # Create a list to store the sums of each star graph\n        sums = []\n        \n        # Iterate through each node\n        for node in range(len(vals)):\n            # If the node has less than k neighbors, skip it\n            if node in graph and len(graph[node]) < k:\n                continue\n            \n            # Calculate the sum of the star graph centered at the current node\n            star_sum = vals[node]\n            if node in graph:\n                for neighbor in graph[node]:\n                    star_sum += vals[neighbor]\n            \n            # Add the sum to the list of sums\n            sums.append(star_sum)\n        \n        # Return the maximum sum\n        return max(sums)\n```", "extracted_code": "\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        # Create a dictionary to store the neighbors of each node\n        graph = {}\n        for edge in edges:\n            node1, node2 = edge\n            if node1 not in graph:\n                graph[node1] = []\n            if node2 not in graph:\n                graph[node2] = []\n            graph[node1].append(node2)\n            graph[node2].append(node1)\n        \n        # Create a list to store the sums of each star graph\n        sums = []\n        \n        # Iterate through each node\n        for node in range(len(vals)):\n            # If the node has less than k neighbors, skip it\n            if node in graph and len(graph[node]) < k:\n                continue\n            \n            # Calculate the sum of the star graph centered at the current node\n            star_sum = vals[node]\n            if node in graph:\n                for neighbor in graph[node]:\n                    star_sum += vals[neighbor]\n            \n            # Add the sum to the list of sums\n            sums.append(star_sum)\n        \n        # Return the maximum sum\n        return max(sums)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2493", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        # Create an adjacency list to represent the graph\n        graph = [[] for _ in range(n+1)]\n        for edge in edges:\n            u, v = edge\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Initialize the group index for each node\n        group = [0] * (n+1)\n        # Perform a depth-first search to group the nodes\n        def dfs(node, group_idx):\n            group[node] = group_idx\n            for neighbor in graph[node]:\n                if group[neighbor] == group_idx:\n                    return False\n                if group[neighbor] == 0 and not dfs(neighbor, group_idx+1):\n                    return False\n            return True\n        \n        # Group the nodes\n        for i in range(1, n+1):\n            if group[i] == 0 and not dfs(i, 1):\n                return -1\n        \n        # Return the maximum number of groups\n        return max(group)\n```", "extracted_code": "\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        # Create an adjacency list to represent the graph\n        graph = [[] for _ in range(n+1)]\n        for edge in edges:\n            u, v = edge\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Initialize the group index for each node\n        group = [0] * (n+1)\n        # Perform a depth-first search to group the nodes\n        def dfs(node, group_idx):\n            group[node] = group_idx\n            for neighbor in graph[node]:\n                if group[neighbor] == group_idx:\n                    return False\n                if group[neighbor] == 0 and not dfs(neighbor, group_idx+1):\n                    return False\n            return True\n        \n        # Group the nodes\n        for i in range(1, n+1):\n            if group[i] == 0 and not dfs(i, 1):\n                return -1\n        \n        # Return the maximum number of groups\n        return max(group)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2488", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        left = 0\n        right = 0\n        while right < n:\n            if nums[right] <= k:\n                count += right - left + 1\n            else:\n                left = right + 1\n            right += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        left = 0\n        right = 0\n        while right < n:\n            if nums[right] <= k:\n                count += right - left + 1\n            else:\n                left = right + 1\n            right += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2487", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:  # If the head is None, return None\n            return None\n        \n        # Initialize a dummy node before the head\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # Initialize two pointers\n        prev = dummy\n        curr = head\n        \n        while curr:\n            # Check if there is a node with a strictly greater value\n            remove = False\n            temp = curr.next\n            while temp:\n                if temp.val > curr.val:\n                    remove = True\n                    break\n                temp = temp.next\n            \n            # If there is a node with a strictly greater value, remove the current node\n            if remove:\n                prev.next = curr.next\n            else:\n                prev = curr\n            \n            curr = curr.next\n        \n        return dummy.next\n```", "extracted_code": "\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:  # If the head is None, return None\n            return None\n        \n        # Initialize a dummy node before the head\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # Initialize two pointers\n        prev = dummy\n        curr = head\n        \n        while curr:\n            # Check if there is a node with a strictly greater value\n            remove = False\n            temp = curr.next\n            while temp:\n                if temp.val > curr.val:\n                    remove = True\n                    break\n                temp = temp.next\n            \n            # If there is a node with a strictly greater value, remove the current node\n            if remove:\n                prev.next = curr.next\n            else:\n                prev = curr\n            \n            curr = curr.next\n        \n        return dummy.next\n", "difficulty": 2.0}
{"task_id": "LeetCode/2484", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        n = len(s)\n        mod = 10 ** 9 + 7\n\n        # Initialize a 2D dp table to store the counts of palindromic subsequences\n        dp = [[0] * n for _ in range(n)]\n\n        # Fill the main diagonal with 1 as single characters are palindromic\n        for i in range(n):\n            dp[i][i] = 1\n        \n        # Iterate over the string in reverse order\n        for i in range(n - 1, -1, -1):\n            # Iterate over the string from i+1 to n\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    # If the characters at positions i and j are the same, there are three cases:\n                    # 1. They can be used as the outer characters of a palindromic subsequence, so we add 2 to the count\n                    # 2. They can be used as the inner characters of a palindromic subsequence, so we add the count of the subsequence without these characters\n                    # 3. They can be excluded from the subsequence, so we subtract the count of the subsequence without these characters\n                    dp[i][j] = (2 + dp[i + 1][j - 1]) % mod\n                else:\n                    # If the characters at positions i and j are different, the count is the sum of the counts of the subsequences without these characters\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % mod\n        \n        # Return the count of palindromic subsequences of length 5\n        return dp[0][n - 1]\n```", "extracted_code": "\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        n = len(s)\n        mod = 10 ** 9 + 7\n\n        # Initialize a 2D dp table to store the counts of palindromic subsequences\n        dp = [[0] * n for _ in range(n)]\n\n        # Fill the main diagonal with 1 as single characters are palindromic\n        for i in range(n):\n            dp[i][i] = 1\n        \n        # Iterate over the string in reverse order\n        for i in range(n - 1, -1, -1):\n            # Iterate over the string from i+1 to n\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    # If the characters at positions i and j are the same, there are three cases:\n                    # 1. They can be used as the outer characters of a palindromic subsequence, so we add 2 to the count\n                    # 2. They can be used as the inner characters of a palindromic subsequence, so we add the count of the subsequence without these characters\n                    # 3. They can be excluded from the subsequence, so we subtract the count of the subsequence without these characters\n                    dp[i][j] = (2 + dp[i + 1][j - 1]) % mod\n                else:\n                    # If the characters at positions i and j are different, the count is the sum of the counts of the subsequences without these characters\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % mod\n        \n        # Return the count of palindromic subsequences of length 5\n        return dp[0][n - 1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2483", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        left_penalty = [0] * (n + 1)\n        right_penalty = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            left_penalty[i] = left_penalty[i-1] + (customers[i-1] == 'N')\n        \n        for i in range(n-1, -1, -1):\n            right_penalty[i] = right_penalty[i+1] + (customers[i] == 'Y')\n        \n        min_penalty = float('inf')\n        best_time = 0\n        \n        for i in range(n+1):\n            penalty = left_penalty[i] + right_penalty[i]\n            if penalty < min_penalty:\n                min_penalty = penalty\n                best_time = i\n        \n        return best_time\n```", "extracted_code": "\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        left_penalty = [0] * (n + 1)\n        right_penalty = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            left_penalty[i] = left_penalty[i-1] + (customers[i-1] == 'N')\n        \n        for i in range(n-1, -1, -1):\n            right_penalty[i] = right_penalty[i+1] + (customers[i] == 'Y')\n        \n        min_penalty = float('inf')\n        best_time = 0\n        \n        for i in range(n+1):\n            penalty = left_penalty[i] + right_penalty[i]\n            if penalty < min_penalty:\n                min_penalty = penalty\n                best_time = i\n        \n        return best_time\n", "difficulty": 2.0}
{"task_id": "LeetCode/2482", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow = [0] * m\n        onesCol = [0] * n\n        zerosRow = [0] * m\n        zerosCol = [0] * n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    onesRow[i] += 1\n                    onesCol[j] += 1\n                else:\n                    zerosRow[i] += 1\n                    zerosCol[j] += 1\n        diff = [[onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j] for j in range(n)] for i in range(m)]\n        return diff\n```", "extracted_code": "\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow = [0] * m\n        onesCol = [0] * n\n        zerosRow = [0] * m\n        zerosCol = [0] * n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    onesRow[i] += 1\n                    onesCol[j] += 1\n                else:\n                    zerosRow[i] += 1\n                    zerosCol[j] += 1\n        diff = [[onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j] for j in range(n)] for i in range(m)]\n        return diff\n", "difficulty": 2.0}
{"task_id": "LeetCode/2481", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n <= 0:\n            return 0\n        return n - 1\n```", "extracted_code": "\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n <= 0:\n            return 0\n        return n - 1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2478", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        # Create a list to store the count of beautiful partitions for each number\n        beautiful_partitions = [0] * 10\n        \n        # Iterate through the string\n        for i in range(len(s)):\n            # Calculate the prefix sum for each digit\n            prefix_sum = [0] * 10\n            for j in range(i, len(s)):\n                digit = int(s[j])\n                prefix_sum[digit] += 1\n                \n                # Check if the substring length is at least minLength\n                if j - i + 1 >= minLength:\n                    # Check if the first digit is prime and the last digit is non-prime\n                    if (digit in [2, 3, 5, 7]) and (prefix_sum[4] + prefix_sum[6] + prefix_sum[8] + prefix_sum[9] == 0):\n                        # Increment the count of beautiful partitions for the first digit\n                        beautiful_partitions[digit] += 1\n        \n        # Initialize the result\n        result = 0\n        \n        # Calculate the total count of beautiful partitions\n        for i in range(10):\n            # Check if the count of beautiful partitions for the first digit is at least k\n            if beautiful_partitions[i] >= k:\n                # Calculate the number of ways to choose k beautiful partitions from the count of beautiful partitions for the first digit\n                num_ways = self.calculateCombination(beautiful_partitions[i], k)\n                # Add the number of ways to the result\n                result += num_ways\n        \n        # Return the result modulo 10^9 + 7\n        return result % (10**9 + 7)\n    \n    def calculateCombination(self, n: int, k: int) -> int:\n        # Initialize the result\n        result = 1\n        \n        # Calculate the value of n! / (k! * (n-k)!)\n        for i in range(k):\n            result *= (n - i)\n            result //= (i + 1)\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        # Create a list to store the count of beautiful partitions for each number\n        beautiful_partitions = [0] * 10\n        \n        # Iterate through the string\n        for i in range(len(s)):\n            # Calculate the prefix sum for each digit\n            prefix_sum = [0] * 10\n            for j in range(i, len(s)):\n                digit = int(s[j])\n                prefix_sum[digit] += 1\n                \n                # Check if the substring length is at least minLength\n                if j - i + 1 >= minLength:\n                    # Check if the first digit is prime and the last digit is non-prime\n                    if (digit in [2, 3, 5, 7]) and (prefix_sum[4] + prefix_sum[6] + prefix_sum[8] + prefix_sum[9] == 0):\n                        # Increment the count of beautiful partitions for the first digit\n                        beautiful_partitions[digit] += 1\n        \n        # Initialize the result\n        result = 0\n        \n        # Calculate the total count of beautiful partitions\n        for i in range(10):\n            # Check if the count of beautiful partitions for the first digit is at least k\n            if beautiful_partitions[i] >= k:\n                # Calculate the number of ways to choose k beautiful partitions from the count of beautiful partitions for the first digit\n                num_ways = self.calculateCombination(beautiful_partitions[i], k)\n                # Add the number of ways to the result\n                result += num_ways\n        \n        # Return the result modulo 10^9 + 7\n        return result % (10**9 + 7)\n    \n    def calculateCombination(self, n: int, k: int) -> int:\n        # Initialize the result\n        result = 1\n        \n        # Calculate the value of n! / (k! * (n-k)!)\n        for i in range(k):\n            result *= (n - i)\n            result //= (i + 1)\n        \n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2476", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def find_closest(node, target):\n            closest = None\n            while node:\n                if node.val == target:\n                    return node.val\n                elif node.val < target:\n                    if not closest or target - node.val < target - closest:\n                        closest = node.val\n                    node = node.right\n                else:\n                    if not closest or node.val - target < closest - target:\n                        closest = node.val\n                    node = node.left\n            return closest\n        \n        def find_smallest_greater(node, target):\n            smallest = float('inf')\n            while node:\n                if node.val == target:\n                    return node.val\n                elif node.val < target:\n                    node = node.right\n                else:\n                    if node.val < smallest:\n                        smallest = node.val\n                    node = node.left\n            return smallest if smallest != float('inf') else -1\n        \n        def find_largest_smaller(node, target):\n            largest = -1\n            while node:\n                if node.val == target:\n                    return node.val\n                elif node.val < target:\n                    if node.val > largest:\n                        largest = node.val\n                    node = node.right\n                else:\n                    node = node.left\n            return largest\n        \n        def find_closest_nodes(node, queries):\n            res = []\n            for q in queries:\n                min_val = find_largest_smaller(node, q)\n                max_val = find_smallest_greater(node, q)\n                res.append([min_val, max_val])\n            return res\n        \n        return find_closest_nodes(root, queries)\n```", "extracted_code": "\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def find_closest(node, target):\n            closest = None\n            while node:\n                if node.val == target:\n                    return node.val\n                elif node.val < target:\n                    if not closest or target - node.val < target - closest:\n                        closest = node.val\n                    node = node.right\n                else:\n                    if not closest or node.val - target < closest - target:\n                        closest = node.val\n                    node = node.left\n            return closest\n        \n        def find_smallest_greater(node, target):\n            smallest = float('inf')\n            while node:\n                if node.val == target:\n                    return node.val\n                elif node.val < target:\n                    node = node.right\n                else:\n                    if node.val < smallest:\n                        smallest = node.val\n                    node = node.left\n            return smallest if smallest != float('inf') else -1\n        \n        def find_largest_smaller(node, target):\n            largest = -1\n            while node:\n                if node.val == target:\n                    return node.val\n                elif node.val < target:\n                    if node.val > largest:\n                        largest = node.val\n                    node = node.right\n                else:\n                    node = node.left\n            return largest\n        \n        def find_closest_nodes(node, queries):\n            res = []\n            for q in queries:\n                min_val = find_largest_smaller(node, q)\n                max_val = find_smallest_greater(node, q)\n                res.append([min_val, max_val])\n            return res\n        \n        return find_closest_nodes(root, queries)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2472", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i+k, len(s)+1):\n                substring = s[i:j]\n                if substring == substring[::-1] and len(substring) >= k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i+k, len(s)+1):\n                substring = s[i:j]\n                if substring == substring[::-1] and len(substring) >= k:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2471", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        levels = []  # List to store the nodes at each level\n        self.traverse(root, 0, levels)  # Perform a depth-first traversal to populate the levels list\n        operations = 0  # Variable to store the minimum number of operations\n        for level in levels:\n            if not self.is_sorted(level):  # If the level is not already sorted in increasing order\n                operations += 1  # Increment the number of operations\n        return operations\n    \n    def traverse(self, node: Optional[TreeNode], level: int, levels: List[List[int]]) -> None:\n        if node is None:\n            return\n        if level >= len(levels):\n            levels.append([])  # Append a new empty list for the current level\n        levels[level].append(node.val)  # Add the node's value to the current level\n        self.traverse(node.left, level + 1, levels)  # Recursively traverse the left subtree\n        self.traverse(node.right, level + 1, levels)  # Recursively traverse the right subtree\n    \n    def is_sorted(self, arr: List[int]) -> bool:\n        for i in range(1, len(arr)):\n            if arr[i] <= arr[i-1]:  # If any element is less than or equal to the previous element\n                return False  # The list is not sorted in increasing order\n        return True  # The list is sorted in increasing order\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        levels = []  # List to store the nodes at each level\n        self.traverse(root, 0, levels)  # Perform a depth-first traversal to populate the levels list\n        operations = 0  # Variable to store the minimum number of operations\n        for level in levels:\n            if not self.is_sorted(level):  # If the level is not already sorted in increasing order\n                operations += 1  # Increment the number of operations\n        return operations\n    \n    def traverse(self, node: Optional[TreeNode], level: int, levels: List[List[int]]) -> None:\n        if node is None:\n            return\n        if level >= len(levels):\n            levels.append([])  # Append a new empty list for the current level\n        levels[level].append(node.val)  # Add the node's value to the current level\n        self.traverse(node.left, level + 1, levels)  # Recursively traverse the left subtree\n        self.traverse(node.right, level + 1, levels)  # Recursively traverse the right subtree\n    \n    def is_sorted(self, arr: List[int]) -> bool:\n        for i in range(1, len(arr)):\n            if arr[i] <= arr[i-1]:  # If any element is less than or equal to the previous element\n                return False  # The list is not sorted in increasing order\n        return True  # The list is sorted in increasing order\n", "difficulty": 2.0}
{"task_id": "LeetCode/2470", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        \n        def lcm(a, b):\n            return (a * b) // gcd(a, b)\n        \n        count = 0\n        lcm_val = 1\n        left = 0\n        \n        for right in range(len(nums)):\n            lcm_val = lcm(lcm_val, nums[right])\n            \n            while lcm_val > k:\n                lcm_val = lcm_val // nums[left]\n                left += 1\n                \n            if lcm_val == k:\n                count += right - left + 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        \n        def lcm(a, b):\n            return (a * b) // gcd(a, b)\n        \n        count = 0\n        lcm_val = 1\n        left = 0\n        \n        for right in range(len(nums)):\n            lcm_val = lcm(lcm_val, nums[right])\n            \n            while lcm_val > k:\n                lcm_val = lcm_val // nums[left]\n                left += 1\n                \n            if lcm_val == k:\n                count += right - left + 1\n        \n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2468", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        parts = []\n        remaining = len(message)\n        i = 0\n        while remaining > 0:\n            suffix = \"<{}/{}>\".format(i+1, (remaining-1)//limit + 1)\n            if remaining <= limit:\n                parts.append(message[i:] + suffix)\n                remaining = 0\n            else:\n                parts.append(message[i:i+limit] + suffix)\n                i += limit\n                remaining -= limit\n        return parts\n```", "extracted_code": "\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        parts = []\n        remaining = len(message)\n        i = 0\n        while remaining > 0:\n            suffix = \"<{}/{}>\".format(i+1, (remaining-1)//limit + 1)\n            if remaining <= limit:\n                parts.append(message[i:] + suffix)\n                remaining = 0\n            else:\n                parts.append(message[i:i+limit] + suffix)\n                i += limit\n                remaining -= limit\n        return parts\n", "difficulty": 3.0}
{"task_id": "LeetCode/2466", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        dp = [[[0] * (one+1) for _ in range(zero+1)] for _ in range(high+1)]\n        \n        for i in range(low, high+1):\n            dp[i][0][0] = 1\n        \n        for i in range(low, high+1):\n            for j in range(zero+1):\n                for k in range(one+1):\n                    if i > low:\n                        dp[i][j][k] += dp[i-1][j][k]\n                    if j > 0:\n                        dp[i][j][k] += dp[i][j-1][k] if k == one else 0\n                    if k > 0:\n                        dp[i][j][k] += dp[i][j][k-1] if j == zero else 0\n                    dp[i][j][k] %= (10**9 + 7)\n        \n        return dp[high][zero][one]\n```", "extracted_code": "\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        dp = [[[0] * (one+1) for _ in range(zero+1)] for _ in range(high+1)]\n        \n        for i in range(low, high+1):\n            dp[i][0][0] = 1\n        \n        for i in range(low, high+1):\n            for j in range(zero+1):\n                for k in range(one+1):\n                    if i > low:\n                        dp[i][j][k] += dp[i-1][j][k]\n                    if j > 0:\n                        dp[i][j][k] += dp[i][j-1][k] if k == one else 0\n                    if k > 0:\n                        dp[i][j][k] += dp[i][j][k-1] if j == zero else 0\n                    dp[i][j][k] %= (10**9 + 7)\n        \n        return dp[high][zero][one]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2463", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort()\n        n = len(robot)\n        m = len(factory)\n        dist = [0] * n\n        for i in range(n):\n            dist[i] = abs(robot[i] - factory[0][0])\n        for j in range(1, m):\n            prev_dist = dist.copy()\n            for i in range(n):\n                dist[i] = min(dist[i], prev_dist[i] + abs(robot[i] - factory[j][0]))\n        return min(dist)\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort()\n        n = len(robot)\n        m = len(factory)\n        dist = [0] * n\n        for i in range(n):\n            dist[i] = abs(robot[i] - factory[0][0])\n        for j in range(1, m):\n            prev_dist = dist.copy()\n            for i in range(n):\n                dist[i] = min(dist[i], prev_dist[i] + abs(robot[i] - factory[j][0]))\n        return min(dist)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2462", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        workers = len(costs)\n        costs_with_indices = [(costs[i], i) for i in range(workers)]\n        costs_with_indices.sort()\n        min_cost = float('inf')\n        total_cost = 0\n        for i in range(k):\n            if i < candidates or k - i <= workers - candidates:\n                total_cost += costs_with_indices[i][0]\n                min_cost = min(min_cost, costs_with_indices[i][1])\n            else:\n                total_cost += costs_with_indices[workers - k + i][0]\n                min_cost = min(min_cost, costs_with_indices[workers - k + i][1])\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        workers = len(costs)\n        costs_with_indices = [(costs[i], i) for i in range(workers)]\n        costs_with_indices.sort()\n        min_cost = float('inf')\n        total_cost = 0\n        for i in range(k):\n            if i < candidates or k - i <= workers - candidates:\n                total_cost += costs_with_indices[i][0]\n                min_cost = min(min_cost, costs_with_indices[i][1])\n            else:\n                total_cost += costs_with_indices[workers - k + i][0]\n                min_cost = min(min_cost, costs_with_indices[workers - k + i][1])\n        return total_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2461", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        # Initialize a set to keep track of distinct elements\n        distinct_set = set()\n        # Initialize a variable to keep track of the maximum subarray sum\n        max_sum = 0\n        # Initialize two pointers, start and end\n        start, end = 0, 0\n        \n        # Iterate through the array using the end pointer\n        while end < len(nums):\n            # Add the current element to the distinct set\n            distinct_set.add(nums[end])\n            \n            # If the size of the distinct set is less than k\n            if len(distinct_set) < k:\n                # Move the end pointer forward\n                end += 1\n            # If the size of the distinct set is equal to k\n            elif len(distinct_set) == k:\n                # Update the maximum subarray sum if necessary\n                max_sum = max(max_sum, sum(distinct_set))\n                # Remove the element at the start pointer from the distinct set\n                distinct_set.remove(nums[start])\n                # Move the start pointer forward\n                start += 1\n            # If the size of the distinct set is greater than k\n            else:\n                # Remove the element at the start pointer from the distinct set\n                distinct_set.remove(nums[start])\n                # Move the start pointer forward\n                start += 1\n        \n        # Return the maximum subarray sum\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        # Initialize a set to keep track of distinct elements\n        distinct_set = set()\n        # Initialize a variable to keep track of the maximum subarray sum\n        max_sum = 0\n        # Initialize two pointers, start and end\n        start, end = 0, 0\n        \n        # Iterate through the array using the end pointer\n        while end < len(nums):\n            # Add the current element to the distinct set\n            distinct_set.add(nums[end])\n            \n            # If the size of the distinct set is less than k\n            if len(distinct_set) < k:\n                # Move the end pointer forward\n                end += 1\n            # If the size of the distinct set is equal to k\n            elif len(distinct_set) == k:\n                # Update the maximum subarray sum if necessary\n                max_sum = max(max_sum, sum(distinct_set))\n                # Remove the element at the start pointer from the distinct set\n                distinct_set.remove(nums[start])\n                # Move the start pointer forward\n                start += 1\n            # If the size of the distinct set is greater than k\n            else:\n                # Remove the element at the start pointer from the distinct set\n                distinct_set.remove(nums[start])\n                # Move the start pointer forward\n                start += 1\n        \n        # Return the maximum subarray sum\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2458", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        # Calculate the initial height of the tree\n        initial_height = self.calculate_height(root)\n        \n        # Store the heights after each query\n        heights = [initial_height]\n        \n        # Remove the subtrees and calculate the heights\n        for query in queries:\n            self.remove_subtree(root, query)\n            height = self.calculate_height(root)\n            heights.append(height)\n        \n        return heights\n    \n    def calculate_height(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return 1 + max(self.calculate_height(root.left), self.calculate_height(root.right))\n    \n    def remove_subtree(self, root: Optional[TreeNode], target: int) -> None:\n        if root is None:\n            return\n        \n        if root.left and root.left.val == target:\n            root.left = None\n            return\n        \n        if root.right and root.right.val == target:\n            root.right = None\n            return\n        \n        self.remove_subtree(root.left, target)\n        self.remove_subtree(root.right, target)\n```\n", "extracted_code": "\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        # Calculate the initial height of the tree\n        initial_height = self.calculate_height(root)\n        \n        # Store the heights after each query\n        heights = [initial_height]\n        \n        # Remove the subtrees and calculate the heights\n        for query in queries:\n            self.remove_subtree(root, query)\n            height = self.calculate_height(root)\n            heights.append(height)\n        \n        return heights\n    \n    def calculate_height(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return 1 + max(self.calculate_height(root.left), self.calculate_height(root.right))\n    \n    def remove_subtree(self, root: Optional[TreeNode], target: int) -> None:\n        if root is None:\n            return\n        \n        if root.left and root.left.val == target:\n            root.left = None\n            return\n        \n        if root.right and root.right.val == target:\n            root.right = None\n            return\n        \n        self.remove_subtree(root.left, target)\n        self.remove_subtree(root.right, target)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2457", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        if sum(int(digit) for digit in str(n)) <= target:\n            return 0\n        digits = [int(digit) for digit in str(n)]\n        digits.reverse()\n        carry = 0\n        for i in range(len(digits)):\n            if digits[i] + carry <= target:\n                return carry * 10**(i-1)\n            carry = (digits[i] + carry) // 10\n        return carry * 10**len(digits)\n```", "extracted_code": "\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        if sum(int(digit) for digit in str(n)) <= target:\n            return 0\n        digits = [int(digit) for digit in str(n)]\n        digits.reverse()\n        carry = 0\n        for i in range(len(digits)):\n            if digits[i] + carry <= target:\n                return carry * 10**(i-1)\n            carry = (digits[i] + carry) // 10\n        return carry * 10**len(digits)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2455", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if len(even_divisible_by_3) == 0:\n            return 0\n        else:\n            return sum(even_divisible_by_3) // len(even_divisible_by_3)\n```", "extracted_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if len(even_divisible_by_3) == 0:\n            return 0\n        else:\n            return sum(even_divisible_by_3) // len(even_divisible_by_3)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2454", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        stack = []\n        res = [-1] * n\n        \n        for i in range(n-1, -1, -1):\n            while stack and nums[i] > stack[-1]:\n                res[stack.pop()] = nums[i]\n            \n            if stack:\n                res[i] = stack[-1]\n                \n            stack.append(i)\n        \n        return res\n```", "extracted_code": "\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        stack = []\n        res = [-1] * n\n        \n        for i in range(n-1, -1, -1):\n            while stack and nums[i] > stack[-1]:\n                res[stack.pop()] = nums[i]\n            \n            if stack:\n                res[i] = stack[-1]\n                \n            stack.append(i)\n        \n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2449", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n        \n        for num in target:\n            if num not in count or count[num] == 0:\n                return -1\n            count[num] -= 1\n        \n        operations = 0\n        for num in count:\n            if count[num] > 0:\n                operations += count[num]\n        \n        return operations\n```", "extracted_code": "\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n        \n        for num in target:\n            if num not in count or count[num] == 0:\n                return -1\n            count[num] -= 1\n        \n        operations = 0\n        for num in count:\n            if count[num] > 0:\n                operations += count[num]\n        \n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2448", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        total_cost = 0\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1]:\n                total_cost += min(cost[i], cost[i-1])\n            elif nums[i] < nums[i-1]:\n                j = i\n                max_cost = -1\n                while j < n and nums[j] < nums[j-1]:\n                    total_cost += cost[j-1]\n                    max_cost = max(max_cost, cost[j-1])\n                    j += 1\n                total_cost -= max_cost\n                \n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        total_cost = 0\n        \n        for i in range(1, n):\n            if nums[i] == nums[i-1]:\n                total_cost += min(cost[i], cost[i-1])\n            elif nums[i] < nums[i-1]:\n                j = i\n                max_cost = -1\n                while j < n and nums[j] < nums[j-1]:\n                    total_cost += cost[j-1]\n                    max_cost = max(max_cost, cost[j-1])\n                    j += 1\n                total_cost -= max_cost\n                \n        return total_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2444", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        count = 0\n        left = 0\n        right = 0\n        \n        for i in range(n):\n            if nums[i] >= minK and nums[i] <= maxK:\n                right = i + 1\n            elif nums[i] < minK:\n                count += right - left\n            elif nums[i] > maxK:\n                left = i + 1\n                right = i + 1\n            prefix[i + 1] = prefix[i] + (right - left)\n        \n        return prefix[n]\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        count = 0\n        left = 0\n        right = 0\n        \n        for i in range(n):\n            if nums[i] >= minK and nums[i] <= maxK:\n                right = i + 1\n            elif nums[i] < minK:\n                count += right - left\n            elif nums[i] > maxK:\n                left = i + 1\n                right = i + 1\n            prefix[i + 1] = prefix[i] + (right - left)\n        \n        return prefix[n]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2443", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        return str(num + int(str(num)[::-1])) == str(num + int(str(num)[::-1]))[::-1]\n```", "extracted_code": "\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        return str(num + int(str(num)[::-1])) == str(num + int(str(num)[::-1]))[::-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2442", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        distinct_integers = set(nums)\n        for num in nums:\n            distinct_integers.add(int(str(num)[::-1]))\n        return len(distinct_integers)\n```", "extracted_code": "\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        distinct_integers = set(nums)\n        for num in nums:\n            distinct_integers.add(int(str(num)[::-1]))\n        return len(distinct_integers)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2440", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent):\n            total = nums[node]\n            for nei in graph[node]:\n                if nei == parent:\n                    continue\n                child_total = dfs(nei, node)\n                if child_total == target:\n                    nonlocal ans\n                    ans += 1\n                total += child_total\n            return total\n        \n        n = len(nums)\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        total_sum = sum(nums)\n        if total_sum % n != 0:\n            return 0\n        \n        target = total_sum // n\n        ans = 0\n        dfs(0, -1)\n        return ans\n```", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent):\n            total = nums[node]\n            for nei in graph[node]:\n                if nei == parent:\n                    continue\n                child_total = dfs(nei, node)\n                if child_total == target:\n                    nonlocal ans\n                    ans += 1\n                total += child_total\n            return total\n        \n        n = len(nums)\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        total_sum = sum(nums)\n        if total_sum % n != 0:\n            return 0\n        \n        target = total_sum // n\n        ans = 0\n        dfs(0, -1)\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2438", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 1000000007\n        powers = []\n        power = 1\n        while power <= n:\n            powers.append(power)\n            power *= 2\n        \n        answers = []\n        for query in queries:\n            left = query[0]\n            right = query[1]\n            product = 1\n            for i in range(left, right + 1):\n                product = (product * powers[i]) % MOD\n            answers.append(product)\n        \n        return answers\n```", "extracted_code": "\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 1000000007\n        powers = []\n        power = 1\n        while power <= n:\n            powers.append(power)\n            power *= 2\n        \n        answers = []\n        for query in queries:\n            left = query[0]\n            right = query[1]\n            product = 1\n            for i in range(left, right + 1):\n                product = (product * powers[i]) % MOD\n            answers.append(product)\n        \n        return answers\n", "difficulty": 2.0}
{"task_id": "LeetCode/2435", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] % k == 0:\n                    count += 1\n\n        return count % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] % k == 0:\n                    count += 1\n\n        return count % (10**9 + 7)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2434", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = \"\"\n        while s or t:\n            if not t or (s and s[0] <= t[-1]):\n                t += s[0]\n                s = s[1:]\n            else:\n                t = t[:-1]\n        return t\n```", "extracted_code": "\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = \"\"\n        while s or t:\n            if not t or (s and s[0] <= t[-1]):\n                t += s[0]\n                s = s[1:]\n            else:\n                t = t[:-1]\n        return t\n", "difficulty": 2.0}
{"task_id": "LeetCode/2432", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        time_worked = [0] * n\n        for i in range(1, len(logs)):\n            id_i, leaveTime_i = logs[i]\n            id_i_minus_1, leaveTime_i_minus_1 = logs[i-1]\n            time_worked[id_i] += leaveTime_i - leaveTime_i_minus_1\n        \n        max_time = max(time_worked)\n        return time_worked.index(max_time)\n```", "extracted_code": "\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        time_worked = [0] * n\n        for i in range(1, len(logs)):\n            id_i, leaveTime_i = logs[i]\n            id_i_minus_1, leaveTime_i_minus_1 = logs[i-1]\n            time_worked[id_i] += leaveTime_i - leaveTime_i_minus_1\n        \n        max_time = max(time_worked)\n        return time_worked.index(max_time)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2430", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        for i in range(1, n//2 + 1):\n            if s[:i] == s[i:2*i]:\n                return 2\n        return 1\n```", "extracted_code": "\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        for i in range(1, n//2 + 1):\n            if s[:i] == s[i:2*i]:\n                return 2\n        return 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2429", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        # Count the number of set bits in num2\n        num2_set_bits = bin(num2).count('1')\n        \n        # Check all numbers with same number of set bits as num2\n        # and find the one with minimal XOR value\n        min_xor = float('inf')\n        min_xor_num = 0\n        for i in range(1, num1+1):\n            if bin(i).count('1') == num2_set_bits:\n                xor_val = i ^ num1\n                if xor_val < min_xor:\n                    min_xor = xor_val\n                    min_xor_num = i\n        \n        return min_xor_num\n```", "extracted_code": "\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        # Count the number of set bits in num2\n        num2_set_bits = bin(num2).count('1')\n        \n        # Check all numbers with same number of set bits as num2\n        # and find the one with minimal XOR value\n        min_xor = float('inf')\n        min_xor_num = 0\n        for i in range(1, num1+1):\n            if bin(i).count('1') == num2_set_bits:\n                xor_val = i ^ num1\n                if xor_val < min_xor:\n                    min_xor = xor_val\n                    min_xor_num = i\n        \n        return min_xor_num\n", "difficulty": 2.0}
{"task_id": "LeetCode/2427", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        # Find the smaller number between a and b\n        n = min(a, b)\n        \n        # Initialize a count variable to keep track of common factors\n        count = 0\n        \n        # Iterate from 1 to n\n        for i in range(1, n+1):\n            # Check if i is a factor of both a and b\n            if a % i == 0 and b % i == 0:\n                # Increment the count if i is a common factor\n                count += 1\n        \n        # Return the count of common factors\n        return count\n```", "extracted_code": "\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        # Find the smaller number between a and b\n        n = min(a, b)\n        \n        # Initialize a count variable to keep track of common factors\n        count = 0\n        \n        # Iterate from 1 to n\n        for i in range(1, n+1):\n            # Check if i is a factor of both a and b\n            if a % i == 0 and b % i == 0:\n                # Increment the count if i is a common factor\n                count += 1\n        \n        # Return the count of common factors\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2426", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        n = len(nums1)\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        n = len(nums1)\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2425", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_sum = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_sum ^= num1 ^ num2\n        return xor_sum\n```", "extracted_code": "\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_sum = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_sum ^= num1 ^ num2\n        return xor_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2424", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "Here is the complete function definition for the given problem:\n\n```python\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.uploaded = [False] * (n+1)\n        self.longest_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded[video] = True\n        if video == self.longest_prefix + 1:\n            while self.longest_prefix < len(self.uploaded) - 1 and self.uploaded[self.longest_prefix + 1]:\n                self.longest_prefix += 1\n\n    def longest(self) -> int:\n        return self.longest_prefix\n```\n\nNote: The implementation uses an array `uploaded` to keep track of the videos that have been uploaded. The `longest_prefix` variable stores the length of the longest uploaded prefix. In the `upload` method, when a video is uploaded, it is marked as uploaded in the `uploaded` array. If the uploaded video is the next video in the sequence (i.e., `video == self.longest_prefix + 1`), the `longest_prefix` is incremented until the next video in the sequence is not uploaded. Finally, the `longest` method returns the length of the longest uploaded prefix.", "extracted_code": "\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.uploaded = [False] * (n+1)\n        self.longest_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded[video] = True\n        if video == self.longest_prefix + 1:\n            while self.longest_prefix < len(self.uploaded) - 1 and self.uploaded[self.longest_prefix + 1]:\n                self.longest_prefix += 1\n\n    def longest(self) -> int:\n        return self.longest_prefix\n", "difficulty": 2.0}
{"task_id": "LeetCode/2421", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent, max_val):\n            count = 0\n            if vals[node] == max_val:\n                count += 1\n            for nei in graph[node]:\n                if nei != parent:\n                    count += dfs(nei, node, max(max_val, vals[node]))\n            return count\n        \n        n = len(vals)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        return dfs(0, -1, vals[0])\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent, max_val):\n            count = 0\n            if vals[node] == max_val:\n                count += 1\n            for nei in graph[node]:\n                if nei != parent:\n                    count += dfs(nei, node, max(max_val, vals[node]))\n            return count\n        \n        n = len(vals)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        return dfs(0, -1, vals[0])\n", "difficulty": 3.0}
{"task_id": "LeetCode/2419", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            bitwise_and = nums[i]\n            for j in range(i, n):\n                bitwise_and &= nums[j]\n                if bitwise_and == 0:\n                    break\n                ans = max(ans, j - i + 1)\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            bitwise_and = nums[i]\n            for j in range(i, n):\n                bitwise_and &= nums[j]\n                if bitwise_and == 0:\n                    break\n                ans = max(ans, j - i + 1)\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2416", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        prefix_scores = []\n        for word in words:\n            score = 0\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                score += words.count(prefix)\n            prefix_scores.append(score)\n        return prefix_scores\n```", "extracted_code": "\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        prefix_scores = []\n        for word in words:\n            score = 0\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                score += words.count(prefix)\n            prefix_scores.append(score)\n        return prefix_scores\n", "difficulty": 3.0}
{"task_id": "LeetCode/2415", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def reverseLevel(node, level):\n            if not node:\n                return\n            \n            if level % 2 == 1:\n                node.vals.reverse()\n            \n            reverseLevel(node.left, level + 1)\n            reverseLevel(node.right, level + 1)\n        \n        reverseLevel(root, 1)\n        return root\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def reverseLevel(node, level):\n            if not node:\n                return\n            \n            if level % 2 == 1:\n                node.vals.reverse()\n            \n            reverseLevel(node.left, level + 1)\n            reverseLevel(node.right, level + 1)\n        \n        reverseLevel(root, 1)\n        return root\n", "difficulty": 2.0}
{"task_id": "LeetCode/2414", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        if not s:\n            return 0\n        \n        max_length = 1\n        current_length = 1\n        \n        for i in range(1, len(s)):\n            if ord(s[i]) - ord(s[i-1]) == 1:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 1\n        \n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        if not s:\n            return 0\n        \n        max_length = 1\n        current_length = 1\n        \n        for i in range(1, len(s)):\n            if ord(s[i]) - ord(s[i-1]) == 1:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 1\n        \n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2413", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return 2 * n\n```", "extracted_code": "\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return 2 * n\n", "difficulty": 1.0}
{"task_id": "LeetCode/2412", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        money = 0\n        for transaction in transactions:\n            money = max(money, transaction[0])\n        return money\n```", "extracted_code": "\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        money = 0\n        for transaction in transactions:\n            money = max(money, transaction[0])\n        return money\n", "difficulty": 3.0}
{"task_id": "LeetCode/2409", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        alice_arrival = int(arriveAlice[3:]) - 1\n        alice_departure = int(leaveAlice[3:]) - 1\n        bob_arrival = int(arriveBob[3:]) - 1\n        bob_departure = int(leaveBob[3:]) - 1\n        \n        alice_month = int(arriveAlice[:2]) - 1\n        bob_month = int(arriveBob[:2]) - 1\n        \n        days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        \n        alice_days = sum(days_per_month[alice_month:alice_month+1]) - alice_arrival\n        bob_days = bob_departure - sum(days_per_month[:bob_month])\n        \n        if alice_month < bob_month:\n            overlap_days = sum(days_per_month[alice_month:bob_month]) - alice_arrival - (bob_departure - sum(days_per_month[:bob_month]))\n        elif alice_month == bob_month:\n            overlap_days = abs(alice_arrival - bob_departure)\n        else:\n            overlap_days = sum(days_per_month[bob_month:alice_month]) - bob_arrival - (alice_days - sum(days_per_month[:alice_month]))\n        \n        return max(overlap_days, 0)\n```", "extracted_code": "\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        alice_arrival = int(arriveAlice[3:]) - 1\n        alice_departure = int(leaveAlice[3:]) - 1\n        bob_arrival = int(arriveBob[3:]) - 1\n        bob_departure = int(leaveBob[3:]) - 1\n        \n        alice_month = int(arriveAlice[:2]) - 1\n        bob_month = int(arriveBob[:2]) - 1\n        \n        days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        \n        alice_days = sum(days_per_month[alice_month:alice_month+1]) - alice_arrival\n        bob_days = bob_departure - sum(days_per_month[:bob_month])\n        \n        if alice_month < bob_month:\n            overlap_days = sum(days_per_month[alice_month:bob_month]) - alice_arrival - (bob_departure - sum(days_per_month[:bob_month]))\n        elif alice_month == bob_month:\n            overlap_days = abs(alice_arrival - bob_departure)\n        else:\n            overlap_days = sum(days_per_month[bob_month:alice_month]) - bob_arrival - (alice_days - sum(days_per_month[:alice_month]))\n        \n        return max(overlap_days, 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2407", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [1] * n\n        longest = 1\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j] and nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            longest = max(longest, dp[i])\n        \n        return longest\n```", "extracted_code": "\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [1] * n\n        longest = 1\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j] and nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            longest = max(longest, dp[i])\n        \n        return longest\n", "difficulty": 3.0}
{"task_id": "LeetCode/2402", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        rooms = [0] * n\n        for start, end in meetings:\n            for i in range(n):\n                if rooms[i] <= start:\n                    rooms[i] = end\n                    break\n        return rooms.index(max(rooms))\n```", "extracted_code": "\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        rooms = [0] * n\n        for start, end in meetings:\n            for i in range(n):\n                if rooms[i] <= start:\n                    rooms[i] = end\n                    break\n        return rooms.index(max(rooms))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2401", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        # Create a helper function to check if a subarray is nice\n        def is_nice(subarray):\n            # Iterate through all pairs of elements in the subarray\n            for i in range(len(subarray)):\n                for j in range(i+1, len(subarray)):\n                    # If the bitwise AND of the pair is not 0, return False\n                    if subarray[i] & subarray[j] != 0:\n                        return False\n            # If all pairs satisfy the condition, return True\n            return True\n        \n        # Initialize the maximum length of nice subarray to 0\n        max_length = 0\n        \n        # Iterate through all possible subarrays\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                # Check if the subarray is nice\n                if is_nice(nums[i:j+1]):\n                    # Update the maximum length if necessary\n                    max_length = max(max_length, j-i+1)\n        \n        # Return the maximum length of nice subarray\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        # Create a helper function to check if a subarray is nice\n        def is_nice(subarray):\n            # Iterate through all pairs of elements in the subarray\n            for i in range(len(subarray)):\n                for j in range(i+1, len(subarray)):\n                    # If the bitwise AND of the pair is not 0, return False\n                    if subarray[i] & subarray[j] != 0:\n                        return False\n            # If all pairs satisfy the condition, return True\n            return True\n        \n        # Initialize the maximum length of nice subarray to 0\n        max_length = 0\n        \n        # Iterate through all possible subarrays\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                # Check if the subarray is nice\n                if is_nice(nums[i:j+1]):\n                    # Update the maximum length if necessary\n                    max_length = max(max_length, j-i+1)\n        \n        # Return the maximum length of nice subarray\n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2399", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        indices = [[] for _ in range(26)]\n        \n        for i, char in enumerate(s):\n            indices[ord(char) - ord('a')].append(i)\n        \n        for i, char in enumerate(s):\n            char_index = ord(char) - ord('a')\n            \n            if len(indices[char_index]) > 2:\n                return False\n            \n            if len(indices[char_index]) == 2:\n                if indices[char_index][1] - indices[char_index][0] != distance[char_index]:\n                    return False\n        \n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        indices = [[] for _ in range(26)]\n        \n        for i, char in enumerate(s):\n            indices[ord(char) - ord('a')].append(i)\n        \n        for i, char in enumerate(s):\n            char_index = ord(char) - ord('a')\n            \n            if len(indices[char_index]) > 2:\n                return False\n            \n            if len(indices[char_index]) == 2:\n                if indices[char_index][1] - indices[char_index][0] != distance[char_index]:\n                    return False\n        \n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2398", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        max_robots = 0\n        max_charge = max(chargeTimes)\n        total_cost = max_charge\n        \n        for i in range(n):\n            total_cost += runningCosts[i]\n            \n            if total_cost <= budget:\n                max_robots = i + 1\n            else:\n                break\n        \n        return max_robots\n```", "extracted_code": "\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        max_robots = 0\n        max_charge = max(chargeTimes)\n        total_cost = max_charge\n        \n        for i in range(n):\n            total_cost += runningCosts[i]\n            \n            if total_cost <= budget:\n                max_robots = i + 1\n            else:\n                break\n        \n        return max_robots\n", "difficulty": 3.0}
{"task_id": "LeetCode/2397", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        max_rows = 0\n        \n        def backtrack(col_idx, selected_cols):\n            nonlocal max_rows\n            if len(selected_cols) == numSelect:\n                rows_covered = 0\n                for row in range(m):\n                    for col in range(n):\n                        if matrix[row][col] == 1 and col not in selected_cols:\n                            break\n                    else:\n                        rows_covered += 1\n                max_rows = max(max_rows, rows_covered)\n                return\n            \n            if col_idx == n:\n                return\n            \n            backtrack(col_idx + 1, selected_cols)\n            backtrack(col_idx + 1, selected_cols + [col_idx])\n        \n        backtrack(0, [])\n        return max_rows\n```", "extracted_code": "\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        max_rows = 0\n        \n        def backtrack(col_idx, selected_cols):\n            nonlocal max_rows\n            if len(selected_cols) == numSelect:\n                rows_covered = 0\n                for row in range(m):\n                    for col in range(n):\n                        if matrix[row][col] == 1 and col not in selected_cols:\n                            break\n                    else:\n                        rows_covered += 1\n                max_rows = max(max_rows, rows_covered)\n                return\n            \n            if col_idx == n:\n                return\n            \n            backtrack(col_idx + 1, selected_cols)\n            backtrack(col_idx + 1, selected_cols + [col_idx])\n        \n        backtrack(0, [])\n        return max_rows\n", "difficulty": 2.0}
{"task_id": "LeetCode/2396", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        for base in range(2, n-1):\n            num_base = \"\"\n            num = n\n            while num > 0:\n                num_base += str(num % base)\n                num //= base\n            if not is_palindrome(num_base):\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        for base in range(2, n-1):\n            num_base = \"\"\n            num = n\n            while num > 0:\n                num_base += str(num % base)\n                num //= base\n            if not is_palindrome(num_base):\n                return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2392", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        def check_conditions(matrix, rowConditions, colConditions):\n            for i in range(len(rowConditions)):\n                above = rowConditions[i][0]\n                below = rowConditions[i][1]\n                above_row = -1\n                below_row = -1\n                for j in range(k):\n                    if matrix[j][i] == above:\n                        above_row = j\n                    if matrix[j][i] == below:\n                        below_row = j\n                if above_row >= below_row:\n                    return False\n            for i in range(len(colConditions)):\n                left = colConditions[i][0]\n                right = colConditions[i][1]\n                left_col = -1\n                right_col = -1\n                for j in range(k):\n                    if matrix[i][j] == left:\n                        left_col = j\n                    if matrix[i][j] == right:\n                        right_col = j\n                if left_col >= right_col:\n                    return False\n            return True\n        \n        def backtrack(matrix, row, col, k, rowConditions, colConditions):\n            if col == k:\n                col = 0\n                row += 1\n            if row == k:\n                return check_conditions(matrix, rowConditions, colConditions)\n            for num in range(1, k+1):\n                matrix[row][col] = num\n                if backtrack(matrix, row, col+1, k, rowConditions, colConditions):\n                    return True\n                matrix[row][col] = 0\n            return False\n        \n        matrix = [[0 for _ in range(k)] for _ in range(k)]\n        if backtrack(matrix, 0, 0, k, rowConditions, colConditions):\n            return matrix\n        return []\n```", "extracted_code": "\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        def check_conditions(matrix, rowConditions, colConditions):\n            for i in range(len(rowConditions)):\n                above = rowConditions[i][0]\n                below = rowConditions[i][1]\n                above_row = -1\n                below_row = -1\n                for j in range(k):\n                    if matrix[j][i] == above:\n                        above_row = j\n                    if matrix[j][i] == below:\n                        below_row = j\n                if above_row >= below_row:\n                    return False\n            for i in range(len(colConditions)):\n                left = colConditions[i][0]\n                right = colConditions[i][1]\n                left_col = -1\n                right_col = -1\n                for j in range(k):\n                    if matrix[i][j] == left:\n                        left_col = j\n                    if matrix[i][j] == right:\n                        right_col = j\n                if left_col >= right_col:\n                    return False\n            return True\n        \n        def backtrack(matrix, row, col, k, rowConditions, colConditions):\n            if col == k:\n                col = 0\n                row += 1\n            if row == k:\n                return check_conditions(matrix, rowConditions, colConditions)\n            for num in range(1, k+1):\n                matrix[row][col] = num\n                if backtrack(matrix, row, col+1, k, rowConditions, colConditions):\n                    return True\n                matrix[row][col] = 0\n            return False\n        \n        matrix = [[0 for _ in range(k)] for _ in range(k)]\n        if backtrack(matrix, 0, 0, k, rowConditions, colConditions):\n            return matrix\n        return []\n", "difficulty": 3.0}
{"task_id": "LeetCode/2390", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char == '*':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(char)\n        return ''.join(stack)\n```", "extracted_code": "\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char == '*':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(char)\n        return ''.join(stack)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2386", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\n\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums.sort(reverse=True)  # Sort the array in descending order\n        heap = []  # Create a heap to store the subsequence sums\n        heapq.heappush(heap, 0)  # Add 0 to the heap to handle the case of empty subsequence\n        \n        for num in nums:\n            sub_sum = num  # Initialize the sub_sum with the current number\n            \n            # Iterate through the heap and add the current number to each subsequence sum\n            for sub in heapq.nsmallest(len(heap), heap):\n                heapq.heappush(heap, sub + sub_sum)\n            \n            # Add the current number itself as a subsequence sum\n            heapq.heappush(heap, sub_sum)\n            \n            # If the heap size is greater than k, remove the smallest element\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        # Return the kth largest subsequence sum\n        return heapq.heappop(heap)\n```", "extracted_code": "\nimport heapq\n\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums.sort(reverse=True)  # Sort the array in descending order\n        heap = []  # Create a heap to store the subsequence sums\n        heapq.heappush(heap, 0)  # Add 0 to the heap to handle the case of empty subsequence\n        \n        for num in nums:\n            sub_sum = num  # Initialize the sub_sum with the current number\n            \n            # Iterate through the heap and add the current number to each subsequence sum\n            for sub in heapq.nsmallest(len(heap), heap):\n                heapq.heappush(heap, sub + sub_sum)\n            \n            # Add the current number itself as a subsequence sum\n            heapq.heappush(heap, sub_sum)\n            \n            # If the heap size is greater than k, remove the smallest element\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        # Return the kth largest subsequence sum\n        return heapq.heappop(heap)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2385", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        queue = [(root, 0)]\n        infected = set([start])\n        max_time = 0\n        \n        while queue:\n            node, time = queue.pop(0)\n            max_time = max(max_time, time)\n            \n            if node.left:\n                queue.append((node.left, time + 1))\n                if node.left.val not in infected:\n                    infected.add(node.left.val)\n                    \n            if node.right:\n                queue.append((node.right, time + 1))\n                if node.right.val not in infected:\n                    infected.add(node.right.val)\n                    \n        return max_time\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        queue = [(root, 0)]\n        infected = set([start])\n        max_time = 0\n        \n        while queue:\n            node, time = queue.pop(0)\n            max_time = max(max_time, time)\n            \n            if node.left:\n                queue.append((node.left, time + 1))\n                if node.left.val not in infected:\n                    infected.add(node.left.val)\n                    \n            if node.right:\n                queue.append((node.right, time + 1))\n                if node.right.val not in infected:\n                    infected.add(node.right.val)\n                    \n        return max_time\n", "difficulty": 2.0}
{"task_id": "LeetCode/2382", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        # Initialize the prefix sum array\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        \n        # Initialize the segment sums array\n        segment_sums = []\n        for i in range(1, len(prefix_sum)):\n            segment_sums.append(prefix_sum[i] - prefix_sum[i-1])\n        \n        # Initialize the result array\n        result = []\n        max_segment_sum = max(segment_sums)\n        result.append(max_segment_sum)\n        \n        # Remove elements and update segment sums\n        for query in removeQueries:\n            removed_num = nums[query]\n            nums[query] = 0\n            for i in range(query, len(prefix_sum)):\n                prefix_sum[i+1] = prefix_sum[i] - removed_num\n            segment_sum = prefix_sum[query+1] - prefix_sum[query]\n            segment_sums[query] = segment_sum\n            max_segment_sum = max(max_segment_sum, segment_sum)\n            result.append(max_segment_sum)\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        # Initialize the prefix sum array\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        \n        # Initialize the segment sums array\n        segment_sums = []\n        for i in range(1, len(prefix_sum)):\n            segment_sums.append(prefix_sum[i] - prefix_sum[i-1])\n        \n        # Initialize the result array\n        result = []\n        max_segment_sum = max(segment_sums)\n        result.append(max_segment_sum)\n        \n        # Remove elements and update segment sums\n        for query in removeQueries:\n            removed_num = nums[query]\n            nums[query] = 0\n            for i in range(query, len(prefix_sum)):\n                prefix_sum[i+1] = prefix_sum[i] - removed_num\n            segment_sum = prefix_sum[query+1] - prefix_sum[query]\n            segment_sums[query] = segment_sum\n            max_segment_sum = max(max_segment_sum, segment_sum)\n            result.append(max_segment_sum)\n        \n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2376", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        count = 0\n        for i in range(1, n+1):\n            if len(set(str(i))) == len(str(i)):\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        count = 0\n        for i in range(1, n+1):\n            if len(set(str(i))) == len(str(i)):\n                count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2368", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        # Create an adjacency matrix to represent the tree\n        graph = [[float('inf')] * n for _ in range(n)]\n        for u, v in edges:\n            graph[u][v] = 1\n            graph[v][u] = 1\n        \n        # Dijkstra's algorithm to find the shortest path from node 0 to all other nodes\n        distances = [float('inf')] * n\n        distances[0] = 0\n        visited = set()\n        while len(visited) < n:\n            # Find the node with the minimum distance\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if i not in visited and distances[i] < min_dist:\n                    min_dist = distances[i]\n                    min_node = i\n            visited.add(min_node)\n            \n            # Update the distances to the neighboring nodes\n            for i in range(n):\n                if i not in visited and graph[min_node][i] < float('inf'):\n                    distances[i] = min(distances[i], distances[min_node] + graph[min_node][i])\n        \n        # Count the number of nodes that can be reached from node 0 without visiting a restricted node\n        count = 0\n        for i in range(n):\n            if distances[i] <= 2 or i in restricted:\n                count += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        # Create an adjacency matrix to represent the tree\n        graph = [[float('inf')] * n for _ in range(n)]\n        for u, v in edges:\n            graph[u][v] = 1\n            graph[v][u] = 1\n        \n        # Dijkstra's algorithm to find the shortest path from node 0 to all other nodes\n        distances = [float('inf')] * n\n        distances[0] = 0\n        visited = set()\n        while len(visited) < n:\n            # Find the node with the minimum distance\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if i not in visited and distances[i] < min_dist:\n                    min_dist = distances[i]\n                    min_node = i\n            visited.add(min_node)\n            \n            # Update the distances to the neighboring nodes\n            for i in range(n):\n                if i not in visited and graph[min_node][i] < float('inf'):\n                    distances[i] = min(distances[i], distances[min_node] + graph[min_node][i])\n        \n        # Count the number of nodes that can be reached from node 0 without visiting a restricted node\n        count = 0\n        for i in range(n):\n            if distances[i] <= 2 or i in restricted:\n                count += 1\n        \n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2366", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n-1):\n            if nums[i] > nums[i+1]:\n                count += nums[i] - nums[i+1]\n                nums[i+1] = nums[i]\n        return count\n```", "extracted_code": "\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n-1):\n            if nums[i] > nums[i+1]:\n                count += nums[i] - nums[i+1]\n                nums[i+1] = nums[i]\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2365", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_counts = collections.Counter(tasks)\n        max_freq = max(task_counts.values())\n        num_most_freq = list(task_counts.values()).count(max_freq)\n        return max(len(tasks), (max_freq - 1) * (space + 1) + num_most_freq)\n```", "extracted_code": "\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_counts = collections.Counter(tasks)\n        max_freq = max(task_counts.values())\n        num_most_freq = list(task_counts.values()).count(max_freq)\n        return max(len(tasks), (max_freq - 1) * (space + 1) + num_most_freq)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2360", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        max_cycle_length = -1\n        \n        for i in range(n):\n            visited = set()\n            curr = i\n            cycle_length = 0\n            \n            while curr != -1:\n                if curr in visited:\n                    if curr == i:\n                        max_cycle_length = max(max_cycle_length, cycle_length)\n                        break\n                    else:\n                        break\n                visited.add(curr)\n                curr = edges[curr]\n                cycle_length += 1\n        \n        return max_cycle_length\n```", "extracted_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        max_cycle_length = -1\n        \n        for i in range(n):\n            visited = set()\n            curr = i\n            cycle_length = 0\n            \n            while curr != -1:\n                if curr in visited:\n                    if curr == i:\n                        max_cycle_length = max(max_cycle_length, cycle_length)\n                        break\n                    else:\n                        break\n                visited.add(curr)\n                curr = edges[curr]\n                cycle_length += 1\n        \n        return max_cycle_length\n", "difficulty": 3.0}
{"task_id": "LeetCode/2359", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        visited = [False] * n\n        \n        def dfs(node):\n            if node == node1 or node == node2:\n                return node\n            if visited[node]:\n                return -1\n            visited[node] = True\n            next_node = edges[node]\n            if next_node == -1:\n                return -1\n            return dfs(next_node)\n        \n        return dfs(node1)\n```", "extracted_code": "\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        visited = [False] * n\n        \n        def dfs(node):\n            if node == node1 or node == node2:\n                return node\n            if visited[node]:\n                return -1\n            visited[node] = True\n            next_node = edges[node]\n            if next_node == -1:\n                return -1\n            return dfs(next_node)\n        \n        return dfs(node1)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2354", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                num1 = nums[i]\n                num2 = nums[j]\n                set_bits = bin(num1 | num2).count('1')\n                and_bits = bin(num1 & num2).count('1')\n                if set_bits + and_bits >= k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                num1 = nums[i]\n                num2 = nums[j]\n                set_bits = bin(num1 | num2).count('1')\n                and_bits = bin(num1 & num2).count('1')\n                if set_bits + and_bits >= k:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2353", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.food_ratings = {}\n        self.cuisine_ratings = {}\n        for i in range(len(foods)):\n            food = foods[i]\n            cuisine = cuisines[i]\n            rating = ratings[i]\n            self.food_ratings[food] = rating\n            if cuisine not in self.cuisine_ratings:\n                self.cuisine_ratings[cuisine] = [(rating, food)]\n            else:\n                self.cuisine_ratings[cuisine].append((rating, food))\n        \n    def changeRating(self, food: str, newRating: int) -> None:\n        old_rating = self.food_ratings[food]\n        self.food_ratings[food] = newRating\n        for cuisine, foods in self.cuisine_ratings.items():\n            for i in range(len(foods)):\n                if foods[i][1] == food:\n                    foods[i] = (newRating, food)\n                    break\n        \n    def highestRated(self, cuisine: str) -> str:\n        foods = sorted(self.cuisine_ratings[cuisine], key=lambda x: (-x[0], x[1]))\n        return foods[0][1]\n```", "extracted_code": "\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.food_ratings = {}\n        self.cuisine_ratings = {}\n        for i in range(len(foods)):\n            food = foods[i]\n            cuisine = cuisines[i]\n            rating = ratings[i]\n            self.food_ratings[food] = rating\n            if cuisine not in self.cuisine_ratings:\n                self.cuisine_ratings[cuisine] = [(rating, food)]\n            else:\n                self.cuisine_ratings[cuisine].append((rating, food))\n        \n    def changeRating(self, food: str, newRating: int) -> None:\n        old_rating = self.food_ratings[food]\n        self.food_ratings[food] = newRating\n        for cuisine, foods in self.cuisine_ratings.items():\n            for i in range(len(foods)):\n                if foods[i][1] == food:\n                    foods[i] = (newRating, food)\n                    break\n        \n    def highestRated(self, cuisine: str) -> str:\n        foods = sorted(self.cuisine_ratings[cuisine], key=lambda x: (-x[0], x[1]))\n        return foods[0][1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2350", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        # Create a set to store all possible sequences of rolls\n        sequences = set()\n        \n        # Iterate through the rolls\n        for roll in rolls:\n            # Create a new set to store the updated sequences\n            new_sequences = set()\n            \n            # For each existing sequence, add the current roll\n            for seq in sequences:\n                new_sequences.add(seq + (roll,))\n            \n            # Add the current roll as a new sequence\n            new_sequences.add((roll,))\n            \n            # Update the sequences set\n            sequences.update(new_sequences)\n            \n        # Iterate through all possible sequences of length 1 to n\n        for length in range(1, len(rolls) + 1):\n            # Generate all possible sequences of length\n            possible_sequences = itertools.product(range(1, k + 1), repeat=length)\n            \n            # Check if each possible sequence is in the set of sequences\n            for seq in possible_sequences:\n                if seq not in sequences:\n                    return length\n        \n        # If all possible sequences are in the set, return n + 1\n        return len(rolls) + 1\n```", "extracted_code": "\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        # Create a set to store all possible sequences of rolls\n        sequences = set()\n        \n        # Iterate through the rolls\n        for roll in rolls:\n            # Create a new set to store the updated sequences\n            new_sequences = set()\n            \n            # For each existing sequence, add the current roll\n            for seq in sequences:\n                new_sequences.add(seq + (roll,))\n            \n            # Add the current roll as a new sequence\n            new_sequences.add((roll,))\n            \n            # Update the sequences set\n            sequences.update(new_sequences)\n            \n        # Iterate through all possible sequences of length 1 to n\n        for length in range(1, len(rolls) + 1):\n            # Generate all possible sequences of length\n            possible_sequences = itertools.product(range(1, k + 1), repeat=length)\n            \n            # Check if each possible sequence is in the set of sequences\n            for seq in possible_sequences:\n                if seq not in sequences:\n                    return length\n        \n        # If all possible sequences are in the set, return n + 1\n        return len(rolls) + 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2349", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass NumberContainers:\n    def __init__(self):\n        self.container = {}\n        \n    def change(self, index: int, number: int) -> None:\n        self.container[index] = number\n        \n    def find(self, number: int) -> int:\n        min_index = float('inf')\n        for index, num in self.container.items():\n            if num == number:\n                min_index = min(min_index, index)\n        return min_index if min_index != float('inf') else -1\n```", "extracted_code": "\nclass NumberContainers:\n    def __init__(self):\n        self.container = {}\n        \n    def change(self, index: int, number: int) -> None:\n        self.container[index] = number\n        \n    def find(self, number: int) -> int:\n        min_index = float('inf')\n        for index, num in self.container.items():\n            if num == number:\n                min_index = min(min_index, index)\n        return min_index if min_index != float('inf') else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2344", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        # Find the smallest element in nums\n        smallest = min(nums)\n        \n        # Check if smallest divides all elements in numsDivide\n        for num in numsDivide:\n            if num % smallest != 0:\n                return -1\n        \n        # Count the number of elements in nums that are equal to smallest\n        count = nums.count(smallest)\n        \n        # Return the minimum number of deletions needed\n        return len(nums) - count\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        # Find the smallest element in nums\n        smallest = min(nums)\n        \n        # Check if smallest divides all elements in numsDivide\n        for num in numsDivide:\n            if num % smallest != 0:\n                return -1\n        \n        # Count the number of elements in nums that are equal to smallest\n        count = nums.count(smallest)\n        \n        # Return the minimum number of deletions needed\n        return len(nums) - count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2343", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        # Function to trim each number in nums to its rightmost trim digits\n        def trimNumbers(nums: List[str], trim: int) -> List[str]:\n            trimmed_nums = []\n            for num in nums:\n                trimmed_nums.append(num[-trim:])\n            return trimmed_nums\n        \n        # Function to find the index of the kth smallest trimmed number in nums\n        def findIndex(nums: List[str], k: int) -> int:\n            sorted_nums = sorted(nums)\n            return nums.index(sorted_nums[k-1])\n        \n        answer = []\n        for query in queries:\n            k = query[0]  # kth smallest number\n            trim = query[1]  # number of digits to trim\n            \n            trimmed_nums = trimNumbers(nums, trim)\n            index = findIndex(trimmed_nums, k)\n            \n            answer.append(index)\n        \n        return answer\n```", "extracted_code": "\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        # Function to trim each number in nums to its rightmost trim digits\n        def trimNumbers(nums: List[str], trim: int) -> List[str]:\n            trimmed_nums = []\n            for num in nums:\n                trimmed_nums.append(num[-trim:])\n            return trimmed_nums\n        \n        # Function to find the index of the kth smallest trimmed number in nums\n        def findIndex(nums: List[str], k: int) -> int:\n            sorted_nums = sorted(nums)\n            return nums.index(sorted_nums[k-1])\n        \n        answer = []\n        for query in queries:\n            k = query[0]  # kth smallest number\n            trim = query[1]  # number of digits to trim\n            \n            trimmed_nums = trimNumbers(nums, trim)\n            index = findIndex(trimmed_nums, k)\n            \n            answer.append(index)\n        \n        return answer\n", "difficulty": 2.0}
{"task_id": "LeetCode/2342", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        digit_sums = {}\n        max_sum = -1\n        for num in nums:\n            digit_sum = sum(int(digit) for digit in str(num))\n            if digit_sum in digit_sums:\n                max_sum = max(max_sum, num + digit_sums[digit_sum])\n            digit_sums[digit_sum] = max(digit_sums.get(digit_sum, 0), num)\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        digit_sums = {}\n        max_sum = -1\n        for num in nums:\n            digit_sum = sum(int(digit) for digit in str(num))\n            if digit_sum in digit_sums:\n                max_sum = max(max_sum, num + digit_sums[digit_sum])\n            digit_sums[digit_sum] = max(digit_sums.get(digit_sum, 0), num)\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2338", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (maxValue + 1) for _ in range(n)]\n        for i in range(1, maxValue + 1):\n            dp[0][i] = 1\n        for i in range(1, n):\n            prefix_sum = [0] * (maxValue + 1)\n            prefix_sum[maxValue] = dp[i-1][maxValue]\n            for j in range(maxValue - 1, 0, -1):\n                prefix_sum[j] = (prefix_sum[j+1] + dp[i-1][j]) % MOD\n            for j in range(1, maxValue + 1):\n                dp[i][j] = prefix_sum[j]\n        return sum(dp[n-1]) % MOD\n```", "extracted_code": "\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (maxValue + 1) for _ in range(n)]\n        for i in range(1, maxValue + 1):\n            dp[0][i] = 1\n        for i in range(1, n):\n            prefix_sum = [0] * (maxValue + 1)\n            prefix_sum[maxValue] = dp[i-1][maxValue]\n            for j in range(maxValue - 1, 0, -1):\n                prefix_sum[j] = (prefix_sum[j+1] + dp[i-1][j]) % MOD\n            for j in range(1, maxValue + 1):\n                dp[i][j] = prefix_sum[j]\n        return sum(dp[n-1]) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2334", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        start = 0\n        end = 0\n        total = 0\n        count = 0\n        \n        while end < len(nums):\n            total += nums[end]\n            while total > threshold:\n                total -= nums[start]\n                start += 1\n            count += end - start + 1\n            end += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        start = 0\n        end = 0\n        total = 0\n        count = 0\n        \n        while end < len(nums):\n            total += nums[end]\n            while total > threshold:\n                total -= nums[start]\n                start += 1\n            count += end - start + 1\n            end += 1\n        \n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2333", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport numpy as np\n\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        n = len(nums1)\n        \n        # Sort both arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initialize pointers for both arrays\n        i = 0\n        j = 0\n        \n        # Iterate through the arrays and find the difference\n        while i < n and j < n:\n            diff = nums1[i] - nums2[j]\n            \n            # If the difference is positive, we can decrease the element in nums1\n            if diff > 0 and k1 > 0:\n                k1 -= 1\n                i += 1\n            \n            # If the difference is negative, we can increase the element in nums1\n            elif diff < 0 and k2 > 0:\n                k2 -= 1\n                j += 1\n            \n            # If the difference is 0, move to the next elements in both arrays\n            else:\n                i += 1\n                j += 1\n        \n        # Calculate the sum of squared difference\n        sum_square_diff = np.sum(np.square(nums1[i:]) - np.square(nums2[j:]))\n        \n        return sum_square_diff\n```", "extracted_code": "\nimport numpy as np\n\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        n = len(nums1)\n        \n        # Sort both arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initialize pointers for both arrays\n        i = 0\n        j = 0\n        \n        # Iterate through the arrays and find the difference\n        while i < n and j < n:\n            diff = nums1[i] - nums2[j]\n            \n            # If the difference is positive, we can decrease the element in nums1\n            if diff > 0 and k1 > 0:\n                k1 -= 1\n                i += 1\n            \n            # If the difference is negative, we can increase the element in nums1\n            elif diff < 0 and k2 > 0:\n                k2 -= 1\n                j += 1\n            \n            # If the difference is 0, move to the next elements in both arrays\n            else:\n                i += 1\n                j += 1\n        \n        # Calculate the sum of squared difference\n        sum_square_diff = np.sum(np.square(nums1[i:]) - np.square(nums2[j:]))\n        \n        return sum_square_diff\n", "difficulty": 2.0}
{"task_id": "LeetCode/2328", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[m-1][n-1] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if i+1 < m and grid[i+1][j] > grid[i][j]:\n                    dp[i][j] += dp[i+1][j]\n                if j+1 < n and grid[i][j+1] > grid[i][j]:\n                    dp[i][j] += dp[i][j+1]\n                dp[i][j] %= (10**9 + 7)\n        \n        return dp[0][0]\n```", "extracted_code": "\nclass Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[m-1][n-1] = 1\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if i+1 < m and grid[i+1][j] > grid[i][j]:\n                    dp[i][j] += dp[i+1][j]\n                if j+1 < n and grid[i][j+1] > grid[i][j]:\n                    dp[i][j] += dp[i][j+1]\n                dp[i][j] %= (10**9 + 7)\n        \n        return dp[0][0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2325", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        # Step 1: Create the substitution table\n        table = {}\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        for i in range(len(key)):\n            if key[i] not in table and key[i] != \" \":\n                table[key[i]] = alphabet[i]\n        \n        # Step 2: Substitute the message\n        decoded_message = \"\"\n        for char in message:\n            if char == \" \":\n                decoded_message += \" \"\n            else:\n                decoded_message += table[char]\n        \n        return decoded_message\n```", "extracted_code": "\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        # Step 1: Create the substitution table\n        table = {}\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        for i in range(len(key)):\n            if key[i] not in table and key[i] != \" \":\n                table[key[i]] = alphabet[i]\n        \n        # Step 2: Substitute the message\n        decoded_message = \"\"\n        for char in message:\n            if char == \" \":\n                decoded_message += \" \"\n            else:\n                decoded_message += table[char]\n        \n        return decoded_message\n", "difficulty": 1.0}
{"task_id": "LeetCode/2322", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent):\n            xor = nums[node]\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    xor ^= dfs(neighbor, node)\n            return xor\n        \n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        \n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        total_xor = dfs(0, -1)\n        min_score = float('inf')\n        \n        def dfs2(node, parent, xor):\n            nonlocal min_score\n            min_score = min(min_score, abs(2 * xor - total_xor))\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    dfs2(neighbor, node, xor ^ nums[node] ^ nums[neighbor])\n        \n        dfs2(0, -1, 0)\n        return min_score\n```", "extracted_code": "\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent):\n            xor = nums[node]\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    xor ^= dfs(neighbor, node)\n            return xor\n        \n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        \n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        total_xor = dfs(0, -1)\n        min_score = float('inf')\n        \n        def dfs2(node, parent, xor):\n            nonlocal min_score\n            min_score = min(min_score, abs(2 * xor - total_xor))\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    dfs2(neighbor, node, xor ^ nums[node] ^ nums[neighbor])\n        \n        dfs2(0, -1, 0)\n        return min_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2320", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        if n == 1:\n            return 4\n        elif n == 2:\n            return 9\n        else:\n            mod = 10**9 + 7\n            dp = [0] * (n + 1)\n            dp[1] = 4\n            dp[2] = 9\n            for i in range(3, n + 1):\n                dp[i] = (dp[i-1] * 2 + dp[i-2]) % mod\n            return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        if n == 1:\n            return 4\n        elif n == 2:\n            return 9\n        else:\n            mod = 10**9 + 7\n            dp = [0] * (n + 1)\n            dp[1] = 4\n            dp[2] = 9\n            for i in range(3, n + 1):\n                dp[i] = (dp[i-1] * 2 + dp[i-2]) % mod\n            return dp[n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2318", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        # Initialize dp array to store the number of distinct sequences for each roll\n        dp = [0] * (n+1)\n        \n        # Base cases\n        dp[1] = 6\n        dp[2] = 36\n        \n        # Iterate from roll 3 to roll n\n        for i in range(3, n+1):\n            # Calculate the number of distinct sequences for the current roll based on previous rolls\n            dp[i] = (2 * dp[i-1] + dp[i-2]) % (10**9 + 7)\n        \n        # Return the number of distinct sequences for roll n\n        return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        # Initialize dp array to store the number of distinct sequences for each roll\n        dp = [0] * (n+1)\n        \n        # Base cases\n        dp[1] = 6\n        dp[2] = 36\n        \n        # Iterate from roll 3 to roll n\n        for i in range(3, n+1):\n            # Calculate the number of distinct sequences for the current roll based on previous rolls\n            dp[i] = (2 * dp[i-1] + dp[i-2]) % (10**9 + 7)\n        \n        # Return the number of distinct sequences for roll n\n        return dp[n]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2317", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        max_xor = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            prefix_set = set()\n            for num in nums:\n                prefix_set.add(num & mask)\n            \n            temp = max_xor | (1 << i) # Set the ith bit of temp to 1\n            \n            for prefix in prefix_set:\n                if (temp ^ prefix) in prefix_set: # Check if temp ^ prefix is in prefix_set\n                    max_xor = temp\n                    break\n                    \n        return max_xor\n```", "extracted_code": "\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        max_xor = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            prefix_set = set()\n            for num in nums:\n                prefix_set.add(num & mask)\n            \n            temp = max_xor | (1 << i) # Set the ith bit of temp to 1\n            \n            for prefix in prefix_set:\n                if (temp ^ prefix) in prefix_set: # Check if temp ^ prefix is in prefix_set\n                    max_xor = temp\n                    break\n                    \n        return max_xor\n", "difficulty": 2.0}
{"task_id": "LeetCode/2306", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        # Create a set to store all valid names\n        valid_names = set()\n        \n        # Iterate through each pair of distinct names\n        for i in range(len(ideas)):\n            for j in range(i+1, len(ideas)):\n                idea_A = ideas[i]\n                idea_B = ideas[j]\n                \n                # Swap first letters of idea_A and idea_B\n                new_name_A = idea_B[0] + idea_A[1:]\n                new_name_B = idea_A[0] + idea_B[1:]\n                \n                # Check if both new names are not in the original array\n                if new_name_A not in ideas and new_name_B not in ideas:\n                    # Add the valid name to the set\n                    valid_names.add(new_name_A + \" \" + new_name_B)\n        \n        # Return the number of distinct valid names\n        return len(valid_names)\n```", "extracted_code": "\nclass Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        # Create a set to store all valid names\n        valid_names = set()\n        \n        # Iterate through each pair of distinct names\n        for i in range(len(ideas)):\n            for j in range(i+1, len(ideas)):\n                idea_A = ideas[i]\n                idea_B = ideas[j]\n                \n                # Swap first letters of idea_A and idea_B\n                new_name_A = idea_B[0] + idea_A[1:]\n                new_name_B = idea_A[0] + idea_B[1:]\n                \n                # Check if both new names are not in the original array\n                if new_name_A not in ideas and new_name_B not in ideas:\n                    # Add the valid name to the set\n                    valid_names.add(new_name_A + \" \" + new_name_B)\n        \n        # Return the number of distinct valid names\n        return len(valid_names)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2302", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        \n        for i in range(n):\n            product = 1\n            for j in range(i, n):\n                product *= nums[j]\n                if product < k:\n                    count += 1\n                else:\n                    break\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        \n        for i in range(n):\n            product = 1\n            for j in range(i, n):\n                product *= nums[j]\n                if product < k:\n                    count += 1\n                else:\n                    break\n        \n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2301", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        # Create a dictionary to store the mappings\n        map_dict = {}\n        for mapping in mappings:\n            old_char, new_char = mapping\n            map_dict[old_char] = new_char\n        \n        # Loop through each character in the substring\n        for i in range(len(sub)):\n            # If the character is not in the string, return False\n            if sub[i] not in s:\n                return False\n            # If the character is in the string and the mapping exists, replace the character in the substring\n            if sub[i] in s and sub[i] in map_dict:\n                s = s.replace(sub[i], map_dict[sub[i]], 1)\n        \n        # If the modified substring is a substring of the original string, return True\n        if sub in s:\n            return True\n        # Otherwise, return False\n        return False\n```", "extracted_code": "\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        # Create a dictionary to store the mappings\n        map_dict = {}\n        for mapping in mappings:\n            old_char, new_char = mapping\n            map_dict[old_char] = new_char\n        \n        # Loop through each character in the substring\n        for i in range(len(sub)):\n            # If the character is not in the string, return False\n            if sub[i] not in s:\n                return False\n            # If the character is in the string and the mapping exists, replace the character in the substring\n            if sub[i] in s and sub[i] in map_dict:\n                s = s.replace(sub[i], map_dict[sub[i]], 1)\n        \n        # If the modified substring is a substring of the original string, return True\n        if sub in s:\n            return True\n        # Otherwise, return False\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2296", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass TextEditor:\n\n    def __init__(self):\n        self.text = \"\"\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        k = min(k, self.cursor)\n        deleted = self.text[self.cursor - k : self.cursor]\n        self.text = self.text[:self.cursor - k] + self.text[self.cursor:]\n        self.cursor -= k\n        return len(deleted)\n\n    def cursorLeft(self, k: int) -> str:\n        k = min(k, self.cursor)\n        self.cursor -= k\n        return self.text[self.cursor - min(10, self.cursor) : self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        k = min(k, len(self.text) - self.cursor)\n        self.cursor += k\n        return self.text[self.cursor - min(10, self.cursor) : self.cursor]\n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)\n```", "extracted_code": "\nclass TextEditor:\n\n    def __init__(self):\n        self.text = \"\"\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        k = min(k, self.cursor)\n        deleted = self.text[self.cursor - k : self.cursor]\n        self.text = self.text[:self.cursor - k] + self.text[self.cursor:]\n        self.cursor -= k\n        return len(deleted)\n\n    def cursorLeft(self, k: int) -> str:\n        k = min(k, self.cursor)\n        self.cursor -= k\n        return self.text[self.cursor - min(10, self.cursor) : self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        k = min(k, len(self.text) - self.cursor)\n        self.cursor += k\n        return self.text[self.cursor - min(10, self.cursor) : self.cursor]\n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2294", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        counter = collections.Counter(nums)\n        freq = sorted(counter.values())\n        num_partitions = 0\n        \n        for f in freq:\n            if f == 0:\n                continue\n            for i in range(f):\n                if i < len(freq) - 1 and i < k:\n                    freq[i+1] -= 1\n                else:\n                    num_partitions += 1\n        return num_partitions\n```", "extracted_code": "\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        counter = collections.Counter(nums)\n        freq = sorted(counter.values())\n        num_partitions = 0\n        \n        for f in freq:\n            if f == 0:\n                continue\n            for i in range(f):\n                if i < len(freq) - 1 and i < k:\n                    freq[i+1] -= 1\n                else:\n                    num_partitions += 1\n        return num_partitions\n", "difficulty": 2.0}
{"task_id": "LeetCode/2290", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        queue = deque([(0, 0, 0)])\n        visited = set([(0, 0)])\n        \n        while queue:\n            x, y, obstacles = queue.popleft()\n            \n            if x == m - 1 and y == n - 1:\n                return obstacles\n            \n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    \n                    if grid[nx][ny] == 0:\n                        queue.appendleft((nx, ny, obstacles))\n                    else:\n                        queue.append((nx, ny, obstacles + 1))\n        \n        return -1\n```", "extracted_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        queue = deque([(0, 0, 0)])\n        visited = set([(0, 0)])\n        \n        while queue:\n            x, y, obstacles = queue.popleft()\n            \n            if x == m - 1 and y == n - 1:\n                return obstacles\n            \n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    \n                    if grid[nx][ny] == 0:\n                        queue.appendleft((nx, ny, obstacles))\n                    else:\n                        queue.append((nx, ny, obstacles + 1))\n        \n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2286", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass BookMyShow:\n    def __init__(self, n: int, m: int):\n        self.seats = [[False] * m for _ in range(n)]\n        self.n = n\n        self.m = m\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for row in range(maxRow + 1):\n            count = 0\n            start = -1\n            for seat in range(self.m):\n                if not self.seats[row][seat]:\n                    if start == -1:\n                        start = seat\n                    count += 1\n                    if count == k:\n                        for i in range(start, start + k):\n                            self.seats[row][i] = True\n                        return [row, start]\n                else:\n                    count = 0\n                    start = -1\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        count = 0\n        for row in range(self.n):\n            for seat in range(self.m):\n                if not self.seats[row][seat]:\n                    count += 1\n                    self.seats[row][seat] = True\n                    if count == k:\n                        return True\n            if row > maxRow:\n                break\n        return False\n```", "extracted_code": "\nclass BookMyShow:\n    def __init__(self, n: int, m: int):\n        self.seats = [[False] * m for _ in range(n)]\n        self.n = n\n        self.m = m\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for row in range(maxRow + 1):\n            count = 0\n            start = -1\n            for seat in range(self.m):\n                if not self.seats[row][seat]:\n                    if start == -1:\n                        start = seat\n                    count += 1\n                    if count == k:\n                        for i in range(start, start + k):\n                            self.seats[row][i] = True\n                        return [row, start]\n                else:\n                    count = 0\n                    start = -1\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        count = 0\n        for row in range(self.n):\n            for seat in range(self.m):\n                if not self.seats[row][seat]:\n                    count += 1\n                    self.seats[row][seat] = True\n                    if count == k:\n                        return True\n            if row > maxRow:\n                break\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2284", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_count = {}\n        max_count = 0\n        max_sender = \"\"\n        \n        for i in range(len(messages)):\n            sender = senders[i]\n            message = messages[i]\n            count = len(message.split())\n            \n            if sender not in word_count:\n                word_count[sender] = count\n            else:\n                word_count[sender] += count\n            \n            if word_count[sender] > max_count:\n                max_count = word_count[sender]\n                max_sender = sender\n            elif word_count[sender] == max_count and sender > max_sender:\n                max_sender = sender\n        \n        return max_sender\n```", "extracted_code": "\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_count = {}\n        max_count = 0\n        max_sender = \"\"\n        \n        for i in range(len(messages)):\n            sender = senders[i]\n            message = messages[i]\n            count = len(message.split())\n            \n            if sender not in word_count:\n                word_count[sender] = count\n            else:\n                word_count[sender] += count\n            \n            if word_count[sender] > max_count:\n                max_count = word_count[sender]\n                max_sender = sender\n            elif word_count[sender] == max_count and sender > max_sender:\n                max_sender = sender\n        \n        return max_sender\n", "difficulty": 2.0}
{"task_id": "LeetCode/2281", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        n = len(strength)\n        mod = 10**9 + 7\n        total = 0\n        \n        for i in range(n):\n            min_strength = strength[i]\n            sum_strength = strength[i]\n            total += min_strength * sum_strength % mod\n            \n            for j in range(i+1, n):\n                min_strength = min(min_strength, strength[j])\n                sum_strength += strength[j]\n                total += min_strength * sum_strength % mod\n        \n        return total % mod\n```", "extracted_code": "\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        n = len(strength)\n        mod = 10**9 + 7\n        total = 0\n        \n        for i in range(n):\n            min_strength = strength[i]\n            sum_strength = strength[i]\n            total += min_strength * sum_strength % mod\n            \n            for j in range(i+1, n):\n                min_strength = min(min_strength, strength[j])\n                sum_strength += strength[j]\n                total += min_strength * sum_strength % mod\n        \n        return total % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2279", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        n = len(capacity)\n        full_capacity = 0\n        for i in range(n):\n            rocks_needed = capacity[i] - rocks[i]\n            additionalRocks -= rocks_needed\n            if additionalRocks < 0:\n                rocks_needed = capacity[i] - rocks[i] + additionalRocks\n                additionalRocks = 0\n            if rocks_needed > 0:\n                full_capacity += 1\n        return full_capacity\n```", "extracted_code": "\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        n = len(capacity)\n        full_capacity = 0\n        for i in range(n):\n            rocks_needed = capacity[i] - rocks[i]\n            additionalRocks -= rocks_needed\n            if additionalRocks < 0:\n                rocks_needed = capacity[i] - rocks[i] + additionalRocks\n                additionalRocks = 0\n            if rocks_needed > 0:\n                full_capacity += 1\n        return full_capacity\n", "difficulty": 2.0}
{"task_id": "LeetCode/2276", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        nums = set()\n        for interval in self.intervals:\n            nums.update(range(interval[0], interval[1] + 1))\n        return len(nums)\n```", "extracted_code": "\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        nums = set()\n        for interval in self.intervals:\n            nums.update(range(interval[0], interval[1] + 1))\n        return len(nums)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2275", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        n = len(candidates)\n        combinations = []\n        for i in range(1, n+1):\n            for subset in combinations(candidates, i):\n                bitwise_and = subset[0]\n                for j in range(1, i):\n                    bitwise_and &= subset[j]\n                if bitwise_and > 0:\n                    combinations.append(subset)\n        return max(len(combination) for combination in combinations)\n```", "extracted_code": "\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        n = len(candidates)\n        combinations = []\n        for i in range(1, n+1):\n            for subset in combinations(candidates, i):\n                bitwise_and = subset[0]\n                for j in range(1, i):\n                    bitwise_and &= subset[j]\n                if bitwise_and > 0:\n                    combinations.append(subset)\n        return max(len(combination) for combination in combinations)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2272", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        variance = 0\n        \n        # iterate through each character in the string\n        for i in range(len(s)):\n            # iterate through each character starting from the current character\n            for j in range(i, len(s)):\n                # count the occurrences of each character\n                count = {}\n                for k in range(i, j+1):\n                    if s[k] not in count:\n                        count[s[k]] = 0\n                    count[s[k]] += 1\n                \n                # find the maximum difference between the occurrences of any two characters\n                max_diff = 0\n                for char, freq in count.items():\n                    for other_char, other_freq in count.items():\n                        diff = abs(freq - other_freq)\n                        max_diff = max(max_diff, diff)\n                \n                # update the largest variance\n                variance = max(variance, max_diff)\n        \n        return variance\n```", "extracted_code": "\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        variance = 0\n        \n        # iterate through each character in the string\n        for i in range(len(s)):\n            # iterate through each character starting from the current character\n            for j in range(i, len(s)):\n                # count the occurrences of each character\n                count = {}\n                for k in range(i, j+1):\n                    if s[k] not in count:\n                        count[s[k]] = 0\n                    count[s[k]] += 1\n                \n                # find the maximum difference between the occurrences of any two characters\n                max_diff = 0\n                for char, freq in count.items():\n                    for other_char, other_freq in count.items():\n                        diff = abs(freq - other_freq)\n                        max_diff = max(max_diff, diff)\n                \n                # update the largest variance\n                variance = max(variance, max_diff)\n        \n        return variance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2271", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        max_white_tiles = 0\n        for tile in tiles:\n            max_white_tiles = max(max_white_tiles, tile[1] - tile[0] + 1)\n        return max_white_tiles\n```", "extracted_code": "\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        max_white_tiles = 0\n        for tile in tiles:\n            max_white_tiles = max(max_white_tiles, tile[1] - tile[0] + 1)\n        return max_white_tiles\n", "difficulty": 2.0}
{"task_id": "LeetCode/2270", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * n\n        prefix_sum[0] = nums[0]\n        \n        for i in range(1, n):\n            prefix_sum[i] = prefix_sum[i-1] + nums[i]\n        \n        ans = 0\n        MOD = 10**9 + 7\n        \n        for i in range(n-2):\n            left_sum = prefix_sum[i]\n            start = i + 1\n            end = n - 2\n            first_split = -1\n            \n            while start <= end:\n                mid = (start + end) // 2\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\n                if mid_sum >= left_sum:\n                    first_split = mid\n                    end = mid - 1\n                else:\n                    start = mid + 1\n            \n            if first_split == -1:\n                break\n            \n            start = i + 1\n            end = n - 2\n            last_split = -1\n            \n            while start <= end:\n                mid = (start + end) // 2\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\n                right_sum = prefix_sum[n-1] - prefix_sum[mid]\n                if mid_sum <= right_sum:\n                    last_split = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            \n            if last_split == -1:\n                continue\n            \n            ans = (ans + last_split - first_split + 1) % MOD\n        \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * n\n        prefix_sum[0] = nums[0]\n        \n        for i in range(1, n):\n            prefix_sum[i] = prefix_sum[i-1] + nums[i]\n        \n        ans = 0\n        MOD = 10**9 + 7\n        \n        for i in range(n-2):\n            left_sum = prefix_sum[i]\n            start = i + 1\n            end = n - 2\n            first_split = -1\n            \n            while start <= end:\n                mid = (start + end) // 2\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\n                if mid_sum >= left_sum:\n                    first_split = mid\n                    end = mid - 1\n                else:\n                    start = mid + 1\n            \n            if first_split == -1:\n                break\n            \n            start = i + 1\n            end = n - 2\n            last_split = -1\n            \n            while start <= end:\n                mid = (start + end) // 2\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\n                right_sum = prefix_sum[n-1] - prefix_sum[mid]\n                if mid_sum <= right_sum:\n                    last_split = mid\n                    start = mid + 1\n                else:\n                    end = mid - 1\n            \n            if last_split == -1:\n                continue\n            \n            ans = (ans + last_split - first_split + 1) % MOD\n        \n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2269", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        count = 0\n        num_str = str(num)\n        for i in range(len(num_str)-k+1):\n            substr = int(num_str[i:i+k])\n            if substr != 0 and num % substr == 0:\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        count = 0\n        num_str = str(num)\n        for i in range(len(num_str)-k+1):\n            substr = int(num_str[i:i+k])\n            if substr != 0 and num % substr == 0:\n                count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2267", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        \n        # Create a dictionary to store the possible connections for each type of cell\n        connections = {\n            '1': [(0, -1), (0, 1)],\n            '2': [(-1, 0), (1, 0)],\n            '3': [(0, -1), (1, 0)],\n            '4': [(0, 1), (1, 0)],\n            '5': [(0, -1), (-1, 0)],\n            '6': [(0, 1), (-1, 0)]\n        }\n        \n        # Create a dictionary to store the allowed connections for each type of cell\n        allowed_connections = {\n            '1': ['left', 'right'],\n            '2': ['up', 'down'],\n            '3': ['left', 'down'],\n            '4': ['right', 'down'],\n            '5': ['left', 'up'],\n            '6': ['right', 'up']\n        }\n        \n        # Create a visited matrix to keep track of visited cells\n        visited = [[False] * n for _ in range(m)]\n        \n        # Define a DFS function to explore the grid\n        def dfs(i, j):\n            visited[i][j] = True\n            \n            # Check if we have reached the bottom-right cell\n            if i == m - 1 and j == n - 1:\n                return True\n            \n            # Get the possible connections for the current cell type\n            curr_connections = connections[grid[i][j]]\n            \n            # Iterate through the possible connections\n            for di, dj in curr_connections:\n                ni, nj = i + di, j + dj\n                \n                # Check if the next cell is within the grid and not visited\n                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:\n                    # Check if the connection is allowed for the current cell type\n                    if (di, dj) in allowed_connections[grid[i][j]]:\n                        # Check if the next cell can be reached from the current cell\n                        if (-di, -dj) in connections[grid[ni][nj]]:\n                            # Recursively explore the next cell\n                            if dfs(ni, nj):\n                                return True\n            \n            return False\n        \n        # Start the DFS from the top-left cell\n        return dfs(0, 0)\n```", "extracted_code": "\nclass Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        \n        # Create a dictionary to store the possible connections for each type of cell\n        connections = {\n            '1': [(0, -1), (0, 1)],\n            '2': [(-1, 0), (1, 0)],\n            '3': [(0, -1), (1, 0)],\n            '4': [(0, 1), (1, 0)],\n            '5': [(0, -1), (-1, 0)],\n            '6': [(0, 1), (-1, 0)]\n        }\n        \n        # Create a dictionary to store the allowed connections for each type of cell\n        allowed_connections = {\n            '1': ['left', 'right'],\n            '2': ['up', 'down'],\n            '3': ['left', 'down'],\n            '4': ['right', 'down'],\n            '5': ['left', 'up'],\n            '6': ['right', 'up']\n        }\n        \n        # Create a visited matrix to keep track of visited cells\n        visited = [[False] * n for _ in range(m)]\n        \n        # Define a DFS function to explore the grid\n        def dfs(i, j):\n            visited[i][j] = True\n            \n            # Check if we have reached the bottom-right cell\n            if i == m - 1 and j == n - 1:\n                return True\n            \n            # Get the possible connections for the current cell type\n            curr_connections = connections[grid[i][j]]\n            \n            # Iterate through the possible connections\n            for di, dj in curr_connections:\n                ni, nj = i + di, j + dj\n                \n                # Check if the next cell is within the grid and not visited\n                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:\n                    # Check if the connection is allowed for the current cell type\n                    if (di, dj) in allowed_connections[grid[i][j]]:\n                        # Check if the next cell can be reached from the current cell\n                        if (-di, -dj) in connections[grid[ni][nj]]:\n                            # Recursively explore the next cell\n                            if dfs(ni, nj):\n                                return True\n            \n            return False\n        \n        # Start the DFS from the top-left cell\n        return dfs(0, 0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2262", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        n = len(s)\n        appeal_sum = 0\n        \n        for i in range(n):\n            distinct_chars = set()\n            for j in range(i, n):\n                distinct_chars.add(s[j])\n                appeal_sum += len(distinct_chars)\n        \n        return appeal_sum\n```", "extracted_code": "\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        n = len(s)\n        appeal_sum = 0\n        \n        for i in range(n):\n            distinct_chars = set()\n            for j in range(i, n):\n                distinct_chars.add(s[j])\n                appeal_sum += len(distinct_chars)\n        \n        return appeal_sum\n", "difficulty": 3.0}
{"task_id": "LeetCode/2259", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        # Find the index of the first occurrence of digit in number\n        index = number.index(digit)\n        \n        # Remove the digit at the found index and return the resulting string\n        return number[:index] + number[index+1:]\n```", "extracted_code": "\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        # Find the index of the first occurrence of digit in number\n        index = number.index(digit)\n        \n        # Remove the digit at the found index and return the resulting string\n        return number[:index] + number[index+1:]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2258", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('-inf')] * n for _ in range(m)]\n        \n        def dfs(i, j, t):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 2 or max(dp[i][j], t) <= dp[i][j]:\n                return\n            dp[i][j] = max(dp[i][j], t)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                dfs(i + dx, j + dy, t + 1)\n        \n        dfs(0, 0, 0)\n        return dp[m - 1][n - 1] if dp[m - 1][n - 1] > float('-inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('-inf')] * n for _ in range(m)]\n        \n        def dfs(i, j, t):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 2 or max(dp[i][j], t) <= dp[i][j]:\n                return\n            dp[i][j] = max(dp[i][j], t)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                dfs(i + dx, j + dy, t + 1)\n        \n        dfs(0, 0, 0)\n        return dp[m - 1][n - 1] if dp[m - 1][n - 1] > float('-inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2251", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        n = len(flowers)\n        m = len(people)\n        ans = [0] * m\n        \n        # create a list of tuples (start, end, index) for each flower\n        bloom_times = [(start, end, i) for i, (start, end) in enumerate(flowers)]\n        \n        # sort the flowers by start time\n        bloom_times.sort()\n        \n        # sort the people arrival times\n        people.sort()\n        \n        # initialize an empty set to store the blooming flowers\n        blooming = set()\n        \n        # initialize the index for the next flower to bloom\n        i = 0\n        \n        # iterate over the people arrival times\n        for j in range(m):\n            # get the arrival time of the current person\n            arrival_time = people[j]\n            \n            # remove the flowers that have passed their end time from the blooming set\n            to_remove = []\n            for flower in blooming:\n                start, end, _ = bloom_times[flower]\n                if end < arrival_time:\n                    to_remove.append(flower)\n            \n            for flower in to_remove:\n                blooming.remove(flower)\n            \n            # add the flowers that have started blooming and have not yet ended to the blooming set\n            while i < n and bloom_times[i][0] <= arrival_time:\n                blooming.add(bloom_times[i][2])\n                i += 1\n            \n            # store the number of blooming flowers for the current person\n            ans[j] = len(blooming)\n        \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        n = len(flowers)\n        m = len(people)\n        ans = [0] * m\n        \n        # create a list of tuples (start, end, index) for each flower\n        bloom_times = [(start, end, i) for i, (start, end) in enumerate(flowers)]\n        \n        # sort the flowers by start time\n        bloom_times.sort()\n        \n        # sort the people arrival times\n        people.sort()\n        \n        # initialize an empty set to store the blooming flowers\n        blooming = set()\n        \n        # initialize the index for the next flower to bloom\n        i = 0\n        \n        # iterate over the people arrival times\n        for j in range(m):\n            # get the arrival time of the current person\n            arrival_time = people[j]\n            \n            # remove the flowers that have passed their end time from the blooming set\n            to_remove = []\n            for flower in blooming:\n                start, end, _ = bloom_times[flower]\n                if end < arrival_time:\n                    to_remove.append(flower)\n            \n            for flower in to_remove:\n                blooming.remove(flower)\n            \n            # add the flowers that have started blooming and have not yet ended to the blooming set\n            while i < n and bloom_times[i][0] <= arrival_time:\n                blooming.add(bloom_times[i][2])\n                i += 1\n            \n            # store the number of blooming flowers for the current person\n            ans[j] = len(blooming)\n        \n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2248", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        common_elements = set(nums[0])\n        for arr in nums:\n            common_elements = common_elements.intersection(set(arr))\n        return sorted(list(common_elements))\n```", "extracted_code": "\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        common_elements = set(nums[0])\n        for arr in nums:\n            common_elements = common_elements.intersection(set(arr))\n        return sorted(list(common_elements))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2246", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        # Create an adjacency list representation of the tree\n        adj_list = [[] for _ in range(len(parent))]\n        for i in range(1, len(parent)):\n            adj_list[parent[i]].append(i)\n        \n        # Create a dictionary to store the maximum length of path for each character\n        max_path_length = {}\n        \n        # Define a recursive helper function to calculate the maximum path length\n        def dfs(node, prev_char):\n            if s[node] in max_path_length:\n                return max_path_length[s[node]]\n            \n            max_length = 0\n            for child in adj_list[node]:\n                if s[child] != prev_char:\n                    max_length = max(max_length, dfs(child, s[child]))\n            \n            # Update the maximum path length for the current character\n            max_path_length[s[node]] = max_length + 1\n            return max_length + 1\n        \n        # Start the DFS traversal from the root node\n        return dfs(0, '')\n```", "extracted_code": "\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        # Create an adjacency list representation of the tree\n        adj_list = [[] for _ in range(len(parent))]\n        for i in range(1, len(parent)):\n            adj_list[parent[i]].append(i)\n        \n        # Create a dictionary to store the maximum length of path for each character\n        max_path_length = {}\n        \n        # Define a recursive helper function to calculate the maximum path length\n        def dfs(node, prev_char):\n            if s[node] in max_path_length:\n                return max_path_length[s[node]]\n            \n            max_length = 0\n            for child in adj_list[node]:\n                if s[child] != prev_char:\n                    max_length = max(max_length, dfs(child, s[child]))\n            \n            # Update the maximum path length for the current character\n            max_path_length[s[node]] = max_length + 1\n            return max_length + 1\n        \n        # Start the DFS traversal from the root node\n        return dfs(0, '')\n", "difficulty": 3.0}
{"task_id": "LeetCode/2245", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_trailing_zeros = 0\n        \n        # Calculate trailing zeros for horizontal paths\n        for i in range(m):\n            zeros = 0\n            for j in range(n):\n                if grid[i][j] % 10 == 0:\n                    zeros += 1\n                else:\n                    zeros = 0\n                max_trailing_zeros = max(max_trailing_zeros, zeros)\n        \n        # Calculate trailing zeros for vertical paths\n        for j in range(n):\n            zeros = 0\n            for i in range(m):\n                if grid[i][j] % 10 == 0:\n                    zeros += 1\n                else:\n                    zeros = 0\n                max_trailing_zeros = max(max_trailing_zeros, zeros)\n        \n        return max_trailing_zeros\n```", "extracted_code": "\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_trailing_zeros = 0\n        \n        # Calculate trailing zeros for horizontal paths\n        for i in range(m):\n            zeros = 0\n            for j in range(n):\n                if grid[i][j] % 10 == 0:\n                    zeros += 1\n                else:\n                    zeros = 0\n                max_trailing_zeros = max(max_trailing_zeros, zeros)\n        \n        # Calculate trailing zeros for vertical paths\n        for j in range(n):\n            zeros = 0\n            for i in range(m):\n                if grid[i][j] % 10 == 0:\n                    zeros += 1\n                else:\n                    zeros = 0\n                max_trailing_zeros = max(max_trailing_zeros, zeros)\n        \n        return max_trailing_zeros\n", "difficulty": 2.0}
{"task_id": "LeetCode/2242", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        # Create an adjacency list to store the edges\n        adj_list = [[] for _ in range(len(scores))]\n        for edge in edges:\n            adj_list[edge[0]].append(edge[1])\n            adj_list[edge[1]].append(edge[0])\n        \n        # Sort the scores in descending order\n        scores.sort(reverse=True)\n        \n        # Initialize the maximum score\n        max_score = -1\n        \n        # Iterate through all possible combinations of 4 nodes\n        for i in range(len(scores)-3):\n            for j in range(i+1, len(scores)-2):\n                for k in range(j+1, len(scores)-1):\n                    for l in range(k+1, len(scores)):\n                        # Check if the nodes form a valid sequence\n                        if j in adj_list[i] and k in adj_list[j] and l in adj_list[k]:\n                            # Calculate the score of the sequence\n                            sequence_score = scores[i] + scores[j] + scores[k] + scores[l]\n                            # Update the maximum score if necessary\n                            max_score = max(max_score, sequence_score)\n        \n        return max_score\n```", "extracted_code": "\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        # Create an adjacency list to store the edges\n        adj_list = [[] for _ in range(len(scores))]\n        for edge in edges:\n            adj_list[edge[0]].append(edge[1])\n            adj_list[edge[1]].append(edge[0])\n        \n        # Sort the scores in descending order\n        scores.sort(reverse=True)\n        \n        # Initialize the maximum score\n        max_score = -1\n        \n        # Iterate through all possible combinations of 4 nodes\n        for i in range(len(scores)-3):\n            for j in range(i+1, len(scores)-2):\n                for k in range(j+1, len(scores)-1):\n                    for l in range(k+1, len(scores)):\n                        # Check if the nodes form a valid sequence\n                        if j in adj_list[i] and k in adj_list[j] and l in adj_list[k]:\n                            # Calculate the score of the sequence\n                            sequence_score = scores[i] + scores[j] + scores[k] + scores[l]\n                            # Update the maximum score if necessary\n                            max_score = max(max_score, sequence_score)\n        \n        return max_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2241", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount):\n        for i in range(len(banknotesCount)):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount):\n        withdraw_banknotes = [0, 0, 0, 0, 0]\n        for i in range(4, -1, -1):\n            withdraw_banknotes[i] = min(amount // [20, 50, 100, 200, 500][i], self.banknotes[i])\n            amount -= withdraw_banknotes[i] * [20, 50, 100, 200, 500][i]\n        if amount == 0:\n            for i in range(len(self.banknotes)):\n                self.banknotes[i] -= withdraw_banknotes[i]\n            return withdraw_banknotes\n        else:\n            return [-1]\n```", "extracted_code": "\nclass ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount):\n        for i in range(len(banknotesCount)):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount):\n        withdraw_banknotes = [0, 0, 0, 0, 0]\n        for i in range(4, -1, -1):\n            withdraw_banknotes[i] = min(amount // [20, 50, 100, 200, 500][i], self.banknotes[i])\n            amount -= withdraw_banknotes[i] * [20, 50, 100, 200, 500][i]\n        if amount == 0:\n            for i in range(len(self.banknotes)):\n                self.banknotes[i] -= withdraw_banknotes[i]\n            return withdraw_banknotes\n        else:\n            return [-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2234", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        # Calculate the total number of flowers in all gardens\n        total_flowers = sum(flowers)\n        \n        # Calculate the number of complete gardens\n        complete_gardens = sum(1 for garden in flowers if garden >= target)\n        \n        # Calculate the minimum number of flowers in incomplete gardens\n        min_incomplete = min(garden for garden in flowers if garden < target)\n        \n        # Calculate the maximum total beauty\n        max_beauty = complete_gardens * full + min_incomplete * partial\n        \n        # Calculate the maximum number of flowers that can be added\n        max_add_flowers = newFlowers - total_flowers\n        \n        # If there are enough new flowers to complete all incomplete gardens\n        if max_add_flowers >= (target - min_incomplete):\n            max_beauty += full * (complete_gardens + 1) + partial * (target - min_incomplete)\n        else:\n            max_beauty += full * complete_gardens + partial * max_add_flowers\n        \n        return max_beauty\n```", "extracted_code": "\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        # Calculate the total number of flowers in all gardens\n        total_flowers = sum(flowers)\n        \n        # Calculate the number of complete gardens\n        complete_gardens = sum(1 for garden in flowers if garden >= target)\n        \n        # Calculate the minimum number of flowers in incomplete gardens\n        min_incomplete = min(garden for garden in flowers if garden < target)\n        \n        # Calculate the maximum total beauty\n        max_beauty = complete_gardens * full + min_incomplete * partial\n        \n        # Calculate the maximum number of flowers that can be added\n        max_add_flowers = newFlowers - total_flowers\n        \n        # If there are enough new flowers to complete all incomplete gardens\n        if max_add_flowers >= (target - min_incomplete):\n            max_beauty += full * (complete_gardens + 1) + partial * (target - min_incomplete)\n        else:\n            max_beauty += full * complete_gardens + partial * max_add_flowers\n        \n        return max_beauty\n", "difficulty": 3.0}
{"task_id": "LeetCode/2223", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        scores = [0] * n\n        scores[n-1] = n\n        \n        for i in range(n-2, -1, -1):\n            j = 0\n            while i+j < n and s[i+j] == s[j]:\n                j += 1\n            scores[i] = j\n        \n        return sum(scores)\n```", "extracted_code": "\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        scores = [0] * n\n        scores[n-1] = n\n        \n        for i in range(n-2, -1, -1):\n            j = 0\n            while i+j < n and s[i+j] == s[j]:\n                j += 1\n            scores[i] = j\n        \n        return sum(scores)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2206", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        freq = {}\n        for num in nums:\n            freq[num] = freq.get(num, 0) + 1\n        for count in freq.values():\n            if count % 2 != 0:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        freq = {}\n        for num in nums:\n            freq[num] = freq.get(num, 0) + 1\n        for count in freq.values():\n            if count % 2 != 0:\n                return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2160", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        # Convert num to a string\n        num_str = str(num)\n        \n        # Initialize two empty strings for new1 and new2\n        new1 = \"\"\n        new2 = \"\"\n        \n        # Sort the digits in num in ascending order\n        sorted_digits = sorted(num_str)\n        \n        # Iterate through the sorted digits\n        for digit in sorted_digits:\n            # If new1 is empty or the last digit of new1 is smaller than the current digit, append the current digit to new1\n            if not new1 or new1[-1] < digit:\n                new1 += digit\n            # Otherwise, append the current digit to new2\n            else:\n                new2 += digit\n        \n        # Convert new1 and new2 back to integers\n        new1 = int(new1)\n        new2 = int(new2)\n        \n        # Return the sum of new1 and new2\n        return new1 + new2\n```", "extracted_code": "\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        # Convert num to a string\n        num_str = str(num)\n        \n        # Initialize two empty strings for new1 and new2\n        new1 = \"\"\n        new2 = \"\"\n        \n        # Sort the digits in num in ascending order\n        sorted_digits = sorted(num_str)\n        \n        # Iterate through the sorted digits\n        for digit in sorted_digits:\n            # If new1 is empty or the last digit of new1 is smaller than the current digit, append the current digit to new1\n            if not new1 or new1[-1] < digit:\n                new1 += digit\n            # Otherwise, append the current digit to new2\n            else:\n                new2 += digit\n        \n        # Convert new1 and new2 back to integers\n        new1 = int(new1)\n        new2 = int(new2)\n        \n        # Return the sum of new1 and new2\n        return new1 + new2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2148", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        count = 0\n        nums.sort()\n        for i in range(1, len(nums) - 1):\n            if nums[i] > nums[i-1] and nums[i] < nums[i+1]:\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        count = 0\n        nums.sort()\n        for i in range(1, len(nums) - 1):\n            if nums[i] > nums[i-1] and nums[i] < nums[i+1]:\n                count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2068", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        freq1 = [0] * 26\n        freq2 = [0] * 26\n        \n        for ch in word1:\n            freq1[ord(ch) - 97] += 1\n        \n        for ch in word2:\n            freq2[ord(ch) - 97] += 1\n        \n        diff_count = 0\n        for i in range(26):\n            diff = abs(freq1[i] - freq2[i])\n            if diff > 3:\n                return False\n            diff_count += diff\n        \n        return diff_count <= 3\n```", "extracted_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        freq1 = [0] * 26\n        freq2 = [0] * 26\n        \n        for ch in word1:\n            freq1[ord(ch) - 97] += 1\n        \n        for ch in word2:\n            freq2[ord(ch) - 97] += 1\n        \n        diff_count = 0\n        for i in range(26):\n            diff = abs(freq1[i] - freq2[i])\n            if diff > 3:\n                return False\n            diff_count += diff\n        \n        return diff_count <= 3\n", "difficulty": 1.0}
{"task_id": "LeetCode/2053", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = []\n        count_dict = {}\n        \n        for string in arr:\n            if string not in distinct_strings:\n                distinct_strings.append(string)\n                count_dict[string] = 1\n            else:\n                count_dict[string] += 1\n        \n        for string in distinct_strings:\n            if count_dict[string] == 1:\n                k -= 1\n                if k == 0:\n                    return string\n        \n        return \"\"\n```", "extracted_code": "\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = []\n        count_dict = {}\n        \n        for string in arr:\n            if string not in distinct_strings:\n                distinct_strings.append(string)\n                count_dict[string] = 1\n            else:\n                count_dict[string] += 1\n        \n        for string in distinct_strings:\n            if count_dict[string] == 1:\n                k -= 1\n                if k == 0:\n                    return string\n        \n        return \"\"\n", "difficulty": 1.0}
{"task_id": "LeetCode/2032", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        result = []\n        for num in set(nums1):\n            if num in nums2 or num in nums3:\n                result.append(num)\n                \n        for num in set(nums2):\n            if num in nums1 and num not in result:\n                result.append(num)\n                \n        for num in set(nums3):\n            if num in nums1 and num not in result:\n                result.append(num)\n                \n        return result\n```", "extracted_code": "\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        result = []\n        for num in set(nums1):\n            if num in nums2 or num in nums3:\n                result.append(num)\n                \n        for num in set(nums2):\n            if num in nums1 and num not in result:\n                result.append(num)\n                \n        for num in set(nums3):\n            if num in nums1 and num not in result:\n                result.append(num)\n                \n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/2027", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i] == 'X':\n                count += 1\n                i += 3\n            else:\n                i += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i] == 'X':\n                count += 1\n                i += 3\n            else:\n                i += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2006", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1995", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        \n        for a in range(n-3):\n            for b in range(a+1, n-2):\n                for c in range(b+1, n-1):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        \n        for a in range(n-3):\n            for b in range(a+1, n-2):\n                for c in range(b+1, n-1):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        \n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1974", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        current = 'a'\n        time = 0\n        for char in word:\n            diff = abs(ord(char) - ord(current))\n            time += min(diff, 26 - diff) + 1\n            current = char\n        return time\n```", "extracted_code": "\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        current = 'a'\n        time = 0\n        for char in word:\n            diff = abs(ord(char) - ord(current))\n            time += min(diff, 26 - diff) + 1\n            current = char\n        return time\n", "difficulty": 1.0}
{"task_id": "LeetCode/1971", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        return self.dfs(graph, source, destination, visited)\n    \n    def dfs(self, graph, curr, destination, visited):\n        if curr == destination:\n            return True\n        \n        visited.add(curr)\n        \n        for neighbor in graph[curr]:\n            if neighbor not in visited:\n                if self.dfs(graph, neighbor, destination, visited):\n                    return True\n        \n        return False\n```", "extracted_code": "\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        return self.dfs(graph, source, destination, visited)\n    \n    def dfs(self, graph, curr, destination, visited):\n        if curr == destination:\n            return True\n        \n        visited.add(curr)\n        \n        for neighbor in graph[curr]:\n            if neighbor not in visited:\n                if self.dfs(graph, neighbor, destination, visited):\n                    return True\n        \n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1925", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c_square = a**2 + b**2\n                c = int(c_square**0.5)\n                if c <= n and c**2 == c_square:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c_square = a**2 + b**2\n                c = int(c_square**0.5)\n                if c <= n and c**2 == c_square:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1920", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        ans = [0] * len(nums)\n        for i in range(len(nums)):\n            ans[i] = nums[nums[i]]\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        ans = [0] * len(nums)\n        for i in range(len(nums)):\n            ans[i] = nums[nums[i]]\n        return ans\n", "difficulty": 1.0}
{"task_id": "LeetCode/1886", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        n = len(mat)\n        \n        # Check if the matrices are already equal\n        if mat == target:\n            return True\n        \n        # Rotate the matrix 90 degrees clockwise and check if it is equal to the target\n        for _ in range(3):\n            mat = [[mat[j][i] for j in range(n-1, -1, -1)] for i in range(n)]\n            if mat == target:\n                return True\n        \n        return False\n```", "extracted_code": "\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        n = len(mat)\n        \n        # Check if the matrices are already equal\n        if mat == target:\n            return True\n        \n        # Rotate the matrix 90 degrees clockwise and check if it is equal to the target\n        for _ in range(3):\n            mat = [[mat[j][i] for j in range(n-1, -1, -1)] for i in range(n)]\n            if mat == target:\n                return True\n        \n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1880", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def getNumericalValue(word):\n            numericalValue = ''\n            for letter in word:\n                numericalValue += str(ord(letter) - ord('a'))\n            return int(numericalValue)\n        \n        return getNumericalValue(firstWord) + getNumericalValue(secondWord) == getNumericalValue(targetWord)\n```", "extracted_code": "\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def getNumericalValue(word):\n            numericalValue = ''\n            for letter in word:\n                numericalValue += str(ord(letter) - ord('a'))\n            return int(numericalValue)\n        \n        return getNumericalValue(firstWord) + getNumericalValue(secondWord) == getNumericalValue(targetWord)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1854", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        birth_years = [log[0] for log in logs]\n        death_years = [log[1] for log in logs]\n        population_years = {}\n        \n        for year in range(1950, 2051):\n            population_years[year] = 0\n            \n        for i in range(len(logs)):\n            birth_year = logs[i][0]\n            death_year = logs[i][1]\n            for year in range(birth_year, death_year):\n                population_years[year] += 1\n        \n        max_population = max(population_years.values())\n        \n        for year, population in population_years.items():\n            if population == max_population:\n                return year\n```", "extracted_code": "\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        birth_years = [log[0] for log in logs]\n        death_years = [log[1] for log in logs]\n        population_years = {}\n        \n        for year in range(1950, 2051):\n            population_years[year] = 0\n            \n        for i in range(len(logs)):\n            birth_year = logs[i][0]\n            death_year = logs[i][1]\n            for year in range(birth_year, death_year):\n                population_years[year] += 1\n        \n        max_population = max(population_years.values())\n        \n        for year, population in population_years.items():\n            if population == max_population:\n                return year\n", "difficulty": 1.0}
{"task_id": "LeetCode/1837", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        sum_digits = 0\n        while n > 0:\n            sum_digits += n % k\n            n //= k\n        return sum_digits\n```", "extracted_code": "\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        sum_digits = 0\n        while n > 0:\n            sum_digits += n % k\n            n //= k\n        return sum_digits\n", "difficulty": 1.0}
{"task_id": "LeetCode/1800", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = nums[0]\n        current_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                current_sum += nums[i]\n            else:\n                current_sum = nums[i]\n            \n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = nums[0]\n        current_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                current_sum += nums[i]\n            else:\n                current_sum = nums[i]\n            \n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum\n", "difficulty": 1.0}
{"task_id": "LeetCode/1768", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = \"\"\n        len1 = len(word1)\n        len2 = len(word2)\n        i = 0\n        while i < len1 or i < len2:\n            if i < len1:\n                merged += word1[i]\n            if i < len2:\n                merged += word2[i]\n            i += 1\n        return merged + word1[i:] + word2[i:]\n```", "extracted_code": "\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = \"\"\n        len1 = len(word1)\n        len2 = len(word2)\n        i = 0\n        while i < len1 or i < len2:\n            if i < len1:\n                merged += word1[i]\n            if i < len2:\n                merged += word2[i]\n            i += 1\n        return merged + word1[i:] + word2[i:]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1758", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        count = 0\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n        return (count + 1) // 2\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        count = 0\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n        return (count + 1) // 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/1748", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n        \n        unique_sum = 0\n        for num, freq in count.items():\n            if freq == 1:\n                unique_sum += num\n                \n        return unique_sum\n```", "extracted_code": "\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n        \n        unique_sum = 0\n        for num, freq in count.items():\n            if freq == 1:\n                unique_sum += num\n                \n        return unique_sum\n", "difficulty": 1.0}
{"task_id": "LeetCode/1656", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.stream = [None] * n\n        self.ptr = 0\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        idKey -= 1\n        self.stream[idKey] = value\n        if idKey == self.ptr:\n            chunk = []\n            while self.ptr < len(self.stream) and self.stream[self.ptr] is not None:\n                chunk.append(self.stream[self.ptr])\n                self.ptr += 1\n            return chunk\n        else:\n            return []\n```\nThe `OrderedStream` class has an array `stream` of size `n` to store the values. The `ptr` variable keeps track of the index of the next value to be returned. \n\nThe `__init__` method initializes the array `stream` with `None` values and sets `ptr` to 0.\n\nThe `insert` method takes an `idKey` and a `value` as input. It subtracts 1 from `idKey` to convert it to a zero-based index. It then inserts the `value` at the corresponding index in the `stream` array. If the inserted `idKey` is equal to `ptr`, it means that the inserted value is the next one in order. In this case, it creates a new `chunk` list and adds all the values from `ptr` onwards in the `stream` array to the `chunk` list, updating `ptr` to the next empty index. If the inserted `idKey` is not equal to `ptr`, it means that the inserted value is not the next one in order, so it returns an empty list.\n\nThe time complexity of the `insert` method is O(n) in the worst case, where n is the size of the `stream` array.", "extracted_code": "\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.stream = [None] * n\n        self.ptr = 0\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        idKey -= 1\n        self.stream[idKey] = value\n        if idKey == self.ptr:\n            chunk = []\n            while self.ptr < len(self.stream) and self.stream[self.ptr] is not None:\n                chunk.append(self.stream[self.ptr])\n                self.ptr += 1\n            return chunk\n        else:\n            return []\n", "difficulty": 1.0}
{"task_id": "LeetCode/1640", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        # Create a dictionary to store the first element of each piece as key and the piece itself as value\n        piece_dict = {piece[0]: piece for piece in pieces}\n        \n        # Initialize an empty result list\n        result = []\n        \n        # Iterate through each element in arr\n        for num in arr:\n            # If the current element is in the dictionary, add the corresponding piece to the result list\n            if num in piece_dict:\n                result += piece_dict[num]\n            # If the current element is not in the dictionary, return False\n            else:\n                return False\n        \n        # If the result list is equal to arr, return True; otherwise, return False\n        return result == arr\n```", "extracted_code": "\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        # Create a dictionary to store the first element of each piece as key and the piece itself as value\n        piece_dict = {piece[0]: piece for piece in pieces}\n        \n        # Initialize an empty result list\n        result = []\n        \n        # Iterate through each element in arr\n        for num in arr:\n            # If the current element is in the dictionary, add the corresponding piece to the result list\n            if num in piece_dict:\n                result += piece_dict[num]\n            # If the current element is not in the dictionary, return False\n            else:\n                return False\n        \n        # If the result list is equal to arr, return True; otherwise, return False\n        return result == arr\n", "difficulty": 1.0}
{"task_id": "LeetCode/1619", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        remove = int(n * 0.05)\n        trimmed_arr = arr[remove:n-remove]\n        return sum(trimmed_arr) / len(trimmed_arr)\n```", "extracted_code": "\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        remove = int(n * 0.05)\n        trimmed_arr = arr[remove:n-remove]\n        return sum(trimmed_arr) / len(trimmed_arr)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1614", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in s:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        return max_depth\n```", "extracted_code": "\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in s:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        return max_depth\n", "difficulty": 1.0}
{"task_id": "LeetCode/1582", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        row_count = [0] * m\n        col_count = [0] * n\n        special_count = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    row_count[i] += 1\n                    col_count[j] += 1\n        \n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1 and row_count[i] == 1 and col_count[j] == 1:\n                    special_count += 1\n        \n        return special_count\n```", "extracted_code": "\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        row_count = [0] * m\n        col_count = [0] * n\n        special_count = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    row_count[i] += 1\n                    col_count[j] += 1\n        \n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1 and row_count[i] == 1 and col_count[j] == 1:\n                    special_count += 1\n        \n        return special_count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1566", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        n = len(arr)\n        \n        for i in range(n - m * k + 1):\n            pattern = arr[i:i+m]\n            count = 1\n            \n            for j in range(i+m, n, m):\n                if arr[j:j+m] == pattern:\n                    count += 1\n                else:\n                    break\n                \n            if count >= k:\n                return True\n        \n        return False\n```", "extracted_code": "\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        n = len(arr)\n        \n        for i in range(n - m * k + 1):\n            pattern = arr[i:i+m]\n            count = 1\n            \n            for j in range(i+m, n, m):\n                if arr[j:j+m] == pattern:\n                    count += 1\n                else:\n                    break\n                \n            if count >= k:\n                return True\n        \n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1556", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        num_str = str(n)\n        if len(num_str) <= 3:\n            return num_str\n        else:\n            result = \"\"\n            for i in range(len(num_str)-1, -1, -1):\n                result = num_str[i] + result\n                if i != 0 and (len(num_str)-i) % 3 == 0:\n                    result = \".\" + result\n            return result\n```", "extracted_code": "\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        num_str = str(n)\n        if len(num_str) <= 3:\n            return num_str\n        else:\n            result = \"\"\n            for i in range(len(num_str)-1, -1, -1):\n                result = num_str[i] + result\n                if i != 0 and (len(num_str)-i) % 3 == 0:\n                    result = \".\" + result\n            return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1534", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        count = 0\n        n = len(arr)\n        for i in range(n-2):\n            for j in range(i+1, n-1):\n                for k in range(j+1, n):\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        count = 0\n        n = len(arr)\n        for i in range(n-2):\n            for j in range(i+1, n-1):\n                for k in range(j+1, n):\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1496", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        visited = set()\n        x, y = 0, 0\n        visited.add((x, y))\n        \n        for move in path:\n            if move == 'N':\n                y += 1\n            elif move == 'S':\n                y -= 1\n            elif move == 'E':\n                x += 1\n            elif move == 'W':\n                x -= 1\n            \n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        \n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        visited = set()\n        x, y = 0, 0\n        visited.add((x, y))\n        \n        for move in path:\n            if move == 'N':\n                y += 1\n            elif move == 'S':\n                y -= 1\n            elif move == 'E':\n                x += 1\n            elif move == 'W':\n                x -= 1\n            \n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        \n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1486", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n```", "extracted_code": "\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1464", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums.sort()\n        return (nums[-1] - 1) * (nums[-2] - 1)\n```", "extracted_code": "\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums.sort()\n        return (nums[-1] - 1) * (nums[-2] - 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1431", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candies = max(candies)\n        result = []\n        for i in range(len(candies)):\n            if candies[i] + extraCandies >= max_candies:\n                result.append(True)\n            else:\n                result.append(False)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candies = max(candies)\n        result = []\n        for i in range(len(candies)):\n            if candies[i] + extraCandies >= max_candies:\n                result.append(True)\n            else:\n                result.append(False)\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1422", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        score = 0\n        max_score = 0\n        \n        # Count the number of ones in the string\n        ones_count = s.count('1')\n        \n        # Iterate through the string (except for the last character)\n        for i in range(len(s)-1):\n            # If the character is '0', increment the score\n            if s[i] == '0':\n                score += 1\n            # If the character is '1', decrement the ones count\n            else:\n                ones_count -= 1\n            \n            # Update the maximum score\n            max_score = max(max_score, score + ones_count)\n        \n        return max_score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        score = 0\n        max_score = 0\n        \n        # Count the number of ones in the string\n        ones_count = s.count('1')\n        \n        # Iterate through the string (except for the last character)\n        for i in range(len(s)-1):\n            # If the character is '0', increment the score\n            if s[i] == '0':\n                score += 1\n            # If the character is '1', decrement the ones count\n            else:\n                ones_count -= 1\n            \n            # Update the maximum score\n            max_score = max(max_score, score + ones_count)\n        \n        return max_score\n", "difficulty": 1.0}
{"task_id": "LeetCode/1408", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        substrings = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and words[i] in words[j]:\n                    substrings.append(words[i])\n                    break\n        return substrings\n```", "extracted_code": "\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        substrings = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and words[i] in words[j]:\n                    substrings.append(words[i])\n                    break\n        return substrings\n", "difficulty": 1.0}
{"task_id": "LeetCode/1399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        digit_sum_counts = {}\n        max_count = 0\n        \n        for i in range(1, n+1):\n            digit_sum = sum(int(digit) for digit in str(i))\n            digit_sum_counts[digit_sum] = digit_sum_counts.get(digit_sum, 0) + 1\n            max_count = max(max_count, digit_sum_counts[digit_sum])\n        \n        return sum(count == max_count for count in digit_sum_counts.values())\n```", "extracted_code": "\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        digit_sum_counts = {}\n        max_count = 0\n        \n        for i in range(1, n+1):\n            digit_sum = sum(int(digit) for digit in str(i))\n            digit_sum_counts[digit_sum] = digit_sum_counts.get(digit_sum, 0) + 1\n            max_count = max(max_count, digit_sum_counts[digit_sum])\n        \n        return sum(count == max_count for count in digit_sum_counts.values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/1360", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        date_format = \"%Y-%m-%d\"\n        d1 = datetime.strptime(date1, date_format)\n        d2 = datetime.strptime(date2, date_format)\n        delta = d2 - d1\n        return abs(delta.days)\n```", "extracted_code": "\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        date_format = \"%Y-%m-%d\"\n        d1 = datetime.strptime(date1, date_format)\n        d2 = datetime.strptime(date2, date_format)\n        delta = d2 - d1\n        return abs(delta.days)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1323", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num_str = str(num)\n        for i in range(len(num_str)):\n            if num_str[i] == '6':\n                return int(num_str[:i] + '9' + num_str[i+1:])\n        return num\n```", "extracted_code": "\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num_str = str(num)\n        for i in range(len(num_str)):\n            if num_str[i] == '6':\n                return int(num_str[:i] + '9' + num_str[i+1:])\n        return num\n", "difficulty": 1.0}
{"task_id": "LeetCode/1304", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        result = []\n        for i in range(1, n//2 + 1):\n            result.append(i)\n            result.append(-i)\n        if n % 2 != 0:\n            result.append(0)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        result = []\n        for i in range(1, n//2 + 1):\n            result.append(i)\n            result.append(-i)\n        if n % 2 != 0:\n            result.append(0)\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1266", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time = 0\n        for i in range(1, len(points)):\n            dx = abs(points[i][0] - points[i-1][0])\n            dy = abs(points[i][1] - points[i-1][1])\n            time += max(dx, dy)\n        return time\n```", "extracted_code": "\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time = 0\n        for i in range(1, len(points)):\n            dx = abs(points[i][0] - points[i-1][0])\n            dy = abs(points[i][1] - points[i-1][1])\n            time += max(dx, dy)\n        return time\n", "difficulty": 1.0}
{"task_id": "LeetCode/1252", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        rows = [0] * m\n        cols = [0] * n\n        for idx in indices:\n            rows[idx[0]] += 1\n            cols[idx[1]] += 1\n        odd_count = 0\n        for i in range(m):\n            for j in range(n):\n                if (rows[i] + cols[j]) % 2 != 0:\n                    odd_count += 1\n        return odd_count\n```", "extracted_code": "\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        rows = [0] * m\n        cols = [0] * n\n        for idx in indices:\n            rows[idx[0]] += 1\n            cols[idx[1]] += 1\n        odd_count = 0\n        for i in range(m):\n            for j in range(n):\n                if (rows[i] + cols[j]) % 2 != 0:\n                    odd_count += 1\n        return odd_count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1207", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        count = {}\n        for num in arr:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        return len(count.values()) == len(set(count.values()))\n```", "extracted_code": "\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        count = {}\n        for num in arr:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        return len(count.values()) == len(set(count.values()))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1200", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()  # Sort the array in ascending order\n        min_diff = float('inf')  # Initialize the minimum difference variable to infinity\n        pairs = []  # Initialize an empty list to store the pairs with minimum difference\n        \n        # Iterate through the sorted array and find the minimum difference\n        for i in range(len(arr) - 1):\n            diff = arr[i+1] - arr[i]\n            \n            if diff < min_diff:  # If the current difference is smaller than the minimum difference\n                min_diff = diff  # Update the minimum difference\n                pairs = [[arr[i], arr[i+1]]]  # Create a new list with the current pair\n            elif diff == min_diff:  # If the current difference is equal to the minimum difference\n                pairs.append([arr[i], arr[i+1]])  # Add the current pair to the list of pairs\n        \n        return pairs  # Return the list of pairs with the minimum difference\n```", "extracted_code": "\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()  # Sort the array in ascending order\n        min_diff = float('inf')  # Initialize the minimum difference variable to infinity\n        pairs = []  # Initialize an empty list to store the pairs with minimum difference\n        \n        # Iterate through the sorted array and find the minimum difference\n        for i in range(len(arr) - 1):\n            diff = arr[i+1] - arr[i]\n            \n            if diff < min_diff:  # If the current difference is smaller than the minimum difference\n                min_diff = diff  # Update the minimum difference\n                pairs = [[arr[i], arr[i+1]]]  # Create a new list with the current pair\n            elif diff == min_diff:  # If the current difference is equal to the minimum difference\n                pairs.append([arr[i], arr[i+1]])  # Add the current pair to the list of pairs\n        \n        return pairs  # Return the list of pairs with the minimum difference\n", "difficulty": 1.0}
{"task_id": "LeetCode/1175", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        # Function to check if a number is prime\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        # Count the number of prime numbers from 1 to n\n        prime_count = sum(1 for i in range(1, n + 1) if is_prime(i))\n        \n        # Count the number of non-prime numbers from 1 to n\n        non_prime_count = n - prime_count\n        \n        # Calculate the factorial of prime_count and non_prime_count\n        prime_factorial = 1\n        non_prime_factorial = 1\n        for i in range(1, prime_count + 1):\n            prime_factorial *= i\n        for i in range(1, non_prime_count + 1):\n            non_prime_factorial *= i\n        \n        # Calculate the number of permutations with prime numbers at prime indices\n        result = (prime_factorial * non_prime_factorial) % (10**9 + 7)\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        # Function to check if a number is prime\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        # Count the number of prime numbers from 1 to n\n        prime_count = sum(1 for i in range(1, n + 1) if is_prime(i))\n        \n        # Count the number of non-prime numbers from 1 to n\n        non_prime_count = n - prime_count\n        \n        # Calculate the factorial of prime_count and non_prime_count\n        prime_factorial = 1\n        non_prime_factorial = 1\n        for i in range(1, prime_count + 1):\n            prime_factorial *= i\n        for i in range(1, non_prime_count + 1):\n            non_prime_factorial *= i\n        \n        # Calculate the number of permutations with prime numbers at prime indices\n        result = (prime_factorial * non_prime_factorial) % (10**9 + 7)\n        \n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1128", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        count = 0\n        pairs = {}\n        for domino in dominoes:\n            domino.sort()\n            pair = tuple(domino)\n            count += pairs.get(pair, 0)\n            pairs[pair] = pairs.get(pair, 0) + 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        count = 0\n        pairs = {}\n        for domino in dominoes:\n            domino.sort()\n            pair = tuple(domino)\n            count += pairs.get(pair, 0)\n            pairs[pair] = pairs.get(pair, 0) + 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1108", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n```", "extracted_code": "\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n", "difficulty": 1.0}
{"task_id": "LeetCode/1103", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        ans = [0] * num_people\n        i = 0\n        while candies > 0:\n            ans[i % num_people] += min(candies, i + 1)\n            candies -= i + 1\n            i += 1\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        ans = [0] * num_people\n        i = 0\n        while candies > 0:\n            ans[i % num_people] += min(candies, i + 1)\n            candies -= i + 1\n            i += 1\n        return ans\n", "difficulty": 1.0}
{"task_id": "LeetCode/1071", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b)\n        \n        if str1 + str2 != str2 + str1:\n            return \"\"\n        \n        gcd_length = gcd(len(str1), len(str2))\n        return str1[:gcd_length]\n```", "extracted_code": "\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b)\n        \n        if str1 + str2 != str2 + str1:\n            return \"\"\n        \n        gcd_length = gcd(len(str1), len(str2))\n        return str1[:gcd_length]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1025", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        return n % 2 == 0\n```", "extracted_code": "\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        return n % 2 == 0\n", "difficulty": 1.0}
{"task_id": "LeetCode/1009", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        if n == 0:\n            return 1\n        num_bits = n.bit_length()\n        mask = (1 << num_bits) - 1\n        return n ^ mask\n```", "extracted_code": "\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        if n == 0:\n            return 1\n        num_bits = n.bit_length()\n        mask = (1 << num_bits) - 1\n        return n ^ mask\n", "difficulty": 1.0}
{"task_id": "LeetCode/993", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        def findDepthAndParent(node, value, depth, parent):\n            if node is None:\n                return None\n            \n            if node.val == value:\n                return (depth, parent)\n            \n            left_result = findDepthAndParent(node.left, value, depth + 1, node)\n            if left_result is not None:\n                return left_result\n            \n            right_result = findDepthAndParent(node.right, value, depth + 1, node)\n            if right_result is not None:\n                return right_result\n            \n            return None\n        \n        x_result = findDepthAndParent(root, x, 0, None)\n        y_result = findDepthAndParent(root, y, 0, None)\n        \n        if x_result is None or y_result is None:\n            return False\n        \n        x_depth, x_parent = x_result\n        y_depth, y_parent = y_result\n        \n        return x_depth == y_depth and x_parent != y_parent\n```", "extracted_code": "\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        def findDepthAndParent(node, value, depth, parent):\n            if node is None:\n                return None\n            \n            if node.val == value:\n                return (depth, parent)\n            \n            left_result = findDepthAndParent(node.left, value, depth + 1, node)\n            if left_result is not None:\n                return left_result\n            \n            right_result = findDepthAndParent(node.right, value, depth + 1, node)\n            if right_result is not None:\n                return right_result\n            \n            return None\n        \n        x_result = findDepthAndParent(root, x, 0, None)\n        y_result = findDepthAndParent(root, y, 0, None)\n        \n        if x_result is None or y_result is None:\n            return False\n        \n        x_depth, x_parent = x_result\n        y_depth, y_parent = y_result\n        \n        return x_depth == y_depth and x_parent != y_parent\n", "difficulty": 1.0}
{"task_id": "LeetCode/965", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        \n        return self.helper(root, root.val)\n    \n    def helper(self, node: Optional[TreeNode], value: int) -> bool:\n        if not node:\n            return True\n        \n        if node.val != value:\n            return False\n        \n        return self.helper(node.left, value) and self.helper(node.right, value)\n```", "extracted_code": "\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        \n        return self.helper(root, root.val)\n    \n    def helper(self, node: Optional[TreeNode], value: int) -> bool:\n        if not node:\n            return True\n        \n        if node.val != value:\n            return False\n        \n        return self.helper(node.left, value) and self.helper(node.right, value)\n", "difficulty": 1.0}
{"task_id": "LeetCode/953", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        def compare(word1, word2, order):\n            i = 0\n            while i < len(word1) and i < len(word2):\n                if order.index(word1[i]) < order.index(word2[i]):\n                    return -1\n                elif order.index(word1[i]) > order.index(word2[i]):\n                    return 1\n                i += 1\n            if len(word1) < len(word2):\n                return -1\n            elif len(word1) > len(word2):\n                return 1\n            else:\n                return 0\n        \n        for i in range(1, len(words)):\n            if compare(words[i-1], words[i], order) > 0:\n                return False\n        \n        return True\n```", "extracted_code": "\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        def compare(word1, word2, order):\n            i = 0\n            while i < len(word1) and i < len(word2):\n                if order.index(word1[i]) < order.index(word2[i]):\n                    return -1\n                elif order.index(word1[i]) > order.index(word2[i]):\n                    return 1\n                i += 1\n            if len(word1) < len(word2):\n                return -1\n            elif len(word1) > len(word2):\n                return 1\n            else:\n                return 0\n        \n        for i in range(1, len(words)):\n            if compare(words[i-1], words[i], order) > 0:\n                return False\n        \n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/944", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        count = 0\n        for col in zip(*strs):\n            if list(col) != sorted(col):\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        count = 0\n        for col in zip(*strs):\n            if list(col) != sorted(col):\n                count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/933", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests and self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)\n```", "extracted_code": "\nclass RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests and self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)\n", "difficulty": 1.0}
{"task_id": "LeetCode/914", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        # Count the frequencies of each number in the deck\n        freq = {}\n        for num in deck:\n            freq[num] = freq.get(num, 0) + 1\n        \n        # Find the greatest common divisor of all frequencies\n        gcd = freq[deck[0]]\n        for val in freq.values():\n            gcd = self.findGCD(gcd, val)\n        \n        # If the gcd is greater than or equal to 2, return True\n        return gcd >= 2\n    \n    def findGCD(self, a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n```", "extracted_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        # Count the frequencies of each number in the deck\n        freq = {}\n        for num in deck:\n            freq[num] = freq.get(num, 0) + 1\n        \n        # Find the greatest common divisor of all frequencies\n        gcd = freq[deck[0]]\n        for val in freq.values():\n            gcd = self.findGCD(gcd, val)\n        \n        # If the gcd is greater than or equal to 2, return True\n        return gcd >= 2\n    \n    def findGCD(self, a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n", "difficulty": 1.0}
{"task_id": "LeetCode/892", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        surface_area = 0\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    # Calculate the contribution of the top and bottom faces\n                    surface_area += 2\n                    \n                    # Calculate the contribution of the four side faces\n                    if i == 0:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i-1][j])\n                    \n                    if i == n-1:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i+1][j])\n                    \n                    if j == 0:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i][j-1])\n                    \n                    if j == n-1:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i][j+1])\n        \n        return surface_area\n```", "extracted_code": "\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        surface_area = 0\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    # Calculate the contribution of the top and bottom faces\n                    surface_area += 2\n                    \n                    # Calculate the contribution of the four side faces\n                    if i == 0:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i-1][j])\n                    \n                    if i == n-1:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i+1][j])\n                    \n                    if j == 0:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i][j-1])\n                    \n                    if j == n-1:\n                        surface_area += grid[i][j]\n                    else:\n                        surface_area += max(0, grid[i][j] - grid[i][j+1])\n        \n        return surface_area\n", "difficulty": 1.0}
{"task_id": "LeetCode/888", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        # Calculate the sum of candies for Alice and Bob\n        sum_alice = sum(aliceSizes)\n        sum_bob = sum(bobSizes)\n        \n        # Calculate the difference in total candies\n        diff = (sum_alice - sum_bob) // 2\n        \n        # Create a set of Bob's candy sizes\n        bob_set = set(bobSizes)\n        \n        # Iterate through Alice's candy sizes\n        for candy in aliceSizes:\n            # Calculate the target size for Bob's candy\n            target = candy - diff\n            \n            # Check if the target size is in Bob's set\n            if target in bob_set:\n                # Return the candy sizes to exchange\n                return [candy, target]\n```", "extracted_code": "\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        # Calculate the sum of candies for Alice and Bob\n        sum_alice = sum(aliceSizes)\n        sum_bob = sum(bobSizes)\n        \n        # Calculate the difference in total candies\n        diff = (sum_alice - sum_bob) // 2\n        \n        # Create a set of Bob's candy sizes\n        bob_set = set(bobSizes)\n        \n        # Iterate through Alice's candy sizes\n        for candy in aliceSizes:\n            # Calculate the target size for Bob's candy\n            target = candy - diff\n            \n            # Check if the target size is in Bob's set\n            if target in bob_set:\n                # Return the candy sizes to exchange\n                return [candy, target]\n", "difficulty": 1.0}
{"task_id": "LeetCode/867", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n```", "extracted_code": "\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/844", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        def process_string(string):\n            stack = []\n            for char in string:\n                if char == '#':\n                    if stack:\n                        stack.pop()\n                else:\n                    stack.append(char)\n            return stack\n        \n        return process_string(s) == process_string(t)\n```", "extracted_code": "\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        def process_string(string):\n            stack = []\n            for char in string:\n                if char == '#':\n                    if stack:\n                        stack.pop()\n                else:\n                    stack.append(char)\n            return stack\n        \n        return process_string(s) == process_string(t)\n", "difficulty": 1.0}
{"task_id": "LeetCode/830", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        # Initialize variables\n        result = []\n        start = 0\n        n = len(s)\n        \n        # Iterate through the string\n        for i in range(1, n):\n            # Check if the current character is different from the previous character\n            if s[i] != s[i-1]:\n                # Check if the group is large\n                if i - start >= 3:\n                    result.append([start, i-1])\n                # Update the start index\n                start = i\n\n        # Check if the last group is large\n        if n - start >= 3:\n            result.append([start, n-1])\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        # Initialize variables\n        result = []\n        start = 0\n        n = len(s)\n        \n        # Iterate through the string\n        for i in range(1, n):\n            # Check if the current character is different from the previous character\n            if s[i] != s[i-1]:\n                # Check if the group is large\n                if i - start >= 3:\n                    result.append([start, i-1])\n                # Update the start index\n                start = i\n\n        # Check if the last group is large\n        if n - start >= 3:\n            result.append([start, n-1])\n        \n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/804", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse_code = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\n                      \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n        \n        transformations = set()\n        \n        for word in words:\n            transformation = \"\"\n            for char in word:\n                transformation += morse_code[ord(char) - ord('a')]\n                \n            transformations.add(transformation)\n            \n        return len(transformations)\n```", "extracted_code": "\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse_code = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\n                      \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n        \n        transformations = set()\n        \n        for word in words:\n            transformation = \"\"\n            for char in word:\n                transformation += morse_code[ord(char) - ord('a')]\n                \n            transformations.add(transformation)\n            \n        return len(transformations)\n", "difficulty": 1.0}
{"task_id": "LeetCode/762", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        count = 0\n        for num in range(left, right + 1):\n            set_bits = bin(num).count('1')\n            if is_prime(set_bits):\n                count += 1\n        \n        return count\n```", "extracted_code": "\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        count = 0\n        for num in range(left, right + 1):\n            set_bits = bin(num).count('1')\n            if is_prime(set_bits):\n                count += 1\n        \n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/728", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        def is_self_dividing(num):\n            digits = [int(d) for d in str(num)]\n            for digit in digits:\n                if digit == 0 or num % digit != 0:\n                    return False\n            return True\n        \n        self_dividing_nums = []\n        for num in range(left, right+1):\n            if is_self_dividing(num):\n                self_dividing_nums.append(num)\n        \n        return self_dividing_nums\n```", "extracted_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        def is_self_dividing(num):\n            digits = [int(d) for d in str(num)]\n            for digit in digits:\n                if digit == 0 or num % digit != 0:\n                    return False\n            return True\n        \n        self_dividing_nums = []\n        for num in range(left, right+1):\n            if is_self_dividing(num):\n                self_dividing_nums.append(num)\n        \n        return self_dividing_nums\n", "difficulty": 1.0}
{"task_id": "LeetCode/706", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass MyHashMap:\n\n    def __init__(self):\n        self.hashmap = {}\n\n    def put(self, key: int, value: int) -> None:\n        self.hashmap[key] = value\n\n    def get(self, key: int) -> int:\n        return self.hashmap.get(key, -1)\n\n    def remove(self, key: int) -> None:\n        if key in self.hashmap:\n            del self.hashmap[key]\n```", "extracted_code": "\nclass MyHashMap:\n\n    def __init__(self):\n        self.hashmap = {}\n\n    def put(self, key: int, value: int) -> None:\n        self.hashmap[key] = value\n\n    def get(self, key: int) -> int:\n        return self.hashmap.get(key, -1)\n\n    def remove(self, key: int) -> None:\n        if key in self.hashmap:\n            del self.hashmap[key]\n", "difficulty": 1.0}
{"task_id": "LeetCode/704", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1\n```", "extracted_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/682", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        for op in operations:\n            if op == 'C':\n                record.pop()\n            elif op == 'D':\n                record.append(2 * record[-1])\n            elif op == '+':\n                record.append(record[-1] + record[-2])\n            else:\n                record.append(int(op))\n        return sum(record)\n```", "extracted_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        for op in operations:\n            if op == 'C':\n                record.pop()\n            elif op == 'D':\n                record.append(2 * record[-1])\n            elif op == '+':\n                record.append(record[-1] + record[-2])\n            else:\n                record.append(int(op))\n        return sum(record)\n", "difficulty": 1.0}
{"task_id": "LeetCode/680", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_palindrome(left: int, right: int) -> bool:\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            if s[left] != s[right]:\n                return is_palindrome(left + 1, right) or is_palindrome(left, right - 1)\n            left += 1\n            right -= 1\n        \n        return True\n```", "extracted_code": "\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_palindrome(left: int, right: int) -> bool:\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            if s[left] != s[right]:\n                return is_palindrome(left + 1, right) or is_palindrome(left, right - 1)\n            left += 1\n            right -= 1\n        \n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/674", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n        max_length = 1\n        curr_length = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                curr_length += 1\n                max_length = max(max_length, curr_length)\n            else:\n                curr_length = 1\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n        max_length = 1\n        curr_length = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                curr_length += 1\n                max_length = max(max_length, curr_length)\n            else:\n                curr_length = 1\n        return max_length\n", "difficulty": 1.0}
{"task_id": "LeetCode/671", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return float('inf')\n            if node.val > root.val:\n                return node.val\n            left_min = dfs(node.left)\n            right_min = dfs(node.right)\n            return min(left_min, right_min)\n        \n        second_min = dfs(root)\n        return second_min if second_min != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return float('inf')\n            if node.val > root.val:\n                return node.val\n            left_min = dfs(node.left)\n            right_min = dfs(node.right)\n            return min(left_min, right_min)\n        \n        second_min = dfs(root)\n        return second_min if second_min != float('inf') else -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/645", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        count = [0] * (n + 1)\n        \n        for num in nums:\n            count[num] += 1\n        \n        duplicate = 0\n        missing = 0\n        for i in range(1, n+1):\n            if count[i] == 2:\n                duplicate = i\n            elif count[i] == 0:\n                missing = i\n        \n        return [duplicate, missing]\n```", "extracted_code": "\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        count = [0] * (n + 1)\n        \n        for num in nums:\n            count[num] += 1\n        \n        duplicate = 0\n        missing = 0\n        for i in range(1, n+1):\n            if count[i] == 2:\n                duplicate = i\n            elif count[i] == 0:\n                missing = i\n        \n        return [duplicate, missing]\n", "difficulty": 1.0}
{"task_id": "LeetCode/617", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n        \n        merged = TreeNode(root1.val + root2.val)\n        merged.left = self.mergeTrees(root1.left, root2.left)\n        merged.right = self.mergeTrees(root1.right, root2.right)\n        \n        return merged\n```", "extracted_code": "\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n        \n        merged = TreeNode(root1.val + root2.val)\n        merged.left = self.mergeTrees(root1.left, root2.left)\n        merged.right = self.mergeTrees(root1.right, root2.right)\n        \n        return merged\n", "difficulty": 1.0}
{"task_id": "LeetCode/599", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        common = set(list1) & set(list2)\n        min_index_sum = float('inf')\n        result = []\n        \n        for s in common:\n            index_sum = list1.index(s) + list2.index(s)\n            if index_sum < min_index_sum:\n                min_index_sum = index_sum\n                result = [s]\n            elif index_sum == min_index_sum:\n                result.append(s)\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        common = set(list1) & set(list2)\n        min_index_sum = float('inf')\n        result = []\n        \n        for s in common:\n            index_sum = list1.index(s) + list2.index(s)\n            if index_sum < min_index_sum:\n                min_index_sum = index_sum\n                result = [s]\n            elif index_sum == min_index_sum:\n                result.append(s)\n        \n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/572", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        return self.isSameTree(root, subRoot) or self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n    \n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```", "extracted_code": "\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        return self.isSameTree(root, subRoot) or self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n    \n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/551", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        absent_count = 0\n        late_count = 0\n        \n        for i in range(len(s)):\n            if s[i] == 'A':\n                absent_count += 1\n                if absent_count >= 2:\n                    return False\n            if s[i] == 'L':\n                late_count += 1\n                if late_count >= 3 and s[i-1:i+2] == 'LLL':\n                    return False\n            else:\n                late_count = 0\n        \n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        absent_count = 0\n        late_count = 0\n        \n        for i in range(len(s)):\n            if s[i] == 'A':\n                absent_count += 1\n                if absent_count >= 2:\n                    return False\n            if s[i] == 'L':\n                late_count += 1\n                if late_count >= 3 and s[i-1:i+2] == 'LLL':\n                    return False\n            else:\n                late_count = 0\n        \n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2215", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        distinct_nums1 = list(set(nums1) - set(nums2))\n        distinct_nums2 = list(set(nums2) - set(nums1))\n        return [distinct_nums1, distinct_nums2]\n```", "extracted_code": "\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        distinct_nums1 = list(set(nums1) - set(nums2))\n        distinct_nums2 = list(set(nums2) - set(nums1))\n        return [distinct_nums1, distinct_nums2]\n", "difficulty": 1.0}
{"task_id": "LeetCode/509", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return fib[n]\n```", "extracted_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return fib[n]\n", "difficulty": 1.0}
