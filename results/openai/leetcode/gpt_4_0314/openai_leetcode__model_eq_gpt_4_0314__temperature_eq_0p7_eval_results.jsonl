{"task_id": "LeetCode/2818", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_factors(n):\n            i = 2\n            factors = set()\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.add(i)\n            if n > 1:\n                factors.add(n)\n            return len(factors)\n\n        def helper(l, r, k):\n            if k == 0:\n                return 1\n            max_score = 1\n            min_index = l\n            for i in range(l, r + 1):\n                if prime_factors(nums[i]) > prime_factors(nums[min_index]):\n                    min_index = i\n                max_score = max(max_score, nums[min_index] * helper(l, i - 1, k - 1) * helper(i + 1, r, k - 1))\n            return max_score\n\n        return helper(0, len(nums) - 1, k) % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        def prime_factors(n):\n            i = 2\n            factors = set()\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.add(i)\n            if n > 1:\n                factors.add(n)\n            return len(factors)\n\n        def helper(l, r, k):\n            if k == 0:\n                return 1\n            max_score = 1\n            min_index = l\n            for i in range(l, r + 1):\n                if prime_factors(nums[i]) > prime_factors(nums[min_index]):\n                    min_index = i\n                max_score = max(max_score, nums[min_index] * helper(l, i - 1, k - 1) * helper(i + 1, r, k - 1))\n            return max_score\n\n        return helper(0, len(nums) - 1, k) % (10**9 + 7)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2813", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom itertools import combinations\nfrom typing import List\n\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        max_elegance = 0\n\n        for subseq in combinations(items, k):\n            total_profit = sum(item[0] for item in subseq)\n            distinct_categories = len(set(item[1] for item in subseq))\n            elegance = total_profit + distinct_categories ** 2\n            max_elegance = max(max_elegance, elegance)\n\n        return max_elegance\n```", "extracted_code": "\nfrom itertools import combinations\nfrom typing import List\n\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        max_elegance = 0\n\n        for subseq in combinations(items, k):\n            total_profit = sum(item[0] for item in subseq)\n            distinct_categories = len(set(item[1] for item in subseq))\n            elegance = total_profit + distinct_categories ** 2\n            max_elegance = max(max_elegance, elegance)\n\n        return max_elegance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2812", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        def manhattan_distance(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        def dfs(r, c, min_distance):\n            if r < 0 or r >= n or c < 0 or c >= n or visited[r][c]:\n                return -1\n            visited[r][c] = True\n            min_distance = min(min_distance, min([manhattan_distance((r, c), thief) for thief in thieves]))\n            if r == n - 1 and c == n - 1:\n                return min_distance\n            max_safety = max(dfs(r + 1, c, min_distance), dfs(r - 1, c, min_distance),\n                            dfs(r, c + 1, min_distance), dfs(r, c - 1, min_distance))\n            visited[r][c] = False\n            return max_safety\n\n        n = len(grid)\n        visited = [[False for _ in range(n)] for _ in range(n)]\n        thieves = [(r, c) for r in range(n) for c in range(n) if grid[r][c] == 1]\n        \n        return dfs(0, 0, float('inf'))", "extracted_code": "class Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        def manhattan_distance(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        def dfs(r, c, min_distance):\n            if r < 0 or r >= n or c < 0 or c >= n or visited[r][c]:\n                return -1\n            visited[r][c] = True\n            min_distance = min(min_distance, min([manhattan_distance((r, c), thief) for thief in thieves]))\n            if r == n - 1 and c == n - 1:\n                return min_distance\n            max_safety = max(dfs(r + 1, c, min_distance), dfs(r - 1, c, min_distance),\n                            dfs(r, c + 1, min_distance), dfs(r, c - 1, min_distance))\n            visited[r][c] = False\n            return max_safety\n\n        n = len(grid)\n        visited = [[False for _ in range(n)] for _ in range(n)]\n        thieves = [(r, c) for r in range(n) for c in range(n) if grid[r][c] == 1]\n        \n        return dfs(0, 0, float('inf'))", "difficulty": 2.0}
{"task_id": "LeetCode/2811", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        def helper(arr, m, count):\n            if count == 0:\n                return sum(arr) >= m\n            if len(arr) <= count:\n                return False\n            for i in range(1, len(arr)):\n                if sum(arr[:i]) >= m and helper(arr[i:], m, count - 1):\n                    return True\n            return False\n\n        return helper(nums, m, n - 1)\n```", "extracted_code": "\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        def helper(arr, m, count):\n            if count == 0:\n                return sum(arr) >= m\n            if len(arr) <= count:\n                return False\n            for i in range(1, len(arr)):\n                if sum(arr[:i]) >= m and helper(arr[i:], m, count - 1):\n                    return True\n            return False\n\n        return helper(nums, m, n - 1)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2809", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total_sum = sum(nums1)\n        if total_sum <= x:\n            return 0\n        \n        left, right = 0, len(nums1)\n        min_time = float('inf')\n        window_sum = 0\n        \n        for i in range(len(nums1)):\n            total_sum += nums2[i] - nums1[i]\n            window_sum += nums2[i] - nums1[i]\n            while total_sum - window_sum <= x:\n                min_time = min(min_time, i - left + len(nums1))\n                window_sum -= nums2[left] - nums1[left]\n                left += 1\n                \n        return min_time if min_time != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total_sum = sum(nums1)\n        if total_sum <= x:\n            return 0\n        \n        left, right = 0, len(nums1)\n        min_time = float('inf')\n        window_sum = 0\n        \n        for i in range(len(nums1)):\n            total_sum += nums2[i] - nums1[i]\n            window_sum += nums2[i] - nums1[i]\n            while total_sum - window_sum <= x:\n                min_time = min(min_time, i - left + len(nums1))\n                window_sum -= nums2[left] - nums1[left]\n                left += 1\n                \n        return min_time if min_time != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2808", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_count = 1\n        count = 1\n        for i in range(n):\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                count = 1\n            max_count = max(max_count, count)\n        return (n - max_count + 1) // 2\n```", "extracted_code": "\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_count = 1\n        count = 1\n        for i in range(n):\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                count = 1\n            max_count = max(max_count, count)\n        return (n - max_count + 1) // 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2807", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        current = head\n        while current and current.next:\n            gcd_value = gcd(current.val, current.next.val)\n            new_node = ListNode(gcd_value, current.next)\n            current.next = new_node\n            current = new_node.next\n        return head\n```", "extracted_code": "\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        current = head\n        while current and current.next:\n            gcd_value = gcd(current.val, current.next.val)\n            new_node = ListNode(gcd_value, current.next)\n            current.next = new_node\n            current = new_node.next\n        return head\n", "difficulty": 2.0}
{"task_id": "LeetCode/2806", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        balance = 100\n        roundedAmount = (purchaseAmount + 9) // 10 * 10\n        return balance - roundedAmount\n```", "extracted_code": "\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        balance = 100\n        roundedAmount = (purchaseAmount + 9) // 10 * 10\n        return balance - roundedAmount\n", "difficulty": 1.0}
{"task_id": "LeetCode/2801", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 1000000007\n        \n        def is_stepping_number(num):\n            num_str = str(num)\n            for i in range(1, len(num_str)):\n                if abs(int(num_str[i]) - int(num_str[i - 1])) != 1:\n                    return False\n            return True\n\n        def dfs(num, low, high, count):\n            if num > high:\n                return count\n            if low <= num <= high and is_stepping_number(num):\n                count += 1\n            if num == 0:\n                for i in range(1, 10):\n                    count = dfs(num * 10 + i, low, high, count)\n            else:\n                last_digit = num % 10\n                if last_digit > 0:\n                    count = dfs(num * 10 + last_digit - 1, low, high, count)\n                if last_digit < 9:\n                    count = dfs(num * 10 + last_digit + 1, low, high, count)\n            return count\n\n        low, high = int(low), int(high)\n        count = 0\n        for i in range(10):\n            count = dfs(i, low, high, count)\n        return count % MOD\n```", "extracted_code": "\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 1000000007\n        \n        def is_stepping_number(num):\n            num_str = str(num)\n            for i in range(1, len(num_str)):\n                if abs(int(num_str[i]) - int(num_str[i - 1])) != 1:\n                    return False\n            return True\n\n        def dfs(num, low, high, count):\n            if num > high:\n                return count\n            if low <= num <= high and is_stepping_number(num):\n                count += 1\n            if num == 0:\n                for i in range(1, 10):\n                    count = dfs(num * 10 + i, low, high, count)\n            else:\n                last_digit = num % 10\n                if last_digit > 0:\n                    count = dfs(num * 10 + last_digit - 1, low, high, count)\n                if last_digit < 9:\n                    count = dfs(num * 10 + last_digit + 1, low, high, count)\n            return count\n\n        low, high = int(low), int(high)\n        count = 0\n        for i in range(10):\n            count = dfs(i, low, high, count)\n        return count % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2800", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        def concat(s1, s2):\n            for i in range(len(s1)):\n                if s2.startswith(s1[i:]):\n                    return s1 + s2[len(s1) - i:]\n            return s1 + s2\n        \n        candidates = [concat(concat(a, b), c), concat(concat(a, c), b), concat(concat(b, a), c),\n                      concat(concat(b, c), a), concat(concat(c, a), b), concat(concat(c, b), a)]\n        \n        return min(candidates, key=lambda x: (len(x), x))\n```\n", "extracted_code": "\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        def concat(s1, s2):\n            for i in range(len(s1)):\n                if s2.startswith(s1[i:]):\n                    return s1 + s2[len(s1) - i:]\n            return s1 + s2\n        \n        candidates = [concat(concat(a, b), c), concat(concat(a, c), b), concat(concat(b, a), c),\n                      concat(concat(b, c), a), concat(concat(c, a), b), concat(concat(c, b), a)]\n        \n        return min(candidates, key=lambda x: (len(x), x))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2799", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        distinct_count = len(set(nums))\n        left, right, result = 0, 0, 0\n        subarray_count = {}\n\n        while right < len(nums):\n            if nums[right] not in subarray_count:\n                subarray_count[nums[right]] = 0\n            subarray_count[nums[right]] += 1\n            \n            while len(subarray_count) == distinct_count:\n                result += len(nums) - right\n                subarray_count[nums[left]] -= 1\n                if subarray_count[nums[left]] == 0:\n                    del subarray_count[nums[left]]\n                left += 1\n                \n            right += 1\n\n        return result\n```", "extracted_code": "\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        distinct_count = len(set(nums))\n        left, right, result = 0, 0, 0\n        subarray_count = {}\n\n        while right < len(nums):\n            if nums[right] not in subarray_count:\n                subarray_count[nums[right]] = 0\n            subarray_count[nums[right]] += 1\n            \n            while len(subarray_count) == distinct_count:\n                result += len(nums) - right\n                subarray_count[nums[left]] -= 1\n                if subarray_count[nums[left]] == 0:\n                    del subarray_count[nums[left]]\n                left += 1\n                \n            right += 1\n\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2791", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        def dfs(node: int):\n            chars[node] ^= 1 << (ord(s[node]) - ord('a'))\n            if node:\n                counts[node] = counts[parent[node]] ^ chars[node]\n            valid_paths = 0\n            for child in graph[node]:\n                valid_paths += dfs(child)\n            return valid_paths + counts[node] in palindromes\n\n        n = len(parent)\n        graph = [[] for _ in range(n)]\n        for i in range(1, n):\n            graph[parent[i]].append(i)\n        chars = [0] * n\n        counts = [0] * n\n        palindromes = {0, 2 ** i for i in range(26)}\n        return dfs(0)\n```", "extracted_code": "\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        def dfs(node: int):\n            chars[node] ^= 1 << (ord(s[node]) - ord('a'))\n            if node:\n                counts[node] = counts[parent[node]] ^ chars[node]\n            valid_paths = 0\n            for child in graph[node]:\n                valid_paths += dfs(child)\n            return valid_paths + counts[node] in palindromes\n\n        n = len(parent)\n        graph = [[] for _ in range(n)]\n        for i in range(1, n):\n            graph[parent[i]].append(i)\n        chars = [0] * n\n        counts = [0] * n\n        palindromes = {0, 2 ** i for i in range(26)}\n        return dfs(0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2790", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort(reverse=True)\n        groups, size = 0, 0\n\n        for limit in usageLimits:\n            if limit > size:\n                groups += 1\n                size += 1\n\n        return groups", "extracted_code": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort(reverse=True)\n        groups, size = 0, 0\n\n        for limit in usageLimits:\n            if limit > size:\n                groups += 1\n                size += 1\n\n        return groups", "difficulty": 3.0}
{"task_id": "LeetCode/2788", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            new_words = word.split(separator)\n            for new_word in new_words:\n                if new_word != \"\":\n                    result.append(new_word)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            new_words = word.split(separator)\n            for new_word in new_words:\n                if new_word != \"\":\n                    result.append(new_word)\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/2787", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 1000000007\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, int(n ** (1 / x)) + 1):\n            for j in range(n, i ** x - 1, -1):\n                dp[j] = (dp[j] + dp[j - i ** x]) % MOD\n\n        return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 1000000007\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, int(n ** (1 / x)) + 1):\n            for j in range(n, i ** x - 1, -1):\n                dp[j] = (dp[j] + dp[j - i ** x]) % MOD\n\n        return dp[n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2785", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = sorted([c for c in s if c.lower() in 'aeiou'])\n        result = []\n        for c in s:\n            if c.lower() in 'aeiou':\n                result.append(vowels.pop(0))\n            else:\n                result.append(c)\n        return ''.join(result)\n```", "extracted_code": "\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = sorted([c for c in s if c.lower() in 'aeiou'])\n        result = []\n        for c in s:\n            if c.lower() in 'aeiou':\n                result.append(vowels.pop(0))\n            else:\n                result.append(c)\n        return ''.join(result)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2784", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = max(nums)\n        return nums.count(n) == 2 and len(nums) == n + 1 and len(set(nums)) == n\n```", "extracted_code": "\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = max(nums)\n        return nums.count(n) == 2 and len(nums) == n + 1 and len(set(nums)) == n\n", "difficulty": 1.0}
{"task_id": "LeetCode/2781", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        max_length = 0\n        current_length = 0\n        idx = 0\n\n        while idx < len(word):\n            valid = True\n            for f in forbidden:\n                if word[idx:idx + len(f)] == f:\n                    valid = False\n                    idx += len(f) - 1\n                    break\n            if valid:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 0\n            idx += 1\n\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        max_length = 0\n        current_length = 0\n        idx = 0\n\n        while idx < len(word):\n            valid = True\n            for f in forbidden:\n                if word[idx:idx + len(f)] == f:\n                    valid = False\n                    idx += len(f) - 1\n                    break\n            if valid:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 0\n            idx += 1\n\n        return max_length\n", "difficulty": 3.0}
{"task_id": "LeetCode/2772", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        for i in range(len(nums) - k + 1):\n            decrease = nums[i]\n            for j in range(i, i + k):\n                nums[j] -= decrease\n            if i > 0 and nums[i - 1] != 0:\n                return False\n        return all(x == 0 for x in nums[-k + 1:])\n```\n", "extracted_code": "\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        for i in range(len(nums) - k + 1):\n            decrease = nums[i]\n            for j in range(i, i + k):\n                nums[j] -= decrease\n            if i > 0 and nums[i - 1] != 0:\n                return False\n        return all(x == 0 for x in nums[-k + 1:])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2771", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp = [[0] * n for _ in range(2)]\n        \n        for i in range(n):\n            mx1 = mx2 = 0\n            for j in range(i+1):\n                if nums1[i] >= nums1[j]:\n                    mx1 = max(mx1, dp[0][j])\n                if nums1[i] >= nums2[j]:\n                    mx1 = max(mx1, dp[1][j])\n                if nums2[i] >= nums1[j]:\n                    mx2 = max(mx2, dp[0][j])\n                if nums2[i] >= nums2[j]:\n                    mx2 = max(mx2, dp[1][j])\n            dp[0][i] = 1 + mx1\n            dp[1][i] = 1 + mx2\n                \n        return max(dp[0][-1], dp[1][-1])\n```", "extracted_code": "\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp = [[0] * n for _ in range(2)]\n        \n        for i in range(n):\n            mx1 = mx2 = 0\n            for j in range(i+1):\n                if nums1[i] >= nums1[j]:\n                    mx1 = max(mx1, dp[0][j])\n                if nums1[i] >= nums2[j]:\n                    mx1 = max(mx1, dp[1][j])\n                if nums2[i] >= nums1[j]:\n                    mx2 = max(mx2, dp[0][j])\n                if nums2[i] >= nums2[j]:\n                    mx2 = max(mx2, dp[1][j])\n            dp[0][i] = 1 + mx1\n            dp[1][i] = 1 + mx2\n                \n        return max(dp[0][-1], dp[1][-1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2770", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 0\n        max_jumps = 0\n\n        for i in range(1, n):\n            max_jumps = -1\n            for j in range(i):\n                if -target <= nums[i] - nums[j] <= target:\n                    max_jumps = max(max_jumps, dp[j] + 1)\n            dp[i] = max_jumps\n\n        return dp[-1] if dp[-1] != -1 else -1\n```", "extracted_code": "\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 0\n        max_jumps = 0\n\n        for i in range(1, n):\n            max_jumps = -1\n            for j in range(i):\n                if -target <= nums[i] - nums[j] <= target:\n                    max_jumps = max(max_jumps, dp[j] + 1)\n            dp[i] = max_jumps\n\n        return dp[-1] if dp[-1] != -1 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2768", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        black_cells = set(tuple(coord) for coord in coordinates)\n        counts = [0, 0, 0, 0, 0]\n        \n        for x in range(m - 1):\n            for y in range(n - 1):\n                block_coords = [(x, y), (x + 1, y), (x, y + 1), (x + 1, y + 1)]\n                black_count = sum(1 for coord in block_coords if coord in black_cells)\n                counts[black_count] += 1\n                \n        return counts\n```", "extracted_code": "\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        black_cells = set(tuple(coord) for coord in coordinates)\n        counts = [0, 0, 0, 0, 0]\n        \n        for x in range(m - 1):\n            for y in range(n - 1):\n                block_coords = [(x, y), (x + 1, y), (x, y + 1), (x + 1, y + 1)]\n                black_count = sum(1 for coord in block_coords if coord in black_cells)\n                counts[black_count] += 1\n                \n        return counts\n", "difficulty": 2.0}
{"task_id": "LeetCode/2766", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        marble_positions = {}\n        for num in nums:\n            marble_positions[num] = marble_positions.get(num, 0) + 1\n\n        for i in range(len(moveFrom)):\n            marble_positions[moveTo[i]] = marble_positions.get(moveTo[i], 0) + marble_positions[moveFrom[i]]\n            del marble_positions[moveFrom[i]]\n\n        return sorted(marble_positions.keys())\n```", "extracted_code": "\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        marble_positions = {}\n        for num in nums:\n            marble_positions[num] = marble_positions.get(num, 0) + 1\n\n        for i in range(len(moveFrom)):\n            marble_positions[moveTo[i]] = marble_positions.get(moveTo[i], 0) + marble_positions[moveFrom[i]]\n            del marble_positions[moveFrom[i]]\n\n        return sorted(marble_positions.keys())\n", "difficulty": 2.0}
{"task_id": "LeetCode/2763", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        def imbalance_number(arr: List[int]) -> int:\n            sarr = sorted(arr)\n            count = 0\n            for i in range(len(sarr) - 1):\n                if sarr[i + 1] - sarr[i] > 1:\n                    count += 1\n            return count\n        \n        total = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                total += imbalance_number(nums[i:j])\n        return total", "extracted_code": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        def imbalance_number(arr: List[int]) -> int:\n            sarr = sorted(arr)\n            count = 0\n            for i in range(len(sarr) - 1):\n                if sarr[i + 1] - sarr[i] > 1:\n                    count += 1\n            return count\n        \n        total = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                total += imbalance_number(nums[i:j])\n        return total", "difficulty": 3.0}
{"task_id": "LeetCode/2762", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        left = 0\n        for right in range(1, len(nums)):\n            if abs(nums[right] - nums[right - 1]) > 2:\n                left = right\n            count += right - left\n        return count\n```", "extracted_code": "\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        left = 0\n        for right in range(1, len(nums)):\n            if abs(nums[right] - nums[right - 1]) > 2:\n                left = right\n            count += right - left\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2751", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        robots = sorted(zip(positions, healths, directions))\n        stack = []\n\n        for position, health, direction in robots:\n            while stack and direction == 'L' and stack[-1][2] == 'R':\n                prev_position, prev_health, prev_direction = stack.pop()\n                if prev_health > health:\n                    stack.append((prev_position, prev_health - 1, prev_direction))\n                elif prev_health < health:\n                    health -= 1\n                else:\n                    health = -1\n            if health >= 0:\n                stack.append((position, health, direction))\n\n        return [health for _, health, _ in stack]\n```", "extracted_code": "\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        robots = sorted(zip(positions, healths, directions))\n        stack = []\n\n        for position, health, direction in robots:\n            while stack and direction == 'L' and stack[-1][2] == 'R':\n                prev_position, prev_health, prev_direction = stack.pop()\n                if prev_health > health:\n                    stack.append((prev_position, prev_health - 1, prev_direction))\n                elif prev_health < health:\n                    health -= 1\n                else:\n                    health = -1\n            if health >= 0:\n                stack.append((position, health, direction))\n\n        return [health for _, health, _ in stack]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2750", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        zeros, res, mod = [0], 0, 1000000007\n        for num in nums:\n            zeros.append(zeros[-1] + 1 if num == 0 else 0)\n        for i in range(len(zeros)):\n            if zeros[i] > 0:\n                res += zeros[i - 1]\n        return res % mod\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        zeros, res, mod = [0], 0, 1000000007\n        for num in nums:\n            zeros.append(zeros[-1] + 1 if num == 0 else 0)\n        for i in range(len(zeros)):\n            if zeros[i] > 0:\n                res += zeros[i - 1]\n        return res % mod\n", "difficulty": 2.0}
{"task_id": "LeetCode/2749", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        if num2 == 0:\n            return -1\n        operations = 0\n        while num1 != 0:\n            found = False\n            for i in range(61):\n                if num1 - (2 ** i + num2) >= 0:\n                    num1 -= (2 ** i + num2)\n                    found = True\n                    operations += 1\n                    break\n            if not found:\n                return -1\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        if num2 == 0:\n            return -1\n        operations = 0\n        while num1 != 0:\n            found = False\n            for i in range(61):\n                if num1 - (2 ** i + num2) >= 0:\n                    num1 -= (2 ** i + num2)\n                    found = True\n                    operations += 1\n                    break\n            if not found:\n                return -1\n        return operations\n", "difficulty": 2.0}
{"task_id": "LeetCode/2747", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        last_requests = [0] * (n + 1)\n        for server_id, time in logs:\n            last_requests[server_id] = max(last_requests[server_id], time)\n        \n        result = []\n        for query in queries:\n            count = 0\n            for i in range(1, n + 1):\n                if last_requests[i] < query - x:\n                    count += 1\n            result.append(count)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        last_requests = [0] * (n + 1)\n        for server_id, time in logs:\n            last_requests[server_id] = max(last_requests[server_id], time)\n        \n        result = []\n        for query in queries:\n            count = 0\n            for i in range(1, n + 1):\n                if last_requests[i] < query - x:\n                    count += 1\n            result.append(count)\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2744", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        reversed_words = set(word[::-1] for word in words)\n        return sum(word in reversed_words for word in words) // 2\n```", "extracted_code": "\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        reversed_words = set(word[::-1] for word in words)\n        return sum(word in reversed_words for word in words) // 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2742", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        walls = sorted(zip(cost, time), key=lambda x: (x[1], -x[0]))\n        total_time = sum(time)\n        total_cost = 0\n        for i in range(len(walls)):\n            if walls[i][1] <= total_time:\n                total_cost += walls[i][0]\n                total_time -= walls[i][1]\n            else:\n                break\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        walls = sorted(zip(cost, time), key=lambda x: (x[1], -x[0]))\n        total_time = sum(time)\n        total_cost = 0\n        for i in range(len(walls)):\n            if walls[i][1] <= total_time:\n                total_cost += walls[i][0]\n                total_time -= walls[i][1]\n            else:\n                break\n        return total_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2736", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        answer = []\n        for query in queries:\n            xi, yi = query\n            max_sum = -1\n            for j in range(len(nums1)):\n                if nums1[j] >= xi and nums2[j] >= yi:\n                    max_sum = max(max_sum, nums1[j] + nums2[j])\n            answer.append(max_sum)\n        return answer", "extracted_code": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        answer = []\n        for query in queries:\n            xi, yi = query\n            max_sum = -1\n            for j in range(len(nums1)):\n                if nums1[j] >= xi and nums2[j] >= yi:\n                    max_sum = max(max_sum, nums1[j] + nums2[j])\n            answer.append(max_sum)\n        return answer", "difficulty": 3.0}
{"task_id": "LeetCode/2734", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def smallestString(self, s: str) -> str:\n        for i in range(len(s) - 1):\n            if s[i] > s[i + 1]:\n                s = s[:i] + chr(ord(s[i]) - 1) + s[i + 1:]\n                break\n        else:\n            s = s[:-1] + chr(ord(s[-1]) - 1)\n        return s", "extracted_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        for i in range(len(s) - 1):\n            if s[i] > s[i + 1]:\n                s = s[:i] + chr(ord(s[i]) - 1) + s[i + 1:]\n                break\n        else:\n            s = s[:-1] + chr(ord(s[-1]) - 1)\n        return s", "difficulty": 2.0}
{"task_id": "LeetCode/2732", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        rows = list(range(m))\n\n        def is_good_subset(subset):\n            k = len(subset)\n            for col in range(n):\n                column_sum = sum(grid[row][col] for row in subset)\n                if column_sum > k // 2:\n                    return False\n            return True\n\n        for subset_size in range(1, m + 1):\n            for subset in itertools.combinations(rows, subset_size):\n                if is_good_subset(subset):\n                    return list(subset)\n\n        return []", "extracted_code": "class Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        rows = list(range(m))\n\n        def is_good_subset(subset):\n            k = len(subset)\n            for col in range(n):\n                column_sum = sum(grid[row][col] for row in subset)\n                if column_sum > k // 2:\n                    return False\n            return True\n\n        for subset_size in range(1, m + 1):\n            for subset in itertools.combinations(rows, subset_size):\n                if is_good_subset(subset):\n                    return list(subset)\n\n        return []", "difficulty": 3.0}
{"task_id": "LeetCode/2730", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        longest = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                count = 0\n                for k in range(1, len(substring)):\n                    if substring[k] == substring[k - 1]:\n                        count += 1\n                        if count > 1:\n                            break\n                else:\n                    longest = max(longest, len(substring))\n        return longest\n```", "extracted_code": "\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        longest = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                count = 0\n                for k in range(1, len(substring)):\n                    if substring[k] == substring[k - 1]:\n                        count += 1\n                        if count > 1:\n                            break\n                else:\n                    longest = max(longest, len(substring))\n        return longest\n", "difficulty": 2.0}
{"task_id": "LeetCode/2729", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        if n < 100 or n > 999:\n            return False\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n        return set(concatenated) == set(\"123456789\")\n```", "extracted_code": "\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        if n < 100 or n > 999:\n            return False\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n        return set(concatenated) == set(\"123456789\")\n", "difficulty": 1.0}
{"task_id": "LeetCode/2719", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        def digit_sum(x: int) -> int:\n            return sum(map(int, str(x)))\n        \n        def count_good_numbers(num: str) -> int:\n            count = 0\n            for x in range(int(num) + 1):\n                digit_sum_x = digit_sum(x)\n                if min_sum <= digit_sum_x <= max_sum:\n                    count += 1\n            return count\n        \n        return (count_good_numbers(num2) - count_good_numbers(num1) + (digit_sum(int(num1)) >= min_sum and digit_sum(int(num1)) <= max_sum)) % (10**9 + 7)", "extracted_code": "class Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        def digit_sum(x: int) -> int:\n            return sum(map(int, str(x)))\n        \n        def count_good_numbers(num: str) -> int:\n            count = 0\n            for x in range(int(num) + 1):\n                digit_sum_x = digit_sum(x)\n                if min_sum <= digit_sum_x <= max_sum:\n                    count += 1\n            return count\n        \n        return (count_good_numbers(num2) - count_good_numbers(num1) + (digit_sum(int(num1)) >= min_sum and digit_sum(int(num1)) <= max_sum)) % (10**9 + 7)", "difficulty": 3.0}
{"task_id": "LeetCode/2716", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if c in stack:\n                stack.remove(c)\n            else:\n                stack.append(c)\n        return len(stack)\n```", "extracted_code": "\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if c in stack:\n                stack.remove(c)\n            else:\n                stack.append(c)\n        return len(stack)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2713", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if not dp[i][j]:\n                    dp[i][j] = 1\n                for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and mat[i][j] < mat[ni][nj]:\n                        dp[ni][nj] = max(dp[ni][nj], dp[i][j] + 1)\n        \n        return max(max(row) for row in dp)", "extracted_code": "class Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if not dp[i][j]:\n                    dp[i][j] = 1\n                for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                    if 0 <= ni < m and 0 <= nj < n and mat[i][j] < mat[ni][nj]:\n                        dp[ni][nj] = max(dp[ni][nj], dp[i][j] + 1)\n        \n        return max(max(row) for row in dp)", "difficulty": 3.0}
{"task_id": "LeetCode/2712", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        prefix_zero, prefix_one, suffix_zero, suffix_one = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\n\n        for i in range(n):\n            prefix_zero[i + 1] = prefix_zero[i] + (s[i] == '0')\n            prefix_one[i + 1] = prefix_one[i] + (s[i] == '1')\n\n        for i in range(n - 1, -1, -1):\n            suffix_zero[i] = suffix_zero[i + 1] + (s[i] == '0')\n            suffix_one[i] = suffix_one[i + 1] + (s[i] == '1')\n\n        min_cost = n\n\n        for i in range(n + 1):\n            cost = prefix_one[i] + suffix_zero[i]\n            min_cost = min(min_cost, cost)\n\n        return min_cost\n```", "extracted_code": "\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        prefix_zero, prefix_one, suffix_zero, suffix_one = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\n\n        for i in range(n):\n            prefix_zero[i + 1] = prefix_zero[i] + (s[i] == '0')\n            prefix_one[i + 1] = prefix_one[i] + (s[i] == '1')\n\n        for i in range(n - 1, -1, -1):\n            suffix_zero[i] = suffix_zero[i + 1] + (s[i] == '0')\n            suffix_one[i] = suffix_one[i + 1] + (s[i] == '1')\n\n        min_cost = n\n\n        for i in range(n + 1):\n            cost = prefix_one[i] + suffix_zero[i]\n            min_cost = min(min_cost, cost)\n\n        return min_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2709", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        def connected(i, j):\n            return gcd(nums[i], nums[j]) > 1\n\n        for i in range(len(nums)):\n            if any(connected(i, j) for j in range(i + 1, len(nums))):\n                return True\n        return False\n```", "extracted_code": "\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        def connected(i, j):\n            return gcd(nums[i], nums[j]) > 1\n\n        for i in range(len(nums)):\n            if any(connected(i, j) for j in range(i + 1, len(nums))):\n                return True\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2708", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom itertools import combinations\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        max_strength = float('-inf')\n        nums_length = len(nums)\n        \n        for i in range(1, nums_length + 1):\n            for comb in combinations(range(nums_length), i):\n                strength = 1\n                for idx in comb:\n                    strength *= nums[idx]\n                max_strength = max(max_strength, strength)\n                \n        return max_strength\n```", "extracted_code": "\nfrom itertools import combinations\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        max_strength = float('-inf')\n        nums_length = len(nums)\n        \n        for i in range(1, nums_length + 1):\n            for comb in combinations(range(nums_length), i):\n                strength = 1\n                for idx in comb:\n                    strength *= nums[idx]\n                max_strength = max(max_strength, strength)\n                \n        return max_strength\n", "difficulty": 2.0}
{"task_id": "LeetCode/2707", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        n = len(s)\n        dp = [float(\"inf\")] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            for word in dictionary:\n                if s[i - len(word):i] == word:\n                    dp[i] = min(dp[i], dp[i - len(word)])\n\n            dp[i] += 1\n\n        return dp[-1] - 1\n```", "extracted_code": "\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        n = len(s)\n        dp = [float(\"inf\")] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            for word in dictionary:\n                if s[i - len(word):i] == word:\n                    dp[i] = min(dp[i], dp[i - len(word)])\n\n            dp[i] += 1\n\n        return dp[-1] - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2699", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        adj_list = [[] for _ in range(n)]\n        for u, v, w in edges:\n            adj_list[u].append((v, w))\n            adj_list[v].append((u, w))\n\n        def dijkstra(src, dest, set_negative_to_inf=True):\n            dist = [float('inf')] * n\n            dist[src] = 0\n            visited = [False] * n\n            pq = [(0, src)]\n\n            while pq:\n                d, u = heappop(pq)\n\n                if u == dest:\n                    return d\n\n                if visited[u]:\n                    continue\n\n                visited[u] = True\n\n                for v, w in adj_list[u]:\n                    if set_negative_to_inf and w == -1:\n                        continue\n                    new_dist = d + (w if w != -1 else 2 * 10**9)\n                    if new_dist < dist[v]:\n                        dist[v] = new_dist\n                        heappush(pq, (new_dist, v))\n\n            return float('inf')\n\n        initial_dist = dijkstra(source, destination)\n\n        if initial_dist < target:\n            return []\n\n        modified_edges = []\n        for u, v, w in edges:\n            if w == -1:\n                w = 2 * 10**9 - dijkstra(u, v, set_negative_to_inf=False)\n            modified_edges.append([u, v, w])\n\n        return modified_edges if dijkstra(source, destination, set_negative_to_inf=False) == target else []\n```", "extracted_code": "\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        adj_list = [[] for _ in range(n)]\n        for u, v, w in edges:\n            adj_list[u].append((v, w))\n            adj_list[v].append((u, w))\n\n        def dijkstra(src, dest, set_negative_to_inf=True):\n            dist = [float('inf')] * n\n            dist[src] = 0\n            visited = [False] * n\n            pq = [(0, src)]\n\n            while pq:\n                d, u = heappop(pq)\n\n                if u == dest:\n                    return d\n\n                if visited[u]:\n                    continue\n\n                visited[u] = True\n\n                for v, w in adj_list[u]:\n                    if set_negative_to_inf and w == -1:\n                        continue\n                    new_dist = d + (w if w != -1 else 2 * 10**9)\n                    if new_dist < dist[v]:\n                        dist[v] = new_dist\n                        heappush(pq, (new_dist, v))\n\n            return float('inf')\n\n        initial_dist = dijkstra(source, destination)\n\n        if initial_dist < target:\n            return []\n\n        modified_edges = []\n        for u, v, w in edges:\n            if w == -1:\n                w = 2 * 10**9 - dijkstra(u, v, set_negative_to_inf=False)\n            modified_edges.append([u, v, w])\n\n        return modified_edges if dijkstra(source, destination, set_negative_to_inf=False) == target else []\n", "difficulty": 3.0}
{"task_id": "LeetCode/2698", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def sum_of_substrings(num_str, target):\n            if not num_str and target == 0:\n                return True\n            for i in range(1, len(num_str) + 1):\n                if sum_of_substrings(num_str[i:], target - int(num_str[:i])):\n                    return True\n            return False\n\n        total = 0\n        for i in range(1, n + 1):\n            square = i * i\n            if sum_of_substrings(str(square), i):\n                total += square\n        return total\n```", "extracted_code": "\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def sum_of_substrings(num_str, target):\n            if not num_str and target == 0:\n                return True\n            for i in range(1, len(num_str) + 1):\n                if sum_of_substrings(num_str[i:], target - int(num_str[:i])):\n                    return True\n            return False\n\n        total = 0\n        for i in range(1, n + 1):\n            square = i * i\n            if sum_of_substrings(str(square), i):\n                total += square\n        return total\n", "difficulty": 2.0}
{"task_id": "LeetCode/2697", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        s = list(s)\n        n = len(s)\n        for i in range(n // 2):\n            if s[i] != s[n - i - 1]:\n                s[n - i - 1] = min(s[i], s[n - i - 1])\n        return ''.join(s)\n```", "extracted_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        s = list(s)\n        n = len(s)\n        for i in range(n // 2):\n            if s[i] != s[n - i - 1]:\n                s[n - i - 1] = min(s[i], s[n - i - 1])\n        return ''.join(s)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2681", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 1000000007\n        n = len(nums)\n        nums.sort()\n        powers = [1]\n        for i in range(1, n + 1):\n            powers.append(powers[-1] * 2 % MOD)\n        ans = 0\n        for i, num in enumerate(nums):\n            ans += (powers[i] - 1) * (powers[n - i] - 1) * num * num\n            ans %= MOD\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 1000000007\n        n = len(nums)\n        nums.sort()\n        powers = [1]\n        for i in range(1, n + 1):\n            powers.append(powers[-1] * 2 % MOD)\n        ans = 0\n        for i, num in enumerate(nums):\n            ans += (powers[i] - 1) * (powers[n - i] - 1) * num * num\n            ans %= MOD\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2680", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        max_val = 0\n        for i in range(1 << k):\n            temp = [num << (bin(i).count('1')) for num in nums]\n            max_val = max(max_val, reduce(lambda x, y: x | y, temp))\n        return max_val\n```", "extracted_code": "\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        max_val = 0\n        for i in range(1 << k):\n            temp = [num << (bin(i).count('1')) for num in nums]\n            max_val = max(max_val, reduce(lambda x, y: x | y, temp))\n        return max_val\n", "difficulty": 2.0}
{"task_id": "LeetCode/2670", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        diff = [0] * n\n        prefix_distinct = set()\n        suffix_distinct_counts = [0] * (n + 1)\n        \n        for i in range(n - 1, -1, -1):\n            suffix_distinct_counts[i] = len(set(nums[i + 1:]) | set(nums[:i + 1]))\n            \n        for i in range(n):\n            prefix_distinct.add(nums[i])\n            diff[i] = len(prefix_distinct) - suffix_distinct_counts[i + 1]\n            \n        return diff\n```", "extracted_code": "\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        diff = [0] * n\n        prefix_distinct = set()\n        suffix_distinct_counts = [0] * (n + 1)\n        \n        for i in range(n - 1, -1, -1):\n            suffix_distinct_counts[i] = len(set(nums[i + 1:]) | set(nums[:i + 1]))\n            \n        for i in range(n):\n            prefix_distinct.add(nums[i])\n            diff[i] = len(prefix_distinct) - suffix_distinct_counts[i + 1]\n            \n        return diff\n", "difficulty": 1.0}
{"task_id": "LeetCode/2663", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        def is_beautiful(candidate: str) -> bool:\n            for i in range(len(candidate) - 1):\n                if candidate[i] == candidate[i + 1]:\n                    return False\n            return True\n\n        s_list = list(s)\n        for i in range(len(s_list) - 1, -1, -1):\n            if s_list[i] != chr(ord('a') + k - 1):\n                s_list[i] = chr(ord(s_list[i]) + 1)\n                while not is_beautiful(s_list):\n                    s_list[i] = chr(ord(s_list[i]) + 1)\n                    if s_list[i] > chr(ord('a') + k - 1):\n                        break\n                if s_list[i] <= chr(ord('a') + k - 1):\n                    return ''.join(s_list)\n                else:\n                    s_list[i] = 'a'\n            else:\n                s_list[i] = 'a'\n\n        return ''\n```", "extracted_code": "\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        def is_beautiful(candidate: str) -> bool:\n            for i in range(len(candidate) - 1):\n                if candidate[i] == candidate[i + 1]:\n                    return False\n            return True\n\n        s_list = list(s)\n        for i in range(len(s_list) - 1, -1, -1):\n            if s_list[i] != chr(ord('a') + k - 1):\n                s_list[i] = chr(ord(s_list[i]) + 1)\n                while not is_beautiful(s_list):\n                    s_list[i] = chr(ord(s_list[i]) + 1)\n                    if s_list[i] > chr(ord('a') + k - 1):\n                        break\n                if s_list[i] <= chr(ord('a') + k - 1):\n                    return ''.join(s_list)\n                else:\n                    s_list[i] = 'a'\n            else:\n                s_list[i] = 'a'\n\n        return ''\n", "difficulty": 3.0}
{"task_id": "LeetCode/2659", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        ops = 0\n        while nums:\n            min_val = min(nums)\n            min_idx = nums.index(min_val)\n            ops += min_idx + 1\n            nums = nums[min_idx + 1:]\n        return ops\n```", "extracted_code": "\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        ops = 0\n        while nums:\n            min_val = min(nums)\n            min_idx = nums.index(min_val)\n            ops += min_idx + 1\n            nums = nums[min_idx + 1:]\n        return ops\n", "difficulty": 3.0}
{"task_id": "LeetCode/2658", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        def dfs(r, c):\n            if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):\n                return 0\n            fish = grid[r][c]\n            grid[r][c] = 0\n            max_fish = 0\n            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                max_fish = max(max_fish, dfs(r + dr, c + dc))\n            grid[r][c] = fish\n            return max_fish + fish\n\n        result = 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] > 0:\n                    result = max(result, dfs(r, c))\n        return result\n```", "extracted_code": "\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        def dfs(r, c):\n            if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):\n                return 0\n            fish = grid[r][c]\n            grid[r][c] = 0\n            max_fish = 0\n            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                max_fish = max(max_fish, dfs(r + dr, c + dc))\n            grid[r][c] = fish\n            return max_fish + fish\n\n        result = 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] > 0:\n                    result = max(result, dfs(r, c))\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2657", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        position = [0] * (len(A) + 1)\n        for i, a in enumerate(B):\n            position[a] = i\n        count = 0\n        result = [0] * len(A)\n        for i, a in enumerate(A):\n            if position[a] > 0 and position[a] > position[A[i - 1]]:\n                count += 1\n            elif position[a] == 0:\n                count = 0\n            result[i] = count\n        return result\n```", "extracted_code": "\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        position = [0] * (len(A) + 1)\n        for i, a in enumerate(B):\n            position[a] = i\n        count = 0\n        result = [0] * len(A)\n        for i, a in enumerate(A):\n            if position[a] > 0 and position[a] > position[A[i - 1]]:\n                count += 1\n            elif position[a] == 0:\n                count = 0\n            result[i] = count\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2653", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        result = []\n        for i in range(len(nums) - k + 1):\n            subarray = sorted(filter(lambda num: num < 0, nums[i:i+k]))\n            result.append(subarray[x-1] if len(subarray) >= x else 0)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        result = []\n        for i in range(len(nums) - k + 1):\n            subarray = sorted(filter(lambda num: num < 0, nums[i:i+k]))\n            result.append(subarray[x-1] if len(subarray) >= x else 0)\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2652", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(x for x in range(1, n + 1) if x % 3 == 0 or x % 5 == 0 or x % 7 == 0)\n```", "extracted_code": "\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(x for x in range(1, n + 1) if x % 3 == 0 or x % 5 == 0 or x % 7 == 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2651", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24\n```", "extracted_code": "\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24\n", "difficulty": 1.0}
{"task_id": "LeetCode/2646", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def minimumTotalPrice(n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n    from collections import defaultdict\n    def dfs(node: int, parent: int) -> None:\n        for adj in graph[node]:\n            if adj != parent:\n                dfs(adj, node)\n                dp[node] += min(dp[adj], price[adj] // 2)\n\n    def dfs2(node: int, parent: int, cur_sum: int) -> None:\n        nonlocal ans\n        cur_sum += min(dp[node], price[node] // 2)\n        ans += requests[node] * cur_sum\n        for adj in graph[node]:\n            if adj != parent:\n                dfs2(adj, node, cur_sum - min(dp[adj], price[adj] // 2))\n\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    requests = [0] * n\n    for a, b in trips:\n        requests[a] += 1\n        requests[b] += 1\n\n    dp = [0] * n\n    dfs(0, -1)\n    ans = 0\n    dfs2(0, -1, 0)\n    return ans", "extracted_code": "def minimumTotalPrice(n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n    from collections import defaultdict\n    def dfs(node: int, parent: int) -> None:\n        for adj in graph[node]:\n            if adj != parent:\n                dfs(adj, node)\n                dp[node] += min(dp[adj], price[adj] // 2)\n\n    def dfs2(node: int, parent: int, cur_sum: int) -> None:\n        nonlocal ans\n        cur_sum += min(dp[node], price[node] // 2)\n        ans += requests[node] * cur_sum\n        for adj in graph[node]:\n            if adj != parent:\n                dfs2(adj, node, cur_sum - min(dp[adj], price[adj] // 2))\n\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    requests = [0] * n\n    for a, b in trips:\n        requests[a] += 1\n        requests[b] += 1\n\n    dp = [0] * n\n    dfs(0, -1)\n    ans = 0\n    dfs2(0, -1, 0)\n    return ans", "difficulty": 3.0}
{"task_id": "LeetCode/2645", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count = 0\n        a, b, c = 0, 0, 0\n        for letter in word:\n            if letter == 'a':\n                a += 1\n            elif letter == 'b':\n                if a >= b + 1:\n                    b += 1\n                else:\n                    count += 1\n                    b += 1\n            elif letter == 'c':\n                if b >= c + 1:\n                    c += 1\n                else:\n                    count += 1\n                    c += 1\n        count += (a - c) * 2 + (b - c)\n        return count\n```", "extracted_code": "\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count = 0\n        a, b, c = 0, 0, 0\n        for letter in word:\n            if letter == 'a':\n                a += 1\n            elif letter == 'b':\n                if a >= b + 1:\n                    b += 1\n                else:\n                    count += 1\n                    b += 1\n            elif letter == 'c':\n                if b >= c + 1:\n                    c += 1\n                else:\n                    count += 1\n                    c += 1\n        count += (a - c) * 2 + (b - c)\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2642", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Graph:\n\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.graph = {i: [] for i in range(n)}\n        for edge in edges:\n            self.addEdge(edge)\n\n    def addEdge(self, edge: List[int]) -> None:\n        self.graph[edge[0]].append((edge[1], edge[2]))\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        visited = set()\n        queue = [(node1, 0)]\n\n        while queue:\n            curr_node, cost = queue.pop(0)\n            visited.add(curr_node)\n\n            if curr_node == node2:\n                return cost\n\n            for neighbor, edge_cost in self.graph[curr_node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, cost + edge_cost))\n\n        return -1", "extracted_code": "class Graph:\n\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.graph = {i: [] for i in range(n)}\n        for edge in edges:\n            self.addEdge(edge)\n\n    def addEdge(self, edge: List[int]) -> None:\n        self.graph[edge[0]].append((edge[1], edge[2]))\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        visited = set()\n        queue = [(node1, 0)]\n\n        while queue:\n            curr_node, cost = queue.pop(0)\n            visited.add(curr_node)\n\n            if curr_node == node2:\n                return cost\n\n            for neighbor, edge_cost in self.graph[curr_node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, cost + edge_cost))\n\n        return -1", "difficulty": 3.0}
{"task_id": "LeetCode/2640", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        ans = []\n        max_value = 0\n        total = 0\n        for num in nums:\n            max_value = max(max_value, num)\n            total += num + max_value\n            ans.append(total)\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        ans = []\n        max_value = 0\n        total = 0\n        for num in nums:\n            max_value = max(max_value, num)\n            total += num + max_value\n            ans.append(total)\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2617", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def minimumVisitedCells(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i == m - 1 and j == n - 1:\n                break\n            for k in range(1, grid[i][j] + 1):\n                if j + k < n:\n                    dp[i][j + k] = min(dp[i][j + k], dp[i][j] + 1)\n                if i + k < m:\n                    dp[i + k][j] = min(dp[i + k][j], dp[i][j] + 1)\n\n    return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "extracted_code": "def minimumVisitedCells(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i == m - 1 and j == n - 1:\n                break\n            for k in range(1, grid[i][j] + 1):\n                if j + k < n:\n                    dp[i][j + k] = min(dp[i][j + k], dp[i][j] + 1)\n                if i + k < m:\n                    dp[i + k][j] = min(dp[i + k][j], dp[i][j] + 1)\n\n    return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "difficulty": 3.0}
{"task_id": "LeetCode/2616", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums.sort()\n        min_difference = float('inf')\n\n        for i in range(len(nums) - p):\n            difference = nums[i + p] - nums[i]\n            min_difference = min(min_difference, difference)\n\n        return min_difference\n```", "extracted_code": "\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums.sort()\n        min_difference = float('inf')\n\n        for i in range(len(nums) - p):\n            difference = nums[i + p] - nums[i]\n            min_difference = min(min_difference, difference)\n\n        return min_difference\n", "difficulty": 2.0}
{"task_id": "LeetCode/2615", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        from collections import defaultdict\n        index_dict = defaultdict(list)\n        arr = [0] * len(nums)\n\n        for i, num in enumerate(nums):\n            index_dict[num].append(i)\n\n        for indices in index_dict.values():\n            if len(indices) > 1:\n                for i in range(len(indices)):\n                    arr[indices[i]] = sum(abs(indices[i] - indices[j]) for j in range(len(indices)) if i != j)\n        return arr\n```", "extracted_code": "\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        from collections import defaultdict\n        index_dict = defaultdict(list)\n        arr = [0] * len(nums)\n\n        for i, num in enumerate(nums):\n            index_dict[num].append(i)\n\n        for indices in index_dict.values():\n            if len(indices) > 1:\n                for i in range(len(indices)):\n                    arr[indices[i]] = sum(abs(indices[i] - indices[j]) for j in range(len(indices)) if i != j)\n        return arr\n", "difficulty": 2.0}
{"task_id": "LeetCode/2612", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        banned = set(banned)\n        ans = []\n        \n        for i in range(n):\n            if i in banned:\n                ans.append(-1)\n            elif i == p:\n                ans.append(0)\n            else:\n                cnt = abs(i - p) // (k - 1)\n                if cnt % 2 == 0 and p >= cnt * (k - 1) and i >= cnt * (k - 1):\n                    ans.append(cnt)\n                else:\n                    ans.append(-1)\n        \n        return ans", "extracted_code": "class Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        banned = set(banned)\n        ans = []\n        \n        for i in range(n):\n            if i in banned:\n                ans.append(-1)\n            elif i == p:\n                ans.append(0)\n            else:\n                cnt = abs(i - p) // (k - 1)\n                if cnt % 2 == 0 and p >= cnt * (k - 1) and i >= cnt * (k - 1):\n                    ans.append(cnt)\n                else:\n                    ans.append(-1)\n        \n        return ans", "difficulty": 3.0}
{"task_id": "LeetCode/2608", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        shortest_cycle = float('inf')\n\n        for start_node in range(n):\n            visited = [False] * n\n            level = [0] * n\n            queue = [start_node]\n\n            while queue:\n                current_node = queue.pop(0)\n                visited[current_node] = True\n\n                for neighbor in graph[current_node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        level[neighbor] = level[current_node] + 1\n                        queue.append(neighbor)\n                    elif level[current_node] - level[neighbor] + 1 >= 3:\n                        shortest_cycle = min(shortest_cycle, level[current_node] - level[neighbor] + 1)\n\n        return shortest_cycle if shortest_cycle != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        shortest_cycle = float('inf')\n\n        for start_node in range(n):\n            visited = [False] * n\n            level = [0] * n\n            queue = [start_node]\n\n            while queue:\n                current_node = queue.pop(0)\n                visited[current_node] = True\n\n                for neighbor in graph[current_node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        level[neighbor] = level[current_node] + 1\n                        queue.append(neighbor)\n                    elif level[current_node] - level[neighbor] + 1 >= 3:\n                        shortest_cycle = min(shortest_cycle, level[current_node] - level[neighbor] + 1)\n\n        return shortest_cycle if shortest_cycle != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2603", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        def dfs(node: int, parent: int) -> Tuple[int, int]:\n            dp = [0, 0]\n            for child in tree[node]:\n                if child != parent:\n                    child_dp = dfs(child, node)\n                    dp = [max(dp[0], dp[1] + child_dp[1]), dp[1] + child_dp[0] + coins[child]]\n            return dp\n\n        from collections import defaultdict\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n\n        root_dp = dfs(0, -1)\n        return max(root_dp[0], root_dp[1] - coins[0])", "extracted_code": "class Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        def dfs(node: int, parent: int) -> Tuple[int, int]:\n            dp = [0, 0]\n            for child in tree[node]:\n                if child != parent:\n                    child_dp = dfs(child, node)\n                    dp = [max(dp[0], dp[1] + child_dp[1]), dp[1] + child_dp[0] + coins[child]]\n            return dp\n\n        from collections import defaultdict\n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n\n        root_dp = dfs(0, -1)\n        return max(root_dp[0], root_dp[1] - coins[0])", "difficulty": 3.0}
{"task_id": "LeetCode/2601", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        def next_prime(n):\n            while not is_prime(n):\n                n += 1\n            return n\n\n        for i in range(len(nums) - 1):\n            while nums[i] >= nums[i + 1]:\n                p = next_prime(nums[i + 1] - 1)\n                if p >= nums[i + 1]:\n                    return False\n                nums[i + 1] -= p\n\n        return True\n```", "extracted_code": "\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        def next_prime(n):\n            while not is_prime(n):\n                n += 1\n            return n\n\n        for i in range(len(nums) - 1):\n            while nums[i] >= nums[i + 1]:\n                p = next_prime(nums[i + 1] - 1)\n                if p >= nums[i + 1]:\n                    return False\n                nums[i + 1] -= p\n\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2592", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort()\n        perm = nums[len(nums)//2:] + nums[:len(nums)//2]\n        greatness = sum(1 for i in range(len(nums)) if perm[i] > nums[i])\n        return greatness\n```", "extracted_code": "\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort()\n        perm = nums[len(nums)//2:] + nums[:len(nums)//2]\n        greatness = sum(1 for i in range(len(nums)) if perm[i] > nums[i])\n        return greatness\n", "difficulty": 2.0}
{"task_id": "LeetCode/2591", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children or money > 8 * children:\n            return -1\n        if money == 4 * children:\n            return (children - 1) // 2\n        return min(money - children, children)\n```", "extracted_code": "\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children or money > 8 * children:\n            return -1\n        if money == 4 * children:\n            return (children - 1) // 2\n        return min(money - children, children)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2589", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        def dfs(idx, task_duration, time_range):\n            if idx == len(tasks):\n                return 0\n            \n            if (idx, task_duration, time_range) in memo:\n                return memo[(idx, task_duration, time_range)]\n            \n            cur_start, cur_end, cur_duration = tasks[idx]\n            \n            if time_range > cur_end:\n                memo[(idx, task_duration, time_range)] = dfs(idx + 1, task_duration, time_range)\n                return memo[(idx, task_duration, time_range)]\n            \n            skip = dfs(idx + 1, task_duration, time_range)\n            include = float('inf')\n            for t in range(max(cur_start, time_range - task_duration + 1), cur_end - cur_duration + 2):\n                include = min(include, dfs(idx + 1, task_duration + cur_duration, t + cur_duration))\n            \n            memo[(idx, task_duration, time_range)] = min(skip, include)\n            return memo[(idx, task_duration, time_range)]\n        \n        tasks.sort()\n        memo = {}\n        return dfs(0, 0, 0)\n```", "extracted_code": "\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        def dfs(idx, task_duration, time_range):\n            if idx == len(tasks):\n                return 0\n            \n            if (idx, task_duration, time_range) in memo:\n                return memo[(idx, task_duration, time_range)]\n            \n            cur_start, cur_end, cur_duration = tasks[idx]\n            \n            if time_range > cur_end:\n                memo[(idx, task_duration, time_range)] = dfs(idx + 1, task_duration, time_range)\n                return memo[(idx, task_duration, time_range)]\n            \n            skip = dfs(idx + 1, task_duration, time_range)\n            include = float('inf')\n            for t in range(max(cur_start, time_range - task_duration + 1), cur_end - cur_duration + 2):\n                include = min(include, dfs(idx + 1, task_duration + cur_duration, t + cur_duration))\n            \n            memo[(idx, task_duration, time_range)] = min(skip, include)\n            return memo[(idx, task_duration, time_range)]\n        \n        tasks.sort()\n        memo = {}\n        return dfs(0, 0, 0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2587", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        prefix_sum = 0\n        score = 0\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum > 0:\n                score += 1\n            else:\n                break\n        return score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        prefix_sum = 0\n        score = 0\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum > 0:\n                score += 1\n            else:\n                break\n        return score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2585", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        \n        for count, marks in types:\n            for t in range(target, -1, -1):\n                for i in range(1, count + 1):\n                    new_t = t - i * marks\n                    if new_t < 0:\n                        break\n                    dp[t] = (dp[t] + dp[new_t]) % mod\n                    \n        return dp[target]\n```", "extracted_code": "\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        \n        for count, marks in types:\n            for t in range(target, -1, -1):\n                for i in range(1, count + 1):\n                    new_t = t - i * marks\n                    if new_t < 0:\n                        break\n                    dp[t] = (dp[t] + dp[new_t]) % mod\n                    \n        return dp[target]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2584", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom math import gcd\nfrom functools import reduce\nfrom typing import List\n\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        def product(arr):\n            return reduce(lambda x, y: x * y, arr)\n        \n        left = 1\n        right = product(nums)\n        \n        for i in range(len(nums) - 1):\n            left *= nums[i]\n            right //= nums[i]\n            if gcd(left, right) == 1:\n                return i\n        \n        return -1\n```", "extracted_code": "\nfrom math import gcd\nfrom functools import reduce\nfrom typing import List\n\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        def product(arr):\n            return reduce(lambda x, y: x * y, arr)\n        \n        left = 1\n        right = product(nums)\n        \n        for i in range(len(nums) - 1):\n            left *= nums[i]\n            right //= nums[i]\n            if gcd(left, right) == 1:\n                return i\n        \n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2581", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n \n        def dfs(u, parent, depth):\n            if depth == k:\n                return 1\n            count = 0\n            for v in adj[u]:\n                if v != parent:\n                    count += dfs(v, u, depth + 1)\n            return count\n \n        total_count = 0\n        for u, v in guesses:\n            total_count += dfs(u, v, 0)\n \n        return n - total_count\n```", "extracted_code": "\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        adj = [[] for _ in range(n)]\n        for a, b in edges:\n            adj[a].append(b)\n            adj[b].append(a)\n \n        def dfs(u, parent, depth):\n            if depth == k:\n                return 1\n            count = 0\n            for v in adj[u]:\n                if v != parent:\n                    count += dfs(v, u, depth + 1)\n            return count\n \n        total_count = 0\n        for u, v in guesses:\n            total_count += dfs(u, v, 0)\n \n        return n - total_count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2579", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        return 1 + 4 * (n * (n - 1)) // 2\n```", "extracted_code": "\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        return 1 + 4 * (n * (n - 1)) // 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2577", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = [[False] * cols for _ in range(rows)]\n        queue = deque([(0, 0, 0)])\n        visited[0][0] = True\n\n        while queue:\n            row, col, time = queue.popleft()\n            if row == rows - 1 and col == cols - 1:\n                return time\n\n            for dr, dc in directions:\n                newRow, newCol = row + dr, col + dc\n                if 0 <= newRow < rows and 0 <= newCol < cols and not visited[newRow][newCol] and time + 1 >= grid[newRow][newCol]:\n                    visited[newRow][newCol] = True\n                    queue.append((newRow, newCol, time + 1))\n\n        return -1\n```", "extracted_code": "\nfrom collections import deque\nfrom typing import List\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = [[False] * cols for _ in range(rows)]\n        queue = deque([(0, 0, 0)])\n        visited[0][0] = True\n\n        while queue:\n            row, col, time = queue.popleft()\n            if row == rows - 1 and col == cols - 1:\n                return time\n\n            for dr, dc in directions:\n                newRow, newCol = row + dr, col + dc\n                if 0 <= newRow < rows and 0 <= newCol < cols and not visited[newRow][newCol] and time + 1 >= grid[newRow][newCol]:\n                    visited[newRow][newCol] = True\n                    queue.append((newRow, newCol, time + 1))\n\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2576", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def maxNumOfMarkedIndices(nums):\n    nums.sort()\n    marked = [0] * len(nums)\n    result = 0\n\n    for i in range(len(nums)):\n        if marked[i] == 0:\n            for j in range(i + 1, len(nums)):\n                if marked[j] == 0 and 2 * nums[i] <= nums[j]:\n                    marked[i] = 1\n                    marked[j] = 1\n                    result += 2\n                    break\n\n    return result", "extracted_code": "def maxNumOfMarkedIndices(nums):\n    nums.sort()\n    marked = [0] * len(nums)\n    result = 0\n\n    for i in range(len(nums)):\n        if marked[i] == 0:\n            for j in range(i + 1, len(nums)):\n                if marked[j] == 0 and 2 * nums[i] <= nums[j]:\n                    marked[i] = 1\n                    marked[j] = 1\n                    result += 2\n                    break\n\n    return result", "difficulty": 2.0}
{"task_id": "LeetCode/2573", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        word = ['a'] * n\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if lcp[i][j] < lcp[j][i]:\n                    return \"\"\n                if lcp[i][j] == lcp[j][i] and lcp[i][j] < n - 1:\n                    word[max(i, j)] = chr(ord(word[max(i, j)]) + 1)\n\n        return ''.join(word)", "extracted_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        word = ['a'] * n\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if lcp[i][j] < lcp[j][i]:\n                    return \"\"\n                if lcp[i][j] == lcp[j][i] and lcp[i][j] < n - 1:\n                    word[max(i, j)] = chr(ord(word[max(i, j)]) + 1)\n\n        return ''.join(word)", "difficulty": 3.0}
{"task_id": "LeetCode/2570", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        result = []\n        i, j = 0, 0\n\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i][0] < nums2[j][0]:\n                result.append(nums1[i])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                result.append(nums2[j])\n                j += 1\n            else:\n                result.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n\n        while i < len(nums1):\n            result.append(nums1[i])\n            i += 1\n\n        while j < len(nums2):\n            result.append(nums2[j])\n            j += 1\n\n        return result", "extracted_code": "class Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        result = []\n        i, j = 0, 0\n\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i][0] < nums2[j][0]:\n                result.append(nums1[i])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                result.append(nums2[j])\n                j += 1\n            else:\n                result.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n\n        while i < len(nums1):\n            result.append(nums1[i])\n            i += 1\n\n        while j < len(nums2):\n            result.append(nums2[j])\n            j += 1\n\n        return result", "difficulty": 1.0}
{"task_id": "LeetCode/2569", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                for i in range(query[1], query[2] + 1):\n                    nums1[i] = 1 - nums1[i]\n            elif query[0] == 2:\n                for i in range(len(nums1)):\n                    nums2[i] += nums1[i] * query[1]\n            elif query[0] == 3:\n                result.append(sum(nums2))\n        return result\n```", "extracted_code": "\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                for i in range(query[1], query[2] + 1):\n                    nums1[i] = 1 - nums1[i]\n            elif query[0] == 2:\n                for i in range(len(nums1)):\n                    nums2[i] += nums1[i] * query[1]\n            elif query[0] == 3:\n                result.append(sum(nums2))\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2568", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        max_val = 2 * (10 ** 9)\n        expressible = set(nums)\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                expressible.add(nums[i] | nums[j])\n                if len(expressible) >= max_val:\n                    break\n            if len(expressible) >= max_val:\n                break\n                \n        for i in range(1, max_val):\n            if i not in expressible:\n                return i\n```", "extracted_code": "\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        max_val = 2 * (10 ** 9)\n        expressible = set(nums)\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                expressible.add(nums[i] | nums[j])\n                if len(expressible) >= max_val:\n                    break\n            if len(expressible) >= max_val:\n                break\n                \n        for i in range(1, max_val):\n            if i not in expressible:\n                return i\n", "difficulty": 2.0}
{"task_id": "LeetCode/2565", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][m] = 0\n        for j in range(m):\n            dp[n][j] = m - j\n        \n        for i in reversed(range(n)):\n            for j in reversed(range(m)):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1])\n        \n        return dp[0][0]\n```", "extracted_code": "\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][m] = 0\n        for j in range(m):\n            dp[n][j] = m - j\n        \n        for i in reversed(range(n)):\n            for j in reversed(range(m)):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1])\n        \n        return dp[0][0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2564", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def substringXorQueries(s: str, queries: list[list[int]]) -> list[list[int]]:\n    def binary_to_int(binary_str):\n        return int(binary_str, 2)\n\n    def find_substring(first, second):\n        for left in range(len(s)):\n            for right in range(left, len(s)):\n                val = binary_to_int(s[left:right + 1])\n                if val ^ first == second:\n                    return [left, right]\n        return [-1, -1]\n\n    ans = []\n    for query in queries:\n        ans.append(find_substring(query[0], query[1]))\n\n    return ans", "extracted_code": "def substringXorQueries(s: str, queries: list[list[int]]) -> list[list[int]]:\n    def binary_to_int(binary_str):\n        return int(binary_str, 2)\n\n    def find_substring(first, second):\n        for left in range(len(s)):\n            for right in range(left, len(s)):\n                val = binary_to_int(s[left:right + 1])\n                if val ^ first == second:\n                    return [left, right]\n        return [-1, -1]\n\n    ans = []\n    for query in queries:\n        ans.append(find_substring(query[0], query[1]))\n\n    return ans", "difficulty": 2.0}
{"task_id": "LeetCode/2563", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if lower <= nums[i] + nums[j] <= upper:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if lower <= nums[i] + nums[j] <= upper:\n                    count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2561", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        basket1.sort()\n        basket2.sort()\n        if basket1 == basket2:\n            return 0\n        cost = 0\n        i = j = 0\n        n = len(basket1)\n        while i < n and j < n:\n            if basket1[i] < basket2[j]:\n                i += 1\n            elif basket1[i] > basket2[j]:\n                j += 1\n            else:\n                cost += basket1[i]\n                i += 1\n                j += 1\n        if i == n or j == n:\n            return -1\n        return cost\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        basket1.sort()\n        basket2.sort()\n        if basket1 == basket2:\n            return 0\n        cost = 0\n        i = j = 0\n        n = len(basket1)\n        while i < n and j < n:\n            if basket1[i] < basket2[j]:\n                i += 1\n            elif basket1[i] > basket2[j]:\n                j += 1\n            else:\n                cost += basket1[i]\n                i += 1\n                j += 1\n        if i == n or j == n:\n            return -1\n        return cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2560", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        def find_min_capability(start, k):\n            if k == 0:\n                return 0\n            if start >= len(nums):\n                return float('inf')\n            if (start, k) in memo:\n                return memo[(start, k)]\n            steal_this_house = nums[start] + find_min_capability(start + 2, k - 1)\n            skip_this_house = find_min_capability(start + 1, k)\n            memo[(start, k)] = min(steal_this_house, skip_this_house)\n            return memo[(start, k)]\n\n        memo = {}\n        return find_min_capability(0, k)\n```", "extracted_code": "\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        def find_min_capability(start, k):\n            if k == 0:\n                return 0\n            if start >= len(nums):\n                return float('inf')\n            if (start, k) in memo:\n                return memo[(start, k)]\n            steal_this_house = nums[start] + find_min_capability(start + 2, k - 1)\n            skip_this_house = find_min_capability(start + 1, k)\n            memo[(start, k)] = min(steal_this_house, skip_this_house)\n            return memo[(start, k)]\n\n        memo = {}\n        return find_min_capability(0, k)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2556", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        def dfs(r: int, c: int) -> bool:\n            if r == len(grid) - 1 and c == len(grid[0]) - 1:\n                return True\n            if r + 1 < len(grid) and grid[r + 1][c] == 1 and dfs(r + 1, c):\n                return True\n            if c + 1 < len(grid[0]) and grid[r][c + 1] == 1 and dfs(r, c + 1):\n                return True\n            return False\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == 0 and j == 0 or i == len(grid) - 1 and j == len(grid[0]) - 1:\n                    continue\n                temp = grid[i][j]\n                grid[i][j] = 1 - grid[i][j]\n                if not dfs(0, 0):\n                    return True\n                grid[i][j] = temp\n\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        def dfs(r: int, c: int) -> bool:\n            if r == len(grid) - 1 and c == len(grid[0]) - 1:\n                return True\n            if r + 1 < len(grid) and grid[r + 1][c] == 1 and dfs(r + 1, c):\n                return True\n            if c + 1 < len(grid[0]) and grid[r][c + 1] == 1 and dfs(r, c + 1):\n                return True\n            return False\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == 0 and j == 0 or i == len(grid) - 1 and j == len(grid[0]) - 1:\n                    continue\n                temp = grid[i][j]\n                grid[i][j] = 1 - grid[i][j]\n                if not dfs(0, 0):\n                    return True\n                grid[i][j] = temp\n\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2555", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        left = 0\n        right = 0\n        max_prizes = 0\n\n        while right < len(prizePositions):\n            if prizePositions[right] - prizePositions[left] <= k:\n                right += 1\n            else:\n                left_segment = right - left\n                right_segment = 0\n\n                while right < len(prizePositions) - 1 and prizePositions[right + 1] - prizePositions[right] <= k:\n                    right += 1\n                    right_segment += 1\n\n                max_prizes = max(max_prizes, left_segment + right_segment)\n                left += 1\n\n        return max_prizes\n```", "extracted_code": "\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        left = 0\n        right = 0\n        max_prizes = 0\n\n        while right < len(prizePositions):\n            if prizePositions[right] - prizePositions[left] <= k:\n                right += 1\n            else:\n                left_segment = right - left\n                right_segment = 0\n\n                while right < len(prizePositions) - 1 and prizePositions[right + 1] - prizePositions[right] <= k:\n                    right += 1\n                    right_segment += 1\n\n                max_prizes = max(max_prizes, left_segment + right_segment)\n                left += 1\n\n        return max_prizes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2554", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        count = 0\n        curr_sum = 0\n\n        for i in range(1, n + 1):\n            if i not in banned:\n                curr_sum += i\n                if curr_sum <= maxSum:\n                    count += 1\n                else:\n                    break\n\n        return count\n```", "extracted_code": "\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        count = 0\n        curr_sum = 0\n\n        for i in range(1, n + 1):\n            if i not in banned:\n                curr_sum += i\n                if curr_sum <= maxSum:\n                    count += 1\n                else:\n                    break\n\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2552", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n - 3):\n            for j in range(i + 1, n - 2):\n                for k in range(j + 1, n - 1):\n                    for l in range(k + 1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n - 3):\n            for j in range(i + 1, n - 2):\n                for k in range(j + 1, n - 1):\n                    for l in range(k + 1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2551", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        def min_score(weights, k):\n            if k == 1:\n                return sum(weights)\n            if k == len(weights):\n                return max(weights)\n            min_val = float('inf')\n            for i in range(1, len(weights) - k + 2):\n                min_val = min(min_val, min_score(weights[i:], k - 1))\n            return min_val + weights[0]\n        \n        def max_score(weights, k):\n            if k == 1:\n                return sum(weights)\n            if k == len(weights):\n                return max(weights)\n            max_val = float('-inf')\n            for i in range(1, len(weights) - k + 2):\n                max_val = max(max_val, max_score(weights[i:], k - 1))\n            return max_val + weights[0]\n\n        return max_score(weights, k) - min_score(weights, k)\n```", "extracted_code": "\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        def min_score(weights, k):\n            if k == 1:\n                return sum(weights)\n            if k == len(weights):\n                return max(weights)\n            min_val = float('inf')\n            for i in range(1, len(weights) - k + 2):\n                min_val = min(min_val, min_score(weights[i:], k - 1))\n            return min_val + weights[0]\n        \n        def max_score(weights, k):\n            if k == 1:\n                return sum(weights)\n            if k == len(weights):\n                return max(weights)\n            max_val = float('-inf')\n            for i in range(1, len(weights) - k + 2):\n                max_val = max(max_val, max_score(weights[i:], k - 1))\n            return max_val + weights[0]\n\n        return max_score(weights, k) - min_score(weights, k)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2550", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        def power(x: int, y: int) -> int:\n            result = 1\n            while y > 0:\n                if y % 2 == 1:\n                    result = (result * x) % MOD\n                y //= 2\n                x = (x * x) % MOD\n            return result\n        \n        return (power(2, n) - n - 1 + MOD) % MOD\n```", "extracted_code": "\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        def power(x: int, y: int) -> int:\n            result = 1\n            while y > 0:\n                if y % 2 == 1:\n                    result = (result * x) % MOD\n                y //= 2\n                x = (x * x) % MOD\n            return result\n        \n        return (power(2, n) - n - 1 + MOD) % MOD\n", "difficulty": 2.0}
{"task_id": "LeetCode/2547", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        def trimmed(subarray):\n            counts = {}\n            for num in subarray:\n                counts[num] = counts.get(num, 0) + 1\n            return [num for num in subarray if counts[num] > 1]\n\n        def importance_value(subarray):\n            return k + len(trimmed(subarray))\n\n        def split_cost(start):\n            if start == len(nums):\n                return 0\n            if start in memo:\n                return memo[start]\n            cost = float('inf')\n            for end in range(start + 1, len(nums) + 1):\n                cost = min(cost, importance_value(nums[start:end]) + split_cost(end))\n            memo[start] = cost\n            return cost\n\n        memo = {}\n        return split_cost(0)\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        def trimmed(subarray):\n            counts = {}\n            for num in subarray:\n                counts[num] = counts.get(num, 0) + 1\n            return [num for num in subarray if counts[num] > 1]\n\n        def importance_value(subarray):\n            return k + len(trimmed(subarray))\n\n        def split_cost(start):\n            if start == len(nums):\n                return 0\n            if start in memo:\n                return memo[start]\n            cost = float('inf')\n            for end in range(start + 1, len(nums) + 1):\n                cost = min(cost, importance_value(nums[start:end]) + split_cost(end))\n            memo[start] = cost\n            return cost\n\n        memo = {}\n        return split_cost(0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2546", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        s_ones, target_ones = s.count('1'), target.count('1')\n        return s_ones >= target_ones and (s_ones - target_ones) % 2 == 0\n```", "extracted_code": "\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        s_ones, target_ones = s.count('1'), target.count('1')\n        return s_ones >= target_ones and (s_ones - target_ones) % 2 == 0\n", "difficulty": 2.0}
{"task_id": "LeetCode/2545", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        score.sort(key=lambda x: x[k], reverse=True)\n        return score\n```", "extracted_code": "\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        score.sort(key=lambda x: x[k], reverse=True)\n        return score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2543", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        while targetX > 1 and targetY > 1:\n            if targetX > targetY:\n                targetX %= targetY\n            else:\n                targetY %= targetX\n        return (targetX == 1 and targetY > 1) or (targetY == 1 and targetX > 1)\n```", "extracted_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        while targetX > 1 and targetY > 1:\n            if targetX > targetY:\n                targetX %= targetY\n            else:\n                targetY %= targetX\n        return (targetX == 1 and targetY > 1) or (targetY == 1 and targetX > 1)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2538", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        from collections import defaultdict\n\n        def dfs(node, visited, total_cost):\n            nonlocal max_cost, min_cost\n            visited[node] = True\n            max_cost = max(max_cost, total_cost)\n            min_cost = min(min_cost, total_cost)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, visited, total_cost + price[neighbor])\n\n        graph = defaultdict(list)\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n\n        max_diff = 0\n        for i in range(n):\n            max_cost, min_cost = float('-inf'), float('inf')\n            visited = [False] * n\n            dfs(i, visited, price[i])\n            max_diff = max(max_diff, max_cost - min_cost)\n\n        return max_diff", "extracted_code": "class Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        from collections import defaultdict\n\n        def dfs(node, visited, total_cost):\n            nonlocal max_cost, min_cost\n            visited[node] = True\n            max_cost = max(max_cost, total_cost)\n            min_cost = min(min_cost, total_cost)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, visited, total_cost + price[neighbor])\n\n        graph = defaultdict(list)\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n\n        max_diff = 0\n        for i in range(n):\n            max_cost, min_cost = float('-inf'), float('inf')\n            visited = [False] * n\n            dfs(i, visited, price[i])\n            max_diff = max(max_diff, max_cost - min_cost)\n\n        return max_diff", "difficulty": 3.0}
{"task_id": "LeetCode/2532", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = [[i, time[i][0] + time[i][2]] for i in range(k)]\n        workers.sort(key=lambda x: (x[1], x[0]))\n        completed_boxes = 0\n        time_elapsed = 0\n        left_bank = []\n        right_bank = []\n\n        while completed_boxes < n:\n            while workers and (not right_bank or right_bank[0][1] > time_elapsed):\n                left_bank.append([workers[0][0], time_elapsed + workers[0][1]])\n                time_elapsed += workers[0][1]\n                workers.pop(0)\n\n            left_bank.sort(key=lambda x: x[1])\n            right_bank.sort(key=lambda x: x[1])\n\n            if right_bank and right_bank[0][1] <= time_elapsed:\n                completed_boxes += 1\n                time_elapsed += time[right_bank[0][0]][3]\n                right_bank.pop(0)\n            elif left_bank:\n                right_bank.append([left_bank[0][0], time_elapsed + time[left_bank[0][0]][1]])\n                time_elapsed += time[left_bank[0][0]][1]\n                left_bank.pop(0)\n\n        return time_elapsed\n```", "extracted_code": "\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = [[i, time[i][0] + time[i][2]] for i in range(k)]\n        workers.sort(key=lambda x: (x[1], x[0]))\n        completed_boxes = 0\n        time_elapsed = 0\n        left_bank = []\n        right_bank = []\n\n        while completed_boxes < n:\n            while workers and (not right_bank or right_bank[0][1] > time_elapsed):\n                left_bank.append([workers[0][0], time_elapsed + workers[0][1]])\n                time_elapsed += workers[0][1]\n                workers.pop(0)\n\n            left_bank.sort(key=lambda x: x[1])\n            right_bank.sort(key=lambda x: x[1])\n\n            if right_bank and right_bank[0][1] <= time_elapsed:\n                completed_boxes += 1\n                time_elapsed += time[right_bank[0][0]][3]\n                right_bank.pop(0)\n            elif left_bank:\n                right_bank.append([left_bank[0][0], time_elapsed + time[left_bank[0][0]][1]])\n                time_elapsed += time[left_bank[0][0]][1]\n                left_bank.pop(0)\n\n        return time_elapsed\n", "difficulty": 3.0}
{"task_id": "LeetCode/2531", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        distinct_word1 = len(set(word1))\n        distinct_word2 = len(set(word2))\n        \n        if abs(distinct_word1 - distinct_word2) > 1:\n            return False\n        \n        for i in range(len(word1)):\n            for j in range(len(word2)):\n                temp_word1 = list(word1)\n                temp_word2 = list(word2)\n                temp_word1[i], temp_word2[j] = temp_word2[j], temp_word1[i]\n                new_distinct_word1 = len(set(temp_word1))\n                new_distinct_word2 = len(set(temp_word2))\n                \n                if new_distinct_word1 == new_distinct_word2:\n                    return True\n                    \n        return False\n```", "extracted_code": "\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        distinct_word1 = len(set(word1))\n        distinct_word2 = len(set(word2))\n        \n        if abs(distinct_word1 - distinct_word2) > 1:\n            return False\n        \n        for i in range(len(word1)):\n            for j in range(len(word2)):\n                temp_word1 = list(word1)\n                temp_word2 = list(word2)\n                temp_word1[i], temp_word2[j] = temp_word2[j], temp_word1[i]\n                new_distinct_word1 = len(set(temp_word1))\n                new_distinct_word2 = len(set(temp_word2))\n                \n                if new_distinct_word1 == new_distinct_word2:\n                    return True\n                    \n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2528", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n        def count_power(i: int) -> int:\n            return prefix_sum[min(i + r + 1, n)] - prefix_sum[max(i - r, 0)]\n\n        low, high = 0, k + max(stations)\n        while low < high:\n            mid = (low + high + 1) // 2\n            required_stations = 0\n            for i in range(n):\n                diff = max(mid - count_power(i), 0)\n                required_stations += diff\n\n            if required_stations <= k:\n                low = mid\n            else:\n                high = mid - 1\n\n        return low\n```", "extracted_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n        def count_power(i: int) -> int:\n            return prefix_sum[min(i + r + 1, n)] - prefix_sum[max(i - r, 0)]\n\n        low, high = 0, k + max(stations)\n        while low < high:\n            mid = (low + high + 1) // 2\n            required_stations = 0\n            for i in range(n):\n                diff = max(mid - count_power(i), 0)\n                required_stations += diff\n\n            if required_stations <= k:\n                low = mid\n            else:\n                high = mid - 1\n\n        return low\n", "difficulty": 3.0}
{"task_id": "LeetCode/2523", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        min_gap = float(\"inf\")\n        ans = [-1, -1]\n\n        prev_prime = None\n        for num in range(left, right + 1):\n            if is_prime(num):\n                if prev_prime is not None:\n                    cur_gap = num - prev_prime\n                    if cur_gap < min_gap:\n                        min_gap = cur_gap\n                        ans = [prev_prime, num]\n                prev_prime = num\n\n        return ans\n```", "extracted_code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        min_gap = float(\"inf\")\n        ans = [-1, -1]\n\n        prev_prime = None\n        for num in range(left, right + 1):\n            if is_prime(num):\n                if prev_prime is not None:\n                    cur_gap = num - prev_prime\n                    if cur_gap < min_gap:\n                        min_gap = cur_gap\n                        ans = [prev_prime, num]\n                prev_prime = num\n\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2521", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        def prime_factors(n):\n            factors = set()\n            for i in range(2, n + 1):\n                if is_prime(i) and n % i == 0:\n                    factors.add(i)\n            return factors\n\n        all_factors = set()\n        for num in nums:\n            all_factors |= prime_factors(num)\n        return len(all_factors)\n```", "extracted_code": "\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        def prime_factors(n):\n            factors = set()\n            for i in range(2, n + 1):\n                if is_prime(i) and n % i == 0:\n                    factors.add(i)\n            return factors\n\n        all_factors = set()\n        for num in nums:\n            all_factors |= prime_factors(num)\n        return len(all_factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2518", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        from itertools import combinations\n        count = 0\n        mod = 10**9 + 7\n        \n        for i in range(1, len(nums)):\n            for combination in combinations(nums, i):\n                if sum(combination) >= k and sum(nums) - sum(combination) >= k:\n                    count += 1\n                    \n        return count % mod\n```", "extracted_code": "\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        from itertools import combinations\n        count = 0\n        mod = 10**9 + 7\n        \n        for i in range(1, len(nums)):\n            for combination in combinations(nums, i):\n                if sum(combination) >= k and sum(nums) - sum(combination) >= k:\n                    count += 1\n                    \n        return count % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2517", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        result = 0\n        for i in range(len(price) - k + 1):\n            local_diff = float('inf')\n            for j in range(i + 1, i + k):\n                local_diff = min(local_diff, price[j] - price[j - 1])\n            result = max(result, local_diff)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        result = 0\n        for i in range(len(price) - k + 1):\n            local_diff = float('inf')\n            for j in range(i + 1, i + k):\n                local_diff = min(local_diff, price[j] - price[j - 1])\n            result = max(result, local_diff)\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2516", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        if k == 0:\n            return 0\n        \n        n = len(s)\n        a_count = [0] * (n + 1)\n        b_count = [0] * (n + 1)\n        c_count = [0] * (n + 1)\n\n        for i in range(n):\n            a_count[i + 1] = a_count[i] + int(s[i] == 'a')\n            b_count[i + 1] = b_count[i] + int(s[i] == 'b')\n            c_count[i + 1] = c_count[i] + int(s[i] == 'c')\n\n        min_minutes = n\n        for i in range(n + 1):\n            j = n\n            while j >= 0 and (a_count[i] < k or b_count[j] < k or c_count[n - (i + j)] < k):\n                j -= 1\n            if j >= 0:\n                min_minutes = min(min_minutes, i + j)\n\n        return min_minutes if min_minutes != n else -1\n```", "extracted_code": "\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        if k == 0:\n            return 0\n        \n        n = len(s)\n        a_count = [0] * (n + 1)\n        b_count = [0] * (n + 1)\n        c_count = [0] * (n + 1)\n\n        for i in range(n):\n            a_count[i + 1] = a_count[i] + int(s[i] == 'a')\n            b_count[i + 1] = b_count[i] + int(s[i] == 'b')\n            c_count[i + 1] = c_count[i] + int(s[i] == 'c')\n\n        min_minutes = n\n        for i in range(n + 1):\n            j = n\n            while j >= 0 and (a_count[i] < k or b_count[j] < k or c_count[n - (i + j)] < k):\n                j -= 1\n            if j >= 0:\n                min_minutes = min(min_minutes, i + j)\n\n        return min_minutes if min_minutes != n else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2514", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from math import factorial\n\n        def count_perms(word):\n            freq = [0] * 26\n            for c in word:\n                freq[ord(c) - ord('a')] += 1\n            res = factorial(len(word))\n            for f in freq:\n                res //= factorial(f)\n            return res\n\n        words = s.split()\n        res = 1\n        MOD = 10**9 + 7\n        for word in words:\n            res *= count_perms(word)\n            res %= MOD\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from math import factorial\n\n        def count_perms(word):\n            freq = [0] * 26\n            for c in word:\n                freq[ord(c) - ord('a')] += 1\n            res = factorial(len(word))\n            for f in freq:\n                res //= factorial(f)\n            return res\n\n        words = s.split()\n        res = 1\n        MOD = 10**9 + 7\n        for word in words:\n            res *= count_perms(word)\n            res %= MOD\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2513", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        i = 1\n        cnt1, cnt2 = 0, 0\n        \n        while cnt1 < uniqueCnt1 or cnt2 < uniqueCnt2:\n            if i % divisor1 != 0 and cnt1 < uniqueCnt1:\n                cnt1 += 1\n            elif i % divisor2 != 0 and cnt2 < uniqueCnt2:\n                cnt2 += 1\n            i += 1\n        \n        return i - 1\n```", "extracted_code": "\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        i = 1\n        cnt1, cnt2 = 0, 0\n        \n        while cnt1 < uniqueCnt1 or cnt2 < uniqueCnt2:\n            if i % divisor1 != 0 and cnt1 < uniqueCnt1:\n                cnt1 += 1\n            elif i % divisor2 != 0 and cnt2 < uniqueCnt2:\n                cnt2 += 1\n            i += 1\n        \n        return i - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2512", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        student_points = {}\n        \n        for idx, feedback in enumerate(report):\n            points = 0\n            words = feedback.split()\n            for word in words:\n                if word in positive_feedback:\n                    points += 3\n                elif word in negative_feedback:\n                    points -= 1\n            student_points[student_id[idx]] = points\n        \n        sorted_students = sorted(student_points.items(), key=lambda x: (-x[1], x[0]))\n        top_k_students = [student[0] for student in sorted_students[:k]]\n        \n        return top_k_students\n```", "extracted_code": "\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        student_points = {}\n        \n        for idx, feedback in enumerate(report):\n            points = 0\n            words = feedback.split()\n            for word in words:\n                if word in positive_feedback:\n                    points += 3\n                elif word in negative_feedback:\n                    points -= 1\n            student_points[student_id[idx]] = points\n        \n        sorted_students = sorted(student_points.items(), key=lambda x: (-x[1], x[0]))\n        top_k_students = [student[0] for student in sorted_students[:k]]\n        \n        return top_k_students\n", "difficulty": 2.0}
{"task_id": "LeetCode/2509", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_depth(val: int) -> int:\n            depth = 0\n            while val != 1:\n                val = val // 2\n                depth += 1\n            return depth\n\n        answer = []\n        for a, b in queries:\n            depth_a = find_depth(a)\n            depth_b = find_depth(b)\n\n            while depth_a > depth_b:\n                a = a // 2\n                depth_a -= 1\n\n            while depth_b > depth_a:\n                b = b // 2\n                depth_b -= 1\n\n            while a != b:\n                a = a // 2\n                b = b // 2\n                depth_a -= 1\n                depth_b -= 1\n\n            answer.append(depth_a + depth_b)\n        return answer", "extracted_code": "class Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_depth(val: int) -> int:\n            depth = 0\n            while val != 1:\n                val = val // 2\n                depth += 1\n            return depth\n\n        answer = []\n        for a, b in queries:\n            depth_a = find_depth(a)\n            depth_b = find_depth(b)\n\n            while depth_a > depth_b:\n                a = a // 2\n                depth_a -= 1\n\n            while depth_b > depth_a:\n                b = b // 2\n                depth_b -= 1\n\n            while a != b:\n                a = a // 2\n                b = b // 2\n                depth_a -= 1\n                depth_b -= 1\n\n            answer.append(depth_a + depth_b)\n        return answer", "difficulty": 3.0}
{"task_id": "LeetCode/2508", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degrees = [0] * (n + 1)\n        for a, b in edges:\n            degrees[a] += 1\n            degrees[b] += 1\n            \n        odd_degrees = [x for x in degrees if x % 2 == 1]\n        \n        if len(odd_degrees) == 0:\n            return True\n        elif len(odd_degrees) == 2:\n            return True\n        elif len(odd_degrees) == 4:\n            return True\n        else:\n            return False\n```", "extracted_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degrees = [0] * (n + 1)\n        for a, b in edges:\n            degrees[a] += 1\n            degrees[b] += 1\n            \n        odd_degrees = [x for x in degrees if x % 2 == 1]\n        \n        if len(odd_degrees) == 0:\n            return True\n        elif len(odd_degrees) == 2:\n            return True\n        elif len(odd_degrees) == 4:\n            return True\n        else:\n            return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2507", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(num):\n            factors = []\n            while num % 2 == 0:\n                factors.append(2)\n                num //= 2\n            for i in range(3, int(num**0.5)+1, 2):\n                while num % i == 0:\n                    factors.append(i)\n                    num //= i\n            if num > 2:\n                factors.append(num)\n            return factors\n        \n        while True:\n            factors_sum = sum(prime_factors(n))\n            if n == factors_sum:\n                return n\n            n = factors_sum\n```", "extracted_code": "\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(num):\n            factors = []\n            while num % 2 == 0:\n                factors.append(2)\n                num //= 2\n            for i in range(3, int(num**0.5)+1, 2):\n                while num % i == 0:\n                    factors.append(i)\n                    num //= i\n            if num > 2:\n                factors.append(num)\n            return factors\n        \n        while True:\n            factors_sum = sum(prime_factors(n))\n            if n == factors_sum:\n                return n\n            n = factors_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2503", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        def dfs(x: int, y: int, threshold: int, visited: set) -> int:\n            if (x, y) in visited or not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or grid[x][y] >= threshold:\n                return 0\n            visited.add((x, y))\n            points = 1\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                points += dfs(x + dx, y + dy, threshold, visited)\n            return points\n\n        answer = []\n        for query in queries:\n            visited = set()\n            answer.append(dfs(0, 0, query, visited))\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        def dfs(x: int, y: int, threshold: int, visited: set) -> int:\n            if (x, y) in visited or not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or grid[x][y] >= threshold:\n                return 0\n            visited.add((x, y))\n            points = 1\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                points += dfs(x + dx, y + dy, threshold, visited)\n            return points\n\n        answer = []\n        for query in queries:\n            visited = set()\n            answer.append(dfs(0, 0, query, visited))\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2501", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        square_roots = {}\n        max_length = 0\n        for num in nums:\n            square_roots[num] = square_roots.get(num // 2, 0) + 1\n            max_length = max(max_length, square_roots[num])\n        return max_length if max_length > 1 else -1\n```", "extracted_code": "\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        square_roots = {}\n        max_length = 0\n        for num in nums:\n            square_roots[num] = square_roots.get(num // 2, 0) + 1\n            max_length = max(max_length, square_roots[num])\n        return max_length if max_length > 1 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2499", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        cost = 0\n        for i, num in enumerate(nums1):\n            if num == nums2[i]:\n                min_cost = float('inf')\n                for j in range(i + 1, len(nums1)):\n                    if nums1[j] != nums2[i] and nums1[j] != nums2[j]:\n                        cost_temp = i + j\n                        if cost_temp < min_cost:\n                            min_cost = cost_temp\n                            swap_index = j\n                if min_cost == float('inf'):\n                    return -1\n                nums1[i], nums1[swap_index] = nums1[swap_index], nums1[i]\n                cost += min_cost\n        return cost\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        cost = 0\n        for i, num in enumerate(nums1):\n            if num == nums2[i]:\n                min_cost = float('inf')\n                for j in range(i + 1, len(nums1)):\n                    if nums1[j] != nums2[i] and nums1[j] != nums2[j]:\n                        cost_temp = i + j\n                        if cost_temp < min_cost:\n                            min_cost = cost_temp\n                            swap_index = j\n                if min_cost == float('inf'):\n                    return -1\n                nums1[i], nums1[swap_index] = nums1[swap_index], nums1[i]\n                cost += min_cost\n        return cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2498", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        min_cost = float('inf')\n\n        for i in range(1, n):\n            cost = max(stones[i] - stones[0], stones[n - 1] - stones[i])\n            min_cost = min(min_cost, cost)\n\n        return min_cost\n```", "extracted_code": "\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        min_cost = float('inf')\n\n        for i in range(1, n):\n            cost = max(stones[i] - stones[0], stones[n - 1] - stones[i])\n            min_cost = min(min_cost, cost)\n\n        return min_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2497", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        from collections import defaultdict\n        \n        adj_list = defaultdict(list)\n        \n        for a, b in edges:\n            adj_list[a].append(b)\n            adj_list[b].append(a)\n\n        max_sum = float('-inf')\n        for center in range(len(vals)):\n            neighbors = sorted(adj_list[center], key=lambda x: vals[x], reverse=True)\n            cur_sum = vals[center] + sum([vals[neighbor] for neighbor in neighbors[:k]])\n            max_sum = max(max_sum, cur_sum)\n        \n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        from collections import defaultdict\n        \n        adj_list = defaultdict(list)\n        \n        for a, b in edges:\n            adj_list[a].append(b)\n            adj_list[b].append(a)\n\n        max_sum = float('-inf')\n        for center in range(len(vals)):\n            neighbors = sorted(adj_list[center], key=lambda x: vals[x], reverse=True)\n            cur_sum = vals[center] + sum([vals[neighbor] for neighbor in neighbors[:k]])\n            max_sum = max(max_sum, cur_sum)\n        \n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2493", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node, group):\n            if node in visited:\n                return visited[node] == group\n            visited[node] = group\n            for neighbor in graph[node]:\n                if not dfs(neighbor, group ^ 1):\n                    return False\n            return True\n        \n        graph = defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        \n        visited = {}\n        for node in range(1, n + 1):\n            if node not in visited and not dfs(node, 0):\n                return -1\n        \n        return max(visited.values()) + 1\n```", "extracted_code": "\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node, group):\n            if node in visited:\n                return visited[node] == group\n            visited[node] = group\n            for neighbor in graph[node]:\n                if not dfs(neighbor, group ^ 1):\n                    return False\n            return True\n        \n        graph = defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        \n        visited = {}\n        for node in range(1, n + 1):\n            if node not in visited and not dfs(node, 0):\n                return -1\n        \n        return max(visited.values()) + 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2488", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                subarray = nums[i:j]\n                subarray.sort()\n                if len(subarray) % 2 == 0:\n                    median = subarray[len(subarray) // 2 - 1]\n                else:\n                    median = subarray[len(subarray) // 2]\n                if median == k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                subarray = nums[i:j]\n                subarray.sort()\n                if len(subarray) % 2 == 0:\n                    median = subarray[len(subarray) // 2 - 1]\n                else:\n                    median = subarray[len(subarray) // 2]\n                if median == k:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2487", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        max_val = -1\n        current = head\n        prev = None\n\n        while current:\n            if current.val > max_val:\n                max_val = current.val\n                if prev:\n                    prev.next = current\n                else:\n                    head = current\n                prev = current\n            current = current.next\n\n        if prev:\n            prev.next = None\n\n        return head\n```", "extracted_code": "\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        max_val = -1\n        current = head\n        prev = None\n\n        while current:\n            if current.val > max_val:\n                max_val = current.val\n                if prev:\n                    prev.next = current\n                else:\n                    head = current\n                prev = current\n            current = current.next\n\n        if prev:\n            prev.next = None\n\n        return head\n", "difficulty": 2.0}
{"task_id": "LeetCode/2484", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        count = [0] * 10\n        dp = [[0] * 10 for _ in range(n)]\n        \n        for i in range(n):\n            count[int(s[i])] += 1\n            for j in range(10):\n                dp[i][j] = count[j]\n        \n        count = [0] * 10\n        for i in range(n - 1, -1, -1):\n            count[int(s[i])] += 1\n            for j in range(10):\n                dp[i][j] = (dp[i][j] * count[j]) % mod\n        \n        res = sum(dp[i][j] for i in range(n) for j in range(10)) % mod\n        return (res - n * (n - 1) // 2) % mod\n```", "extracted_code": "\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        count = [0] * 10\n        dp = [[0] * 10 for _ in range(n)]\n        \n        for i in range(n):\n            count[int(s[i])] += 1\n            for j in range(10):\n                dp[i][j] = count[j]\n        \n        count = [0] * 10\n        for i in range(n - 1, -1, -1):\n            count[int(s[i])] += 1\n            for j in range(10):\n                dp[i][j] = (dp[i][j] * count[j]) % mod\n        \n        res = sum(dp[i][j] for i in range(n) for j in range(10)) % mod\n        return (res - n * (n - 1) // 2) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2483", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        penalty = [0] * (n + 1)\n        opened = 0\n        closed = customers.count('Y')\n        \n        for j in range(n + 1):\n            penalty[j] = opened + closed\n            if j < n:\n                if customers[j] == 'Y':\n                    closed -= 1\n                else:\n                    opened += 1\n        return penalty.index(min(penalty))\n```", "extracted_code": "\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        penalty = [0] * (n + 1)\n        opened = 0\n        closed = customers.count('Y')\n        \n        for j in range(n + 1):\n            penalty[j] = opened + closed\n            if j < n:\n                if customers[j] == 'Y':\n                    closed -= 1\n                else:\n                    opened += 1\n        return penalty.index(min(penalty))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2482", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow = [sum(row) for row in grid]\n        onesCol = [sum(grid[i][j] for i in range(m)) for j in range(n)]\n        zerosRow = [n - ones for ones in onesRow]\n        zerosCol = [m - ones for ones in onesCol]\n\n        diff = [[onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j] for j in range(n)] for i in range(m)]\n        return diff", "extracted_code": "class Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow = [sum(row) for row in grid]\n        onesCol = [sum(grid[i][j] for i in range(m)) for j in range(n)]\n        zerosRow = [n - ones for ones in onesRow]\n        zerosCol = [m - ones for ones in onesCol]\n\n        diff = [[onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j] for j in range(n)] for i in range(m)]\n        return diff", "difficulty": 2.0}
{"task_id": "LeetCode/2481", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n == 1:\n            return 0\n        elif n % 2 == 0:\n            return n // 2\n        else:\n            return n\n```", "extracted_code": "\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n == 1:\n            return 0\n        elif n % 2 == 0:\n            return n // 2\n        else:\n            return n\n", "difficulty": 1.0}
{"task_id": "LeetCode/2478", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        def is_prime(digit):\n            return digit in {'2', '3', '5', '7'}\n\n        def is_non_prime(digit):\n            return digit in {'1', '4', '6', '8', '9'}\n\n        n = len(s)\n        mod = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                for l in range(minLength, i + 1):\n                    if is_prime(s[i - l]) and is_non_prime(s[i - 1]):\n                        dp[i][j] = (dp[i][j] + dp[i - l][j - 1]) % mod\n\n        return dp[n][k]", "extracted_code": "class Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        def is_prime(digit):\n            return digit in {'2', '3', '5', '7'}\n\n        def is_non_prime(digit):\n            return digit in {'1', '4', '6', '8', '9'}\n\n        n = len(s)\n        mod = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                for l in range(minLength, i + 1):\n                    if is_prime(s[i - l]) and is_non_prime(s[i - 1]):\n                        dp[i][j] = (dp[i][j] + dp[i - l][j - 1]) % mod\n\n        return dp[n][k]", "difficulty": 3.0}
{"task_id": "LeetCode/2476", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def search(node, query):\n            if node is None:\n                return [-1, -1]\n            if query == node.val:\n                return [query, query]\n            elif query < node.val:\n                left_min, left_max = search(node.left, query)\n                if left_max == -1:\n                    left_max = node.val\n                return [left_min, left_max]\n            else:\n                right_min, right_max = search(node.right, query)\n                if right_min == -1:\n                    right_min = node.val\n                return [right_min, right_max]\n\n        return [search(root, query) for query in queries]\n```", "extracted_code": "\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def search(node, query):\n            if node is None:\n                return [-1, -1]\n            if query == node.val:\n                return [query, query]\n            elif query < node.val:\n                left_min, left_max = search(node.left, query)\n                if left_max == -1:\n                    left_max = node.val\n                return [left_min, left_max]\n            else:\n                right_min, right_max = search(node.right, query)\n                if right_min == -1:\n                    right_min = node.val\n                return [right_min, right_max]\n\n        return [search(root, query) for query in queries]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2472", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        def is_palindrome(subs: str) -> bool:\n            return subs == subs[::-1]\n\n        def helper(start: int) -> int:\n            if start >= len(s):\n                return 0\n            max_count = 0\n            for end in range(start + k - 1, len(s)):\n                if is_palindrome(s[start:end + 1]):\n                    max_count = max(max_count, 1 + helper(end + 1))\n            return max_count\n\n        return helper(0)\n```", "extracted_code": "\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        def is_palindrome(subs: str) -> bool:\n            return subs == subs[::-1]\n\n        def helper(start: int) -> int:\n            if start >= len(s):\n                return 0\n            max_count = 0\n            for end in range(start + k - 1, len(s)):\n                if is_palindrome(s[start:end + 1]):\n                    max_count = max(max_count, 1 + helper(end + 1))\n            return max_count\n\n        return helper(0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2471", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        from collections import deque\n        \n        def bfs():\n            q = deque([(root, 0)])\n            levels = {}\n            while q:\n                node, level = q.popleft()\n                if level in levels:\n                    levels[level].append(node.val)\n                else:\n                    levels[level] = [node.val]\n                if node.left:\n                    q.append((node.left, level + 1))\n                if node.right:\n                    q.append((node.right, level + 1))\n            return levels\n        \n        levels = bfs()\n        operations = 0\n        \n        for k in levels:\n            level_values = sorted(levels[k])\n            idx = 0\n            for val in levels[k]:\n                if val != level_values[idx]:\n                    operations += 1\n                idx += 1\n                \n        return operations // 2\n```", "extracted_code": "\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        from collections import deque\n        \n        def bfs():\n            q = deque([(root, 0)])\n            levels = {}\n            while q:\n                node, level = q.popleft()\n                if level in levels:\n                    levels[level].append(node.val)\n                else:\n                    levels[level] = [node.val]\n                if node.left:\n                    q.append((node.left, level + 1))\n                if node.right:\n                    q.append((node.right, level + 1))\n            return levels\n        \n        levels = bfs()\n        operations = 0\n        \n        for k in levels:\n            level_values = sorted(levels[k])\n            idx = 0\n            for val in levels[k]:\n                if val != level_values[idx]:\n                    operations += 1\n                idx += 1\n                \n        return operations // 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2470", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def lcm(x, y):\n            return x * y // gcd(x, y)\n        \n        count = 0\n        for i in range(len(nums)):\n            current_lcm = 1\n            for j in range(i, len(nums)):\n                current_lcm = lcm(current_lcm, nums[j])\n                if current_lcm == k:\n                    count += 1\n                elif current_lcm > k:\n                    break\n        return count\n```", "extracted_code": "\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def lcm(x, y):\n            return x * y // gcd(x, y)\n        \n        count = 0\n        for i in range(len(nums)):\n            current_lcm = 1\n            for j in range(i, len(nums)):\n                current_lcm = lcm(current_lcm, nums[j])\n                if current_lcm == k:\n                    count += 1\n                elif current_lcm > k:\n                    break\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2468", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        if limit < 5:\n            return []\n        \n        suffix_length = 5\n        chunk_size = limit - suffix_length\n        parts = []\n        total_parts = (len(message) + chunk_size - 1) // chunk_size\n\n        for i in range(total_parts):\n            start = i * chunk_size\n            end = min(start + chunk_size, len(message))\n            part_suffix = \"<{}/{}>\".format(i + 1, total_parts)\n            part = message[start:end] + part_suffix\n            parts.append(part)\n\n        return parts\n```", "extracted_code": "\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        if limit < 5:\n            return []\n        \n        suffix_length = 5\n        chunk_size = limit - suffix_length\n        parts = []\n        total_parts = (len(message) + chunk_size - 1) // chunk_size\n\n        for i in range(total_parts):\n            start = i * chunk_size\n            end = min(start + chunk_size, len(message))\n            part_suffix = \"<{}/{}>\".format(i + 1, total_parts)\n            part = message[start:end] + part_suffix\n            parts.append(part)\n\n        return parts\n", "difficulty": 3.0}
{"task_id": "LeetCode/2466", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        \n        def ways_to_construct(length: int, repeat: int) -> int:\n            return max(0, (length + repeat - 1) // repeat)\n        \n        count = 0\n        for length in range(low, high + 1):\n            count += ways_to_construct(length, zero) * ways_to_construct(length, one)\n            count %= MOD\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        \n        def ways_to_construct(length: int, repeat: int) -> int:\n            return max(0, (length + repeat - 1) // repeat)\n        \n        count = 0\n        for length in range(low, high + 1):\n            count += ways_to_construct(length, zero) * ways_to_construct(length, one)\n            count %= MOD\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2463", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort()\n        factory_left = [f[1] for f in factory]\n        distances = [0] * len(robot)\n        i, j = 0, 0\n\n        while i < len(robot) and j < len(factory):\n            if robot[i] <= factory[j][0]:\n                if factory_left[j] > 0:\n                    distances[i] = abs(robot[i] - factory[j][0])\n                    factory_left[j] -= 1\n                    i += 1\n                else:\n                    j += 1\n            else:\n                j += 1\n\n        i, j = len(robot) - 1, len(factory) - 1\n        while i >= 0 and j >= 0:\n            if robot[i] >= factory[j][0]:\n                if factory_left[j] > 0:\n                    new_distance = abs(robot[i] - factory[j][0])\n                    if distances[i] == 0 or new_distance < distances[i]:\n                        distances[i] = new_distance\n                    factory_left[j] -= 1\n                    i -= 1\n                else:\n                    j -= 1\n            else:\n                j -= 1\n\n        return sum(distances)\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort()\n        factory_left = [f[1] for f in factory]\n        distances = [0] * len(robot)\n        i, j = 0, 0\n\n        while i < len(robot) and j < len(factory):\n            if robot[i] <= factory[j][0]:\n                if factory_left[j] > 0:\n                    distances[i] = abs(robot[i] - factory[j][0])\n                    factory_left[j] -= 1\n                    i += 1\n                else:\n                    j += 1\n            else:\n                j += 1\n\n        i, j = len(robot) - 1, len(factory) - 1\n        while i >= 0 and j >= 0:\n            if robot[i] >= factory[j][0]:\n                if factory_left[j] > 0:\n                    new_distance = abs(robot[i] - factory[j][0])\n                    if distances[i] == 0 or new_distance < distances[i]:\n                        distances[i] = new_distance\n                    factory_left[j] -= 1\n                    i -= 1\n                else:\n                    j -= 1\n            else:\n                j -= 1\n\n        return sum(distances)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2462", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        total_cost = 0\n        for _ in range(k):\n            min_cost = float('inf')\n            min_index = -1\n            for i in range(min(candidates, len(costs))):\n                if costs[i] < min_cost:\n                    min_cost = costs[i]\n                    min_index = i\n            for i in range(len(costs) - 1, max(len(costs) - 1 - candidates, -1), -1):\n                if costs[i] < min_cost:\n                    min_cost = costs[i]\n                    min_index = i\n            total_cost += min_cost\n            costs.pop(min_index)\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        total_cost = 0\n        for _ in range(k):\n            min_cost = float('inf')\n            min_index = -1\n            for i in range(min(candidates, len(costs))):\n                if costs[i] < min_cost:\n                    min_cost = costs[i]\n                    min_index = i\n            for i in range(len(costs) - 1, max(len(costs) - 1 - candidates, -1), -1):\n                if costs[i] < min_cost:\n                    min_cost = costs[i]\n                    min_index = i\n            total_cost += min_cost\n            costs.pop(min_index)\n        return total_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2461", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2458", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def getHeight(node):\n            if not node:\n                return 0\n            return 1 + max(getHeight(node.left), getHeight(node.right))\n        \n        def removeSubtree(node, value):\n            if not node:\n                return None\n            if node.val == value:\n                return None\n            node.left = removeSubtree(node.left, value)\n            node.right = removeSubtree(node.right, value)\n            return node\n        \n        answer = []\n        for query in queries:\n            newRoot = removeSubtree(root, query)\n            answer.append(getHeight(newRoot) - 1)\n        \n        return answer\n```", "extracted_code": "\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def getHeight(node):\n            if not node:\n                return 0\n            return 1 + max(getHeight(node.left), getHeight(node.right))\n        \n        def removeSubtree(node, value):\n            if not node:\n                return None\n            if node.val == value:\n                return None\n            node.left = removeSubtree(node.left, value)\n            node.right = removeSubtree(node.right, value)\n            return node\n        \n        answer = []\n        for query in queries:\n            newRoot = removeSubtree(root, query)\n            answer.append(getHeight(newRoot) - 1)\n        \n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2457", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        def digit_sum(num):\n            return sum(int(d) for d in str(num))\n\n        x = 0\n        while digit_sum(n + x) > target:\n            x += 1\n        return x\n```", "extracted_code": "\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        def digit_sum(num):\n            return sum(int(d) for d in str(num))\n\n        x = 0\n        while digit_sum(n + x) > target:\n            x += 1\n        return x\n", "difficulty": 2.0}
{"task_id": "LeetCode/2455", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if len(even_divisible_by_3) == 0:\n            return 0\n        else:\n            return sum(even_divisible_by_3) // len(even_divisible_by_3)\n```", "extracted_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if len(even_divisible_by_3) == 0:\n            return 0\n        else:\n            return sum(even_divisible_by_3) // len(even_divisible_by_3)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2454", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        answer = [-1] * len(nums)\n\n        for i in range(len(nums)):\n            while stack and nums[i] > nums[stack[-1]]:\n                index = stack.pop()\n                if answer[index] == -1:\n                    answer[index] = nums[i]\n            stack.append(i)\n\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        answer = [-1] * len(nums)\n\n        for i in range(len(nums)):\n            while stack and nums[i] > nums[stack[-1]]:\n                index = stack.pop()\n                if answer[index] == -1:\n                    answer[index] = nums[i]\n            stack.append(i)\n\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2449", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        diff = sum((a - b) % 2 for a, b in zip(nums, target)) // 2\n        return diff\n```", "extracted_code": "\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        diff = sum((a - b) % 2 for a, b in zip(nums, target)) // 2\n        return diff\n", "difficulty": 3.0}
{"task_id": "LeetCode/2448", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        min_cost = float(\"inf\")\n        min_num, max_num = min(nums), max(nums)\n        \n        for target in range(min_num, max_num + 1):\n            temp_cost = 0\n            for i in range(len(nums)):\n                temp_cost += abs(nums[i] - target) * cost[i]\n            min_cost = min(min_cost, temp_cost)\n        \n        return min_cost\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        min_cost = float(\"inf\")\n        min_num, max_num = min(nums), max(nums)\n        \n        for target in range(min_num, max_num + 1):\n            temp_cost = 0\n            for i in range(len(nums)):\n                temp_cost += abs(nums[i] - target) * cost[i]\n            min_cost = min(min_cost, temp_cost)\n        \n        return min_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2444", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        left = right = 0\n        count = min_count = max_count = 0\n\n        for num in nums:\n            if num <= maxK:\n                max_count += 1\n                right = max_count\n            else:\n                max_count = 0\n\n            if num < minK:\n                min_count += 1\n                left = min_count\n            else:\n                min_count = 0\n\n            count += right - left\n\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        left = right = 0\n        count = min_count = max_count = 0\n\n        for num in nums:\n            if num <= maxK:\n                max_count += 1\n                right = max_count\n            else:\n                max_count = 0\n\n            if num < minK:\n                min_count += 1\n                left = min_count\n            else:\n                min_count = 0\n\n            count += right - left\n\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2443", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        for i in range(num + 1):\n            reverse_i = int(str(i)[::-1])\n            if i + reverse_i == num:\n                return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        for i in range(num + 1):\n            reverse_i = int(str(i)[::-1])\n            if i + reverse_i == num:\n                return True\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2442", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        distinct_integers = set(nums)\n        for num in nums:\n            reversed_num = int(str(num)[::-1])\n            distinct_integers.add(reversed_num)\n        return len(distinct_integers)\n```", "extracted_code": "\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        distinct_integers = set(nums)\n        for num in nums:\n            reversed_num = int(str(num)[::-1])\n            distinct_integers.add(reversed_num)\n        return len(distinct_integers)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2440", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node, parent):\n            total = nums[node]\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    total += dfs(neighbor, node)\n            if total == target:\n                nonlocal result\n                result += 1\n                return 0\n            return total\n        \n        graph = defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        target = sum(nums) // 2\n        result = 0\n        dfs(0, -1)\n        return result - 1 if result > 0 else 0\n```", "extracted_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node, parent):\n            total = nums[node]\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    total += dfs(neighbor, node)\n            if total == target:\n                nonlocal result\n                result += 1\n                return 0\n            return total\n        \n        graph = defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        target = sum(nums) // 2\n        result = 0\n        dfs(0, -1)\n        return result - 1 if result > 0 else 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2438", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_powers(n):\n            powers = []\n            while n:\n                power = 2 ** (n.bit_length() - 1)\n                powers.append(power)\n                n -= power\n            return powers\n\n        powers = find_powers(n)\n        mod = 10**9 + 7\n        answers = []\n\n        for left, right in queries:\n            product = 1\n            for i in range(left, right + 1):\n                product = (product * powers[i]) % mod\n            answers.append(product)\n\n        return answers\n```", "extracted_code": "\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_powers(n):\n            powers = []\n            while n:\n                power = 2 ** (n.bit_length() - 1)\n                powers.append(power)\n                n -= power\n            return powers\n\n        powers = find_powers(n)\n        mod = 10**9 + 7\n        answers = []\n\n        for left, right in queries:\n            product = 1\n            for i in range(left, right + 1):\n                product = (product * powers[i]) % mod\n            answers.append(product)\n\n        return answers\n", "difficulty": 2.0}
{"task_id": "LeetCode/2435", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[[0] * k for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0] % k] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                for r in range(k):\n                    if i > 0:\n                        dp[i][j][r] = (dp[i][j][r] + dp[i-1][j][(r - grid[i][j]) % k]) % mod\n                    if j > 0:\n                        dp[i][j][r] = (dp[i][j][r] + dp[i][j-1][(r - grid[i][j]) % k]) % mod\n                        \n        return dp[m-1][n-1][0]\n```", "extracted_code": "\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[[0] * k for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0] % k] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                for r in range(k):\n                    if i > 0:\n                        dp[i][j][r] = (dp[i][j][r] + dp[i-1][j][(r - grid[i][j]) % k]) % mod\n                    if j > 0:\n                        dp[i][j][r] = (dp[i][j][r] + dp[i][j-1][(r - grid[i][j]) % k]) % mod\n                        \n        return dp[m-1][n-1][0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2434", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t, paper = \"\", \"\"\n        while s or t:\n            while s and (not t or s[0] <= t[-1]):\n                t, s = t + s[0], s[1:]\n            paper, t = paper + t[-1], t[:-1]\n        return paper\n```", "extracted_code": "\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t, paper = \"\", \"\"\n        while s or t:\n            while s and (not t or s[0] <= t[-1]):\n                t, s = t + s[0], s[1:]\n            paper, t = paper + t[-1], t[:-1]\n        return paper\n", "difficulty": 2.0}
{"task_id": "LeetCode/2432", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        task_times = [logs[i][1] - logs[i - 1][1] if i > 0 else logs[0][1] for i in range(len(logs))]\n        max_time = max(task_times)\n        max_index = task_times.index(max_time)\n        return logs[max_index][0]\n```", "extracted_code": "\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        task_times = [logs[i][1] - logs[i - 1][1] if i > 0 else logs[0][1] for i in range(len(logs))]\n        max_time = max(task_times)\n        max_index = task_times.index(max_time)\n        return logs[max_index][0]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2430", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def deleteString(self, s: str) -> int:\n        def helper(s: str) -> int:\n            n = len(s)\n            for i in range(n // 2, 0, -1):\n                if s[:i] == s[i:i * 2]:\n                    return 1 + helper(s[i:])\n            return 0\n\n        return helper(s)", "extracted_code": "class Solution:\n    def deleteString(self, s: str) -> int:\n        def helper(s: str) -> int:\n            n = len(s)\n            for i in range(n // 2, 0, -1):\n                if s[:i] == s[i:i * 2]:\n                    return 1 + helper(s[i:])\n            return 0\n\n        return helper(s)", "difficulty": 3.0}
{"task_id": "LeetCode/2429", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        set_bits_num2 = bin(num2).count('1')\n        x = 0\n        \n        while bin(x).count('1') != set_bits_num2:\n            x += 1\n            \n        while True:\n            if bin(x ^ num1).count('1') == set_bits_num2:\n                return x\n            x += 1\n```", "extracted_code": "\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        set_bits_num2 = bin(num2).count('1')\n        x = 0\n        \n        while bin(x).count('1') != set_bits_num2:\n            x += 1\n            \n        while True:\n            if bin(x ^ num1).count('1') == set_bits_num2:\n                return x\n            x += 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2427", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        count = 0\n        for i in range(1, min(a, b) + 1):\n            if a % i == 0 and b % i == 0:\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        count = 0\n        for i in range(1, min(a, b) + 1):\n            if a % i == 0 and b % i == 0:\n                count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2426", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        n = len(nums1)\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n\n        return count", "extracted_code": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        n = len(nums1)\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n\n        return count", "difficulty": 3.0}
{"task_id": "LeetCode/2425", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_nums1 = 0\n        xor_nums2 = 0\n        for num in nums1:\n            xor_nums1 ^= num\n        for num in nums2:\n            xor_nums2 ^= num\n        return xor_nums1 ^ xor_nums2\n```", "extracted_code": "\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_nums1 = 0\n        xor_nums2 = 0\n        for num in nums1:\n            xor_nums1 ^= num\n        for num in nums2:\n            xor_nums2 ^= num\n        return xor_nums1 ^ xor_nums2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2424", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.uploaded = set()\n        self.max_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded.add(video)\n        while self.max_prefix + 1 in self.uploaded:\n            self.max_prefix += 1\n\n    def longest(self) -> int:\n        return self.max_prefix\n\n# obj = LUPrefix(n)\n# obj.upload(video)\n# param_2 = obj.longest()\n```", "extracted_code": "\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.uploaded = set()\n        self.max_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded.add(video)\n        while self.max_prefix + 1 in self.uploaded:\n            self.max_prefix += 1\n\n    def longest(self) -> int:\n        return self.max_prefix\n\n# obj = LUPrefix(n)\n# obj.upload(video)\n# param_2 = obj.longest()\n", "difficulty": 2.0}
{"task_id": "LeetCode/2421", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(len(vals))]\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        def dfs(node, parent, max_val):\n            if vals[node] < max_val:\n                return 0\n            max_val = max(max_val, vals[node])\n            path_count = 1 if vals[node] == max_val else 0\n            for child in graph[node]:\n                if child != parent:\n                    path_count += dfs(child, node, max_val)\n            return path_count\n\n        return sum(dfs(i, -1, 0) for i in range(len(vals))) // 2\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(len(vals))]\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        def dfs(node, parent, max_val):\n            if vals[node] < max_val:\n                return 0\n            max_val = max(max_val, vals[node])\n            path_count = 1 if vals[node] == max_val else 0\n            for child in graph[node]:\n                if child != parent:\n                    path_count += dfs(child, node, max_val)\n            return path_count\n\n        return sum(dfs(i, -1, 0) for i in range(len(vals))) // 2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2419", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_bitwise_and = 0\n        longest_subarray = 0\n        for i in range(len(nums)):\n            current_bitwise_and = nums[i]\n            for j in range(i + 1, len(nums)):\n                current_bitwise_and &= nums[j]\n                if current_bitwise_and > max_bitwise_and:\n                    max_bitwise_and = current_bitwise_and\n                    longest_subarray = j - i + 1\n                elif current_bitwise_and == max_bitwise_and:\n                    longest_subarray = max(longest_subarray, j - i + 1)\n                if max_bitwise_and == 0:\n                    break\n        return longest_subarray\n```", "extracted_code": "\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        max_bitwise_and = 0\n        longest_subarray = 0\n        for i in range(len(nums)):\n            current_bitwise_and = nums[i]\n            for j in range(i + 1, len(nums)):\n                current_bitwise_and &= nums[j]\n                if current_bitwise_and > max_bitwise_and:\n                    max_bitwise_and = current_bitwise_and\n                    longest_subarray = j - i + 1\n                elif current_bitwise_and == max_bitwise_and:\n                    longest_subarray = max(longest_subarray, j - i + 1)\n                if max_bitwise_and == 0:\n                    break\n        return longest_subarray\n", "difficulty": 2.0}
{"task_id": "LeetCode/2416", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        answer = []\n        for word in words:\n            score = 0\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                score += sum(1 for w in words if w.startswith(prefix))\n            answer.append(score)\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        answer = []\n        for word in words:\n            score = 0\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                score += sum(1 for w in words if w.startswith(prefix))\n            answer.append(score)\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2415", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def traverse(node, level):\n            if node is None:\n                return\n            if level % 2 == 1:\n                node.left, node.right = node.right, node.left\n            traverse(node.left, level + 1)\n            traverse(node.right, level + 1)\n\n        traverse(root, 0)\n        return root\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def traverse(node, level):\n            if node is None:\n                return\n            if level % 2 == 1:\n                node.left, node.right = node.right, node.left\n            traverse(node.left, level + 1)\n            traverse(node.right, level + 1)\n\n        traverse(root, 0)\n        return root\n", "difficulty": 2.0}
{"task_id": "LeetCode/2414", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_length = 1\n        current_length = 1\n        \n        for i in range(1, len(s)):\n            if ord(s[i]) == ord(s[i-1]) + 1:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 1\n                \n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_length = 1\n        current_length = 1\n        \n        for i in range(1, len(s)):\n            if ord(s[i]) == ord(s[i-1]) + 1:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 1\n                \n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2413", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n if n % 2 == 0 else n * 2\n```", "extracted_code": "\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n if n % 2 == 0 else n * 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2412", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        min_money = 0\n        total_cost = 0\n        total_cashback = 0\n\n        for cost, cashback in transactions:\n            total_cost += cost\n            total_cashback += cashback\n            min_money = max(min_money, cost - cashback)\n\n        return min_money + total_cost - total_cashback\n```", "extracted_code": "\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        min_money = 0\n        total_cost = 0\n        total_cashback = 0\n\n        for cost, cashback in transactions:\n            total_cost += cost\n            total_cashback += cashback\n            min_money = max(min_money, cost - cashback)\n\n        return min_money + total_cost - total_cashback\n", "difficulty": 3.0}
{"task_id": "LeetCode/2409", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        def date_to_day(date: str) -> int:\n            month, day = map(int, date.split('-'))\n            days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n            return sum(days_per_month[:month-1]) + day\n\n        arrive_alice_day = date_to_day(arriveAlice)\n        leave_alice_day = date_to_day(leaveAlice)\n        arrive_bob_day = date_to_day(arriveBob)\n        leave_bob_day = date_to_day(leaveBob)\n\n        start = max(arrive_alice_day, arrive_bob_day)\n        end = min(leave_alice_day, leave_bob_day)\n\n        return max(0, end - start + 1)\n```", "extracted_code": "\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        def date_to_day(date: str) -> int:\n            month, day = map(int, date.split('-'))\n            days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n            return sum(days_per_month[:month-1]) + day\n\n        arrive_alice_day = date_to_day(arriveAlice)\n        leave_alice_day = date_to_day(leaveAlice)\n        arrive_bob_day = date_to_day(arriveBob)\n        leave_bob_day = date_to_day(leaveBob)\n\n        start = max(arrive_alice_day, arrive_bob_day)\n        end = min(leave_alice_day, leave_bob_day)\n\n        return max(0, end - start + 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2407", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [1] * n\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j] and nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)", "extracted_code": "class Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [1] * n\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j] and nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)", "difficulty": 3.0}
{"task_id": "LeetCode/2402", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n        rooms = [0] * n\n        bookings = [0] * n\n        for start, end in meetings:\n            for i in range(n):\n                if start >= rooms[i]:\n                    rooms[i] = end\n                    bookings[i] += 1\n                    break\n        return bookings.index(max(bookings))\n```", "extracted_code": "\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n        rooms = [0] * n\n        bookings = [0] * n\n        for start, end in meetings:\n            for i in range(n):\n                if start >= rooms[i]:\n                    rooms[i] = end\n                    bookings[i] += 1\n                    break\n        return bookings.index(max(bookings))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2401", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        def getMaxNiceLength(start: int) -> int:\n            max_length = 1\n            count = 0\n            for end in range(start + 1, len(nums)):\n                count |= nums[end - 1]\n                if count & nums[end] == 0:\n                    max_length = max(max_length, end - start + 1)\n            return max_length\n\n        longest_nice = 1\n        for i in range(len(nums) - 1):\n            longest_nice = max(longest_nice, getMaxNiceLength(i))\n\n        return longest_nice\n```", "extracted_code": "\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        def getMaxNiceLength(start: int) -> int:\n            max_length = 1\n            count = 0\n            for end in range(start + 1, len(nums)):\n                count |= nums[end - 1]\n                if count & nums[end] == 0:\n                    max_length = max(max_length, end - start + 1)\n            return max_length\n\n        longest_nice = 1\n        for i in range(len(nums) - 1):\n            longest_nice = max(longest_nice, getMaxNiceLength(i))\n\n        return longest_nice\n", "difficulty": 2.0}
{"task_id": "LeetCode/2399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        letter_indices = {}\n        \n        for i, c in enumerate(s):\n            if c in letter_indices:\n                letter_distance = i - letter_indices[c] - 1\n                if letter_distance != distance[ord(c) - ord('a')]:\n                    return False\n            else:\n                letter_indices[c] = i\n                \n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        letter_indices = {}\n        \n        for i, c in enumerate(s):\n            if c in letter_indices:\n                letter_distance = i - letter_indices[c] - 1\n                if letter_distance != distance[ord(c) - ord('a')]:\n                    return False\n            else:\n                letter_indices[c] = i\n                \n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2398", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        max_consecutive_robots = 0\n\n        for i in range(n):\n            cur_cost = chargeTimes[i]\n            running_sum = runningCosts[i]\n\n            for j in range(i + 1, n):\n                cur_cost = max(cur_cost, chargeTimes[j])\n                running_sum += runningCosts[j]\n                total_cost = cur_cost + (j - i + 1) * running_sum\n\n                if total_cost <= budget:\n                    max_consecutive_robots = max(max_consecutive_robots, j - i + 1)\n                else:\n                    break\n\n        return max_consecutive_robots\n```", "extracted_code": "\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        max_consecutive_robots = 0\n\n        for i in range(n):\n            cur_cost = chargeTimes[i]\n            running_sum = runningCosts[i]\n\n            for j in range(i + 1, n):\n                cur_cost = max(cur_cost, chargeTimes[j])\n                running_sum += runningCosts[j]\n                total_cost = cur_cost + (j - i + 1) * running_sum\n\n                if total_cost <= budget:\n                    max_consecutive_robots = max(max_consecutive_robots, j - i + 1)\n                else:\n                    break\n\n        return max_consecutive_robots\n", "difficulty": 3.0}
{"task_id": "LeetCode/2397", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        from itertools import combinations\n\n        def is_covered(row, s):\n            return all(matrix[row][col] == 0 or col in s for col in range(len(matrix[row])))\n\n        max_covered = 0\n        for s in combinations(range(len(matrix[0])), numSelect):\n            covered = sum(is_covered(row, s) for row in range(len(matrix)))\n            max_covered = max(max_covered, covered)\n\n        return max_covered\n```", "extracted_code": "\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        from itertools import combinations\n\n        def is_covered(row, s):\n            return all(matrix[row][col] == 0 or col in s for col in range(len(matrix[row])))\n\n        max_covered = 0\n        for s in combinations(range(len(matrix[0])), numSelect):\n            covered = sum(is_covered(row, s) for row in range(len(matrix)))\n            max_covered = max(max_covered, covered)\n\n        return max_covered\n", "difficulty": 2.0}
{"task_id": "LeetCode/2396", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        def to_base(num, base):\n            digits = []\n            while num:\n                digits.append(num % base)\n                num //= base\n            return digits\n\n        for base in range(2, n - 1):\n            num_in_base = to_base(n, base)\n            if num_in_base != num_in_base[::-1]:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        def to_base(num, base):\n            digits = []\n            while num:\n                digits.append(num % base)\n                num //= base\n            return digits\n\n        for base in range(2, n - 1):\n            num_in_base = to_base(n, base)\n            if num_in_base != num_in_base[::-1]:\n                return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2392", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        def isValid(matrix):\n            for r, c in rowConditions:\n                r_pos, c_pos = -1, -1\n                for i in range(k):\n                    if matrix[i].count(r) > 0:\n                        r_pos = i\n                    if matrix[i].count(c) > 0:\n                        c_pos = i\n                    if r_pos != -1 and c_pos != -1:\n                        break\n                if r_pos == -1 or c_pos == -1 or r_pos >= c_pos:\n                    return False\n\n            for l, r in colConditions:\n                l_pos, r_pos = -1, -1\n                for i in range(k):\n                    if matrix[i].count(l) > 0:\n                        l_pos = matrix[i].index(l)\n                    if matrix[i].count(r) > 0:\n                        r_pos = matrix[i].index(r)\n                    if l_pos != -1 and r_pos != -1:\n                        break\n                if l_pos == -1 or r_pos == -1 or l_pos >= r_pos:\n                    return False\n\n            return True\n\n        def build(matrix, nums):\n            if not nums:\n                if isValid(matrix):\n                    return matrix\n                return []\n            num = nums.pop()\n            for i in range(k):\n                for j in range(k):\n                    if matrix[i][j] == 0:\n                        matrix[i][j] = num\n                        result = build(matrix, nums)\n                        if result:\n                            return result\n                        matrix[i][j] = 0\n            nums.append(num)\n            return []\n\n        matrix = [[0] * k for _ in range(k)]\n        nums = list(range(1, k + 1))\n        return build(matrix, nums)", "extracted_code": "class Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        def isValid(matrix):\n            for r, c in rowConditions:\n                r_pos, c_pos = -1, -1\n                for i in range(k):\n                    if matrix[i].count(r) > 0:\n                        r_pos = i\n                    if matrix[i].count(c) > 0:\n                        c_pos = i\n                    if r_pos != -1 and c_pos != -1:\n                        break\n                if r_pos == -1 or c_pos == -1 or r_pos >= c_pos:\n                    return False\n\n            for l, r in colConditions:\n                l_pos, r_pos = -1, -1\n                for i in range(k):\n                    if matrix[i].count(l) > 0:\n                        l_pos = matrix[i].index(l)\n                    if matrix[i].count(r) > 0:\n                        r_pos = matrix[i].index(r)\n                    if l_pos != -1 and r_pos != -1:\n                        break\n                if l_pos == -1 or r_pos == -1 or l_pos >= r_pos:\n                    return False\n\n            return True\n\n        def build(matrix, nums):\n            if not nums:\n                if isValid(matrix):\n                    return matrix\n                return []\n            num = nums.pop()\n            for i in range(k):\n                for j in range(k):\n                    if matrix[i][j] == 0:\n                        matrix[i][j] = num\n                        result = build(matrix, nums)\n                        if result:\n                            return result\n                        matrix[i][j] = 0\n            nums.append(num)\n            return []\n\n        matrix = [[0] * k for _ in range(k)]\n        nums = list(range(1, k + 1))\n        return build(matrix, nums)", "difficulty": 3.0}
{"task_id": "LeetCode/2390", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def removeStars(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char == '*':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(char)\n        return ''.join(stack)", "extracted_code": "class Solution:\n    def removeStars(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char == '*':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(char)\n        return ''.join(stack)", "difficulty": 2.0}
{"task_id": "LeetCode/2386", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        from itertools import chain, combinations\n\n        def subsequences(arr):\n            return list(chain.from_iterable(combinations(arr, r) for r in range(len(arr) + 1)))\n\n        sub_sums = sorted([sum(x) for x in subsequences(nums)], reverse=True)\n        return sub_sums[k - 1]\n```", "extracted_code": "\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        from itertools import chain, combinations\n\n        def subsequences(arr):\n            return list(chain.from_iterable(combinations(arr, r) for r in range(len(arr) + 1)))\n\n        sub_sums = sorted([sum(x) for x in subsequences(nums)], reverse=True)\n        return sub_sums[k - 1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2385", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        infected = set()\n        queue = [(root, 0)]\n        \n        while queue:\n            node, minutes = queue.pop(0)\n            if node:\n                if node.val == start and node.val not in infected:\n                    infected.add(node.val)\n                    queue.append((node.left, minutes+1))\n                    queue.append((node.right, minutes+1))\n                elif node.val in infected:\n                    queue.append((node.left, minutes+1))\n                    queue.append((node.right, minutes+1))\n                else:\n                    infected.add(node.val)\n                    queue.append((node.left, minutes+1))\n                    queue.append((node.right, minutes+1))\n                    \n        return minutes\n```", "extracted_code": "\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        infected = set()\n        queue = [(root, 0)]\n        \n        while queue:\n            node, minutes = queue.pop(0)\n            if node:\n                if node.val == start and node.val not in infected:\n                    infected.add(node.val)\n                    queue.append((node.left, minutes+1))\n                    queue.append((node.right, minutes+1))\n                elif node.val in infected:\n                    queue.append((node.left, minutes+1))\n                    queue.append((node.right, minutes+1))\n                else:\n                    infected.add(node.val)\n                    queue.append((node.left, minutes+1))\n                    queue.append((node.right, minutes+1))\n                    \n        return minutes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2382", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        n = len(nums)\n        answer = [0] * n\n        for i, query in enumerate(removeQueries):\n            nums[query] = 0\n            max_sum = cur_sum = 0\n            for num in nums:\n                if num == 0:\n                    cur_sum = 0\n                else:\n                    cur_sum += num\n                    max_sum = max(max_sum, cur_sum)\n            answer[i] = max_sum\n        return answer", "extracted_code": "class Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        n = len(nums)\n        answer = [0] * n\n        for i, query in enumerate(removeQueries):\n            nums[query] = 0\n            max_sum = cur_sum = 0\n            for num in nums:\n                if num == 0:\n                    cur_sum = 0\n                else:\n                    cur_sum += num\n                    max_sum = max(max_sum, cur_sum)\n            answer[i] = max_sum\n        return answer", "difficulty": 3.0}
{"task_id": "LeetCode/2376", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        def is_special(num: int) -> bool:\n            seen_digits = set()\n            while num > 0:\n                digit = num % 10\n                if digit in seen_digits:\n                    return False\n                seen_digits.add(digit)\n                num //= 10\n            return True\n\n        count = 0\n        for i in range(1, n + 1):\n            if is_special(i):\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        def is_special(num: int) -> bool:\n            seen_digits = set()\n            while num > 0:\n                digit = num % 10\n                if digit in seen_digits:\n                    return False\n                seen_digits.add(digit)\n                num //= 10\n            return True\n\n        count = 0\n        for i in range(1, n + 1):\n            if is_special(i):\n                count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2368", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        from collections import defaultdict, deque\n        \n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        restricted = set(restricted)\n        \n        visited = set()\n        queue = deque([0])\n        \n        max_nodes = 0\n        while queue:\n            node = queue.popleft()\n            if node not in visited and node not in restricted:\n                visited.add(node)\n                max_nodes += 1\n                \n                for neighbor in tree[node]:\n                    queue.append(neighbor)\n        \n        return max_nodes", "extracted_code": "class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        from collections import defaultdict, deque\n        \n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        restricted = set(restricted)\n        \n        visited = set()\n        queue = deque([0])\n        \n        max_nodes = 0\n        while queue:\n            node = queue.popleft()\n            if node not in visited and node not in restricted:\n                visited.add(node)\n                max_nodes += 1\n                \n                for neighbor in tree[node]:\n                    queue.append(neighbor)\n        \n        return max_nodes", "difficulty": 2.0}
{"task_id": "LeetCode/2366", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        operations = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                operations += (nums[i - 1] - nums[i] + 1) // 2\n                nums[i] = nums[i - 1] + 1\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        operations = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                operations += (nums[i - 1] - nums[i] + 1) // 2\n                nums[i] = nums[i - 1] + 1\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2365", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_count = {}\n        max_days = 0\n        \n        for task in tasks:\n            if task not in task_count:\n                task_count[task] = 1\n            else:\n                task_count[task] += 1\n            \n            max_days = max(max_days, task_count[task] * (space + 1) - space)\n        \n        return max(max_days, len(tasks))\n```", "extracted_code": "\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_count = {}\n        max_days = 0\n        \n        for task in tasks:\n            if task not in task_count:\n                task_count[task] = 1\n            else:\n                task_count[task] += 1\n            \n            max_days = max(max_days, task_count[task] * (space + 1) - space)\n        \n        return max(max_days, len(tasks))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2360", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [0] * len(edges)\n        max_cycle = -1\n\n        for i in range(len(edges)):\n            curr_node = i\n            cycle_length = 0\n\n            while visited[curr_node] == 0 and edges[curr_node] != -1:\n                visited[curr_node] = 1\n                cycle_length += 1\n                curr_node = edges[curr_node]\n\n            if edges[curr_node] == i:\n                max_cycle = max(max_cycle, cycle_length)\n\n        return max_cycle\n```", "extracted_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [0] * len(edges)\n        max_cycle = -1\n\n        for i in range(len(edges)):\n            curr_node = i\n            cycle_length = 0\n\n            while visited[curr_node] == 0 and edges[curr_node] != -1:\n                visited[curr_node] = 1\n                cycle_length += 1\n                curr_node = edges[curr_node]\n\n            if edges[curr_node] == i:\n                max_cycle = max(max_cycle, cycle_length)\n\n        return max_cycle\n", "difficulty": 3.0}
{"task_id": "LeetCode/2359", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        def bfs(node):\n            visited = set()\n            queue = [(node, 0)]\n            dist = {}\n\n            while queue:\n                curr, distance = queue.pop(0)\n                visited.add(curr)\n                dist[curr] = distance\n\n                if edges[curr] != -1 and edges[curr] not in visited:\n                    queue.append((edges[curr], distance + 1))\n\n            return dist\n\n        dist1 = bfs(node1)\n        dist2 = bfs(node2)\n\n        min_distance = float('inf')\n        min_node = -1\n\n        for node in dist1:\n            if node in dist2:\n                max_dist = max(dist1[node], dist2[node])\n                if max_dist < min_distance:\n                    min_distance = max_dist\n                    min_node = node\n\n        return min_node\n```", "extracted_code": "\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        def bfs(node):\n            visited = set()\n            queue = [(node, 0)]\n            dist = {}\n\n            while queue:\n                curr, distance = queue.pop(0)\n                visited.add(curr)\n                dist[curr] = distance\n\n                if edges[curr] != -1 and edges[curr] not in visited:\n                    queue.append((edges[curr], distance + 1))\n\n            return dist\n\n        dist1 = bfs(node1)\n        dist2 = bfs(node2)\n\n        min_distance = float('inf')\n        min_node = -1\n\n        for node in dist1:\n            if node in dist2:\n                max_dist = max(dist1[node], dist2[node])\n                if max_dist < min_distance:\n                    min_distance = max_dist\n                    min_node = node\n\n        return min_node\n", "difficulty": 2.0}
{"task_id": "LeetCode/2354", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        def count_set_bits(n):\n            count = 0\n            while n:\n                count += n & 1\n                n >>= 1\n            return count\n\n        pairs_count = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                num1, num2 = nums[i], nums[j]\n                if count_set_bits(num1 & num2) + count_set_bits(num1 | num2) >= k:\n                    pairs_count += 1 if i == j else 2\n        return pairs_count\n```", "extracted_code": "\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        def count_set_bits(n):\n            count = 0\n            while n:\n                count += n & 1\n                n >>= 1\n            return count\n\n        pairs_count = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                num1, num2 = nums[i], nums[j]\n                if count_set_bits(num1 & num2) + count_set_bits(num1 | num2) >= k:\n                    pairs_count += 1 if i == j else 2\n        return pairs_count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2353", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.food_data = {food: {'cuisine': cuisine, 'rating': rating} for food, cuisine, rating in zip(foods, cuisines, ratings)}\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        self.food_data[food]['rating'] = newRating\n\n    def highestRated(self, cuisine: str) -> str:\n        highest_rated_food = None\n        highest_rating = -1\n        for food, data in self.food_data.items():\n            if data['cuisine'] == cuisine:\n                if data['rating'] > highest_rating or (data['rating'] == highest_rating and food < highest_rated_food):\n                    highest_rated_food = food\n                    highest_rating = data['rating']\n        return highest_rated_food", "extracted_code": "class FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.food_data = {food: {'cuisine': cuisine, 'rating': rating} for food, cuisine, rating in zip(foods, cuisines, ratings)}\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        self.food_data[food]['rating'] = newRating\n\n    def highestRated(self, cuisine: str) -> str:\n        highest_rated_food = None\n        highest_rating = -1\n        for food, data in self.food_data.items():\n            if data['cuisine'] == cuisine:\n                if data['rating'] > highest_rating or (data['rating'] == highest_rating and food < highest_rated_food):\n                    highest_rated_food = food\n                    highest_rating = data['rating']\n        return highest_rated_food", "difficulty": 2.0}
{"task_id": "LeetCode/2350", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        rolls_set = set(rolls)\n        for length in range(1, k + 1):\n            for i in range(k**length):\n                sequence = []\n                for j in range(length):\n                    sequence.append(i // (k**j) % k + 1)\n                if set(sequence).issubset(rolls_set):\n                    continue\n                else:\n                    return length\n        return k\n```", "extracted_code": "\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        rolls_set = set(rolls)\n        for length in range(1, k + 1):\n            for i in range(k**length):\n                sequence = []\n                for j in range(length):\n                    sequence.append(i // (k**j) % k + 1)\n                if set(sequence).issubset(rolls_set):\n                    continue\n                else:\n                    return length\n        return k\n", "difficulty": 3.0}
{"task_id": "LeetCode/2349", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass NumberContainers:\n\n    def __init__(self):\n        self.container = {}\n\n    def change(self, index: int, number: int) -> None:\n        if number not in self.container:\n            self.container[number] = {index}\n        else:\n            self.container[number].add(index)\n\n    def find(self, number: int) -> int:\n        if number in self.container and self.container[number]:\n            return min(self.container[number])\n        return -1\n```\n", "extracted_code": "\nclass NumberContainers:\n\n    def __init__(self):\n        self.container = {}\n\n    def change(self, index: int, number: int) -> None:\n        if number not in self.container:\n            self.container[number] = {index}\n        else:\n            self.container[number].add(index)\n\n    def find(self, number: int) -> int:\n        if number in self.container and self.container[number]:\n            return min(self.container[number])\n        return -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2344", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        def check_divisibility(x):\n            for num in numsDivide:\n                if num % x != 0:\n                    return False\n            return True\n\n        nums.sort()\n        min_deletions = float('inf')\n\n        for i in range(len(nums)):\n            if check_divisibility(nums[i]):\n                min_deletions = min(min_deletions, i)\n\n        return min_deletions if min_deletions != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        def check_divisibility(x):\n            for num in numsDivide:\n                if num % x != 0:\n                    return False\n            return True\n\n        nums.sort()\n        min_deletions = float('inf')\n\n        for i in range(len(nums)):\n            if check_divisibility(nums[i]):\n                min_deletions = min(min_deletions, i)\n\n        return min_deletions if min_deletions != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2343", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        answer = []\n        for query in queries:\n            k, trim = query\n            trimmed_nums = [int(num[-trim:]) for num in nums]\n            sorted_indices = sorted(range(len(trimmed_nums)), key=lambda i: (trimmed_nums[i], i))\n            answer.append(sorted_indices[k - 1])\n        return answer", "extracted_code": "class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        answer = []\n        for query in queries:\n            k, trim = query\n            trimmed_nums = [int(num[-trim:]) for num in nums]\n            sorted_indices = sorted(range(len(trimmed_nums)), key=lambda i: (trimmed_nums[i], i))\n            answer.append(sorted_indices[k - 1])\n        return answer", "difficulty": 2.0}
{"task_id": "LeetCode/2342", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        def sum_of_digits(n: int) -> int:\n            return sum(map(int, str(n)))\n\n        sums = {}\n        max_sum = -1\n\n        for num in nums:\n            digits_sum = sum_of_digits(num)\n            if digits_sum in sums:\n                max_sum = max(max_sum, sums[digits_sum] + num)\n                sums[digits_sum] = max(sums[digits_sum], num)\n            else:\n                sums[digits_sum] = num\n\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        def sum_of_digits(n: int) -> int:\n            return sum(map(int, str(n)))\n\n        sums = {}\n        max_sum = -1\n\n        for num in nums:\n            digits_sum = sum_of_digits(num)\n            if digits_sum in sums:\n                max_sum = max(max_sum, sums[digits_sum] + num)\n                sums[digits_sum] = max(sums[digits_sum], num)\n            else:\n                sums[digits_sum] = num\n\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2338", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (maxValue + 1)\n\n        for x in range(1, maxValue + 1):\n            dp[x] = pow(x, n, MOD) - pow(x - 1, n, MOD)\n            dp[x] %= MOD\n\n        for i in range(2, maxValue + 1):\n            j = 2\n            while i * j <= maxValue:\n                dp[i * j] -= dp[i]\n                dp[i * j] %= MOD\n                j += 1\n\n        ans = 0\n        for x in dp:\n            ans += x\n            ans %= MOD\n\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (maxValue + 1)\n\n        for x in range(1, maxValue + 1):\n            dp[x] = pow(x, n, MOD) - pow(x - 1, n, MOD)\n            dp[x] %= MOD\n\n        for i in range(2, maxValue + 1):\n            j = 2\n            while i * j <= maxValue:\n                dp[i * j] -= dp[i]\n                dp[i * j] %= MOD\n                j += 1\n\n        ans = 0\n        for x in dp:\n            ans += x\n            ans %= MOD\n\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2334", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        for k in range(1, n + 1):\n            for i in range(n - k + 1):\n                if all([x > threshold / k for x in nums[i:i + k]]):\n                    return k\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        for k in range(1, n + 1):\n            for i in range(n - k + 1):\n                if all([x > threshold / k for x in nums[i:i + k]]):\n                    return k\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2333", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        diff = [abs(nums1[i] - nums2[i]) for i in range(len(nums1))]\n        diff.sort(reverse=True)\n\n        for i in range(len(diff)):\n            total_k = k1 + k2\n            if total_k >= diff[i]:\n                k1, k2 = max(0, k1 - diff[i]), max(0, k2 - diff[i])\n                diff[i] = 0\n            elif k1 > 0:\n                k1 -= min(diff[i], k1)\n                diff[i] -= min(diff[i], k1)\n            elif k2 > 0:\n                k2 -= min(diff[i], k2)\n                diff[i] -= min(diff[i], k2)\n\n        return sum(x ** 2 for x in diff)\n```", "extracted_code": "\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        diff = [abs(nums1[i] - nums2[i]) for i in range(len(nums1))]\n        diff.sort(reverse=True)\n\n        for i in range(len(diff)):\n            total_k = k1 + k2\n            if total_k >= diff[i]:\n                k1, k2 = max(0, k1 - diff[i]), max(0, k2 - diff[i])\n                diff[i] = 0\n            elif k1 > 0:\n                k1 -= min(diff[i], k1)\n                diff[i] -= min(diff[i], k1)\n            elif k2 > 0:\n                k2 -= min(diff[i], k2)\n                diff[i] -= min(diff[i], k2)\n\n        return sum(x ** 2 for x in diff)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2328", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        neighbors = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n        def dfs(x, y):\n            if memo[x][y] != -1:\n                return memo[x][y]\n            memo[x][y] = 0\n            for dx, dy in neighbors:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[x][y] < grid[nx][ny]:\n                    memo[x][y] += dfs(nx, ny) % mod\n            return memo[x][y]\n\n        memo = [[-1] * n for _ in range(m)]\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                ans = (ans + dfs(i, j)) % mod\n        return ans", "extracted_code": "class Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        neighbors = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n        def dfs(x, y):\n            if memo[x][y] != -1:\n                return memo[x][y]\n            memo[x][y] = 0\n            for dx, dy in neighbors:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[x][y] < grid[nx][ny]:\n                    memo[x][y] += dfs(nx, ny) % mod\n            return memo[x][y]\n\n        memo = [[-1] * n for _ in range(m)]\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                ans = (ans + dfs(i, j)) % mod\n        return ans", "difficulty": 3.0}
{"task_id": "LeetCode/2325", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        substitution_table = {}\n        seen = set()\n\n        for char in key:\n            if char not in seen and char != ' ':\n                substitution_table[char] = chr(len(seen) + ord('a'))\n                seen.add(char)\n\n        decoded_message = []\n        for char in message:\n            if char == ' ':\n                decoded_message.append(' ')\n            else:\n                decoded_message.append(substitution_table[char])\n\n        return ''.join(decoded_message)", "extracted_code": "class Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        substitution_table = {}\n        seen = set()\n\n        for char in key:\n            if char not in seen and char != ' ':\n                substitution_table[char] = chr(len(seen) + ord('a'))\n                seen.add(char)\n\n        decoded_message = []\n        for char in message:\n            if char == ' ':\n                decoded_message.append(' ')\n            else:\n                decoded_message.append(substitution_table[char])\n\n        return ''.join(decoded_message)", "difficulty": 1.0}
{"task_id": "LeetCode/2322", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent):\n            xor_val = nums[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    xor_val ^= dfs(neighbor, node)\n            xor_values.append(xor_val)\n            return xor_val\n        \n        tree = [[] for _ in range(len(nums))]\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        xor_values = []\n        dfs(0, -1)\n        xor_values.sort(reverse=True)\n        \n        min_score = float('inf')\n        for i in range(len(xor_values) - 1):\n            for j in range(i + 1, len(xor_values)):\n                score = xor_values[i] - xor_values[j]\n                min_score = min(min_score, score)\n                if min_score == 0:\n                    return 0\n        return min_score\n```", "extracted_code": "\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(node, parent):\n            xor_val = nums[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    xor_val ^= dfs(neighbor, node)\n            xor_values.append(xor_val)\n            return xor_val\n        \n        tree = [[] for _ in range(len(nums))]\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        xor_values = []\n        dfs(0, -1)\n        xor_values.sort(reverse=True)\n        \n        min_score = float('inf')\n        for i in range(len(xor_values) - 1):\n            for j in range(i + 1, len(xor_values)):\n                score = xor_values[i] - xor_values[j]\n                min_score = min(min_score, score)\n                if min_score == 0:\n                    return 0\n        return min_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2320", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 2\n\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod\n\n        return (dp[n] * dp[n]) % mod\n```", "extracted_code": "\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 2\n\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod\n\n        return (dp[n] * dp[n]) % mod\n", "difficulty": 2.0}
{"task_id": "LeetCode/2318", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        MOD = 1000000007\n        dp = [[0] * 6 for _ in range(n + 1)]\n        \n        def gcd(a: int, b: int) -> int:\n            while b:\n                a, b = b, a % b\n            return a\n        \n        for i in range(1, 7):\n            dp[1][i - 1] = 1\n\n        for i in range(2, n + 1):\n            for j in range(1, 7):\n                for k in range(1, 7):\n                    if gcd(j, k) == 1 and (i < 3 or j != k):\n                        dp[i][j - 1] = (dp[i][j - 1] + dp[i - 1][k - 1]) % MOD\n\n        return sum(dp[n]) % MOD\n```", "extracted_code": "\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        MOD = 1000000007\n        dp = [[0] * 6 for _ in range(n + 1)]\n        \n        def gcd(a: int, b: int) -> int:\n            while b:\n                a, b = b, a % b\n            return a\n        \n        for i in range(1, 7):\n            dp[1][i - 1] = 1\n\n        for i in range(2, n + 1):\n            for j in range(1, 7):\n                for k in range(1, 7):\n                    if gcd(j, k) == 1 and (i < 3 or j != k):\n                        dp[i][j - 1] = (dp[i][j - 1] + dp[i - 1][k - 1]) % MOD\n\n        return sum(dp[n]) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2317", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        result = 0\n        mask = 0\n        for bit in range(31, -1, -1):\n            mask |= 1 << bit\n            prefixes = {num & mask for num in nums}\n            candidate = result | (1 << bit)\n            for prefix in prefixes:\n                if candidate ^ prefix in prefixes:\n                    result = candidate\n                    break\n        return result\n```", "extracted_code": "\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        result = 0\n        mask = 0\n        for bit in range(31, -1, -1):\n            mask |= 1 << bit\n            prefixes = {num & mask for num in nums}\n            candidate = result | (1 << bit)\n            for prefix in prefixes:\n                if candidate ^ prefix in prefixes:\n                    result = candidate\n                    break\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2306", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctNames(self, ideas: list[str]) -> int:\n        valid_names = set()\n        \n        for i in range(len(ideas)):\n            for j in range(i+1, len(ideas)):\n                swapped_a = ideas[j][0] + ideas[i][1:]\n                swapped_b = ideas[i][0] + ideas[j][1:]\n                if swapped_a != ideas[i] and swapped_a != ideas[j] and swapped_b != ideas[i] and swapped_b != ideas[j]:\n                    valid_names.add(swapped_a + \" \" + swapped_b)\n                    valid_names.add(swapped_b + \" \" + swapped_a)\n                    \n        return len(valid_names)\n```", "extracted_code": "\nclass Solution:\n    def distinctNames(self, ideas: list[str]) -> int:\n        valid_names = set()\n        \n        for i in range(len(ideas)):\n            for j in range(i+1, len(ideas)):\n                swapped_a = ideas[j][0] + ideas[i][1:]\n                swapped_b = ideas[i][0] + ideas[j][1:]\n                if swapped_a != ideas[i] and swapped_a != ideas[j] and swapped_b != ideas[i] and swapped_b != ideas[j]:\n                    valid_names.add(swapped_a + \" \" + swapped_b)\n                    valid_names.add(swapped_b + \" \" + swapped_a)\n                    \n        return len(valid_names)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2302", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            total = 0\n            for j in range(i, len(nums)):\n                total += nums[j]\n                if total * (j - i + 1) < k:\n                    count += 1\n                else:\n                    break\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            total = 0\n            for j in range(i, len(nums)):\n                total += nums[j]\n                if total * (j - i + 1) < k:\n                    count += 1\n                else:\n                    break\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2301", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        def replace_char(sub, old, new):\n            return sub.replace(old, new, 1)\n\n        def is_substring(s, sub):\n            return sub in s\n\n        for mapping in mappings:\n            sub = replace_char(sub, mapping[0], mapping[1])\n            if is_substring(s, sub):\n                return True\n\n        return False", "extracted_code": "class Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        def replace_char(sub, old, new):\n            return sub.replace(old, new, 1)\n\n        def is_substring(s, sub):\n            return sub in s\n\n        for mapping in mappings:\n            sub = replace_char(sub, mapping[0], mapping[1])\n            if is_substring(s, sub):\n                return True\n\n        return False", "difficulty": 3.0}
{"task_id": "LeetCode/2296", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class TextEditor:\n\n    def __init__(self):\n        self.text = \"\"\n        self.cursor_position = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor_position] + text + self.text[self.cursor_position:]\n        self.cursor_position += len(text)\n\n    def deleteText(self, k: int) -> int:\n        deleted = min(k, self.cursor_position)\n        self.text = self.text[:self.cursor_position - deleted] + self.text[self.cursor_position:]\n        self.cursor_position -= deleted\n        return deleted\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor_position = max(self.cursor_position - k, 0)\n        return self.text[max(self.cursor_position - 10, 0):self.cursor_position]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor_position = min(self.cursor_position + k, len(self.text))\n        return self.text[max(self.cursor_position - 10, 0):self.cursor_position]", "extracted_code": "class TextEditor:\n\n    def __init__(self):\n        self.text = \"\"\n        self.cursor_position = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor_position] + text + self.text[self.cursor_position:]\n        self.cursor_position += len(text)\n\n    def deleteText(self, k: int) -> int:\n        deleted = min(k, self.cursor_position)\n        self.text = self.text[:self.cursor_position - deleted] + self.text[self.cursor_position:]\n        self.cursor_position -= deleted\n        return deleted\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor_position = max(self.cursor_position - k, 0)\n        return self.text[max(self.cursor_position - 10, 0):self.cursor_position]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor_position = min(self.cursor_position + k, len(self.text))\n        return self.text[max(self.cursor_position - 10, 0):self.cursor_position]", "difficulty": 3.0}
{"task_id": "LeetCode/2294", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        subsequences = 1\n        min_value = nums[0]\n\n        for num in nums:\n            if num - min_value > k:\n                subsequences += 1\n                min_value = num\n\n        return subsequences", "extracted_code": "class Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        subsequences = 1\n        min_value = nums[0]\n\n        for num in nums:\n            if num - min_value > k:\n                subsequences += 1\n                min_value = num\n\n        return subsequences", "difficulty": 2.0}
{"task_id": "LeetCode/2290", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        from collections import deque\n        import heapq\n\n        m, n = len(grid), len(grid[0])\n        visited = set()\n\n        def neighbors(x, y):\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    yield nx, ny\n\n        q = [(0, 0, 0, 0)]  # cost, x, y, removed\n        heapq.heapify(q)\n\n        while q:\n            cost, x, y, removed = heapq.heappop(q)\n            if (x, y) == (m - 1, n - 1):\n                return removed\n\n            visited.add((x, y))\n\n            for nx, ny in neighbors(x, y):\n                heapq.heappush(q, (cost + 1, nx, ny, removed + grid[nx][ny]))\n\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        from collections import deque\n        import heapq\n\n        m, n = len(grid), len(grid[0])\n        visited = set()\n\n        def neighbors(x, y):\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    yield nx, ny\n\n        q = [(0, 0, 0, 0)]  # cost, x, y, removed\n        heapq.heapify(q)\n\n        while q:\n            cost, x, y, removed = heapq.heappop(q)\n            if (x, y) == (m - 1, n - 1):\n                return removed\n\n            visited.add((x, y))\n\n            for nx, ny in neighbors(x, y):\n                heapq.heappush(q, (cost + 1, nx, ny, removed + grid[nx][ny]))\n\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2286", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        self.n = n\n        self.m = m\n        self.seats = [[0] * m for _ in range(n)]\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for i in range(min(self.n, maxRow + 1)):\n            for j in range(self.m - k + 1):\n                if all(self.seats[i][j:c] == 0 for c in range(j, j + k)):\n                    for c in range(j, j + k):\n                        self.seats[i][c] = 1\n                    return [i, j]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        seats_available = sum(self.seats[i].count(0) for i in range(min(self.n, maxRow + 1)))\n        if seats_available >= k:\n            count = 0\n            for i in range(min(self.n, maxRow + 1)):\n                for j in range(self.m):\n                    if self.seats[i][j] == 0:\n                        self.seats[i][j] = 1\n                        count += 1\n                        if count == k:\n                            return True\n        return False", "extracted_code": "class BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        self.n = n\n        self.m = m\n        self.seats = [[0] * m for _ in range(n)]\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for i in range(min(self.n, maxRow + 1)):\n            for j in range(self.m - k + 1):\n                if all(self.seats[i][j:c] == 0 for c in range(j, j + k)):\n                    for c in range(j, j + k):\n                        self.seats[i][c] = 1\n                    return [i, j]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        seats_available = sum(self.seats[i].count(0) for i in range(min(self.n, maxRow + 1)))\n        if seats_available >= k:\n            count = 0\n            for i in range(min(self.n, maxRow + 1)):\n                for j in range(self.m):\n                    if self.seats[i][j] == 0:\n                        self.seats[i][j] = 1\n                        count += 1\n                        if count == k:\n                            return True\n        return False", "difficulty": 3.0}
{"task_id": "LeetCode/2284", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_count = defaultdict(int)\n        \n        for i, message in enumerate(messages):\n            sender = senders[i]\n            word_count[sender] += len(message.split())\n            \n        max_count = max(word_count.values())\n        max_senders = [sender for sender, count in word_count.items() if count == max_count]\n        \n        return max(max_senders)\n```", "extracted_code": "\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_count = defaultdict(int)\n        \n        for i, message in enumerate(messages):\n            sender = senders[i]\n            word_count[sender] += len(message.split())\n            \n        max_count = max(word_count.values())\n        max_senders = [sender for sender, count in word_count.items() if count == max_count]\n        \n        return max(max_senders)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2281", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        mod = 10**9 + 7\n        result = 0\n        stack = []\n        \n        for i in range(len(strength)):\n            while stack and strength[stack[-1]] > strength[i]:\n                min_strength = strength[stack.pop()]\n                result += min_strength * (i - (stack[-1] if stack else -1)) * (stack[-1] - (stack[-2] if len(stack) > 1 else -1))\n                result %= mod\n            stack.append(i)\n        \n        while stack:\n            min_strength = strength[stack.pop()]\n            result += min_strength * (len(strength) - (stack[-1] if stack else -1)) * (stack[-1] - (stack[-2] if len(stack) > 1 else -1))\n            result %= mod\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        mod = 10**9 + 7\n        result = 0\n        stack = []\n        \n        for i in range(len(strength)):\n            while stack and strength[stack[-1]] > strength[i]:\n                min_strength = strength[stack.pop()]\n                result += min_strength * (i - (stack[-1] if stack else -1)) * (stack[-1] - (stack[-2] if len(stack) > 1 else -1))\n                result %= mod\n            stack.append(i)\n        \n        while stack:\n            min_strength = strength[stack.pop()]\n            result += min_strength * (len(strength) - (stack[-1] if stack else -1)) * (stack[-1] - (stack[-2] if len(stack) > 1 else -1))\n            result %= mod\n        \n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2279", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        available_space = [cap - rock for cap, rock in zip(capacity, rocks)]\n        available_space.sort()\n        full_capacity_bags = 0\n        for space in available_space:\n            if additionalRocks >= space:\n                full_capacity_bags += 1\n                additionalRocks -= space\n            else:\n                break\n        return full_capacity_bags\n```", "extracted_code": "\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        available_space = [cap - rock for cap, rock in zip(capacity, rocks)]\n        available_space.sort()\n        full_capacity_bags = 0\n        for space in available_space:\n            if additionalRocks >= space:\n                full_capacity_bags += 1\n                additionalRocks -= space\n            else:\n                break\n        return full_capacity_bags\n", "difficulty": 2.0}
{"task_id": "LeetCode/2276", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        self.intervals.sort()\n        count = 0\n        merged_intervals = []\n        \n        for interval in self.intervals:\n            if not merged_intervals or merged_intervals[-1][1] < interval[0]:\n                merged_intervals.append(interval)\n            else:\n                merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1]))\n\n        for interval in merged_intervals:\n            count += interval[1] - interval[0] + 1\n\n        return count\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals()\n# obj.add(left,right)\n# param_2 = obj.count()", "extracted_code": "class CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        self.intervals.sort()\n        count = 0\n        merged_intervals = []\n        \n        for interval in self.intervals:\n            if not merged_intervals or merged_intervals[-1][1] < interval[0]:\n                merged_intervals.append(interval)\n            else:\n                merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1]))\n\n        for interval in merged_intervals:\n            count += interval[1] - interval[0] + 1\n\n        return count\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals()\n# obj.add(left,right)\n# param_2 = obj.count()", "difficulty": 3.0}
{"task_id": "LeetCode/2275", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        def helper(idx, current_bitwise_and):\n            if current_bitwise_and == 0:\n                return 0\n            if idx == len(candidates):\n                return 0\n            \n            return max(1 + helper(idx + 1, current_bitwise_and & candidates[idx]), helper(idx + 1, current_bitwise_and))\n        \n        return helper(0, (1 << 30) - 1)\n\n```", "extracted_code": "\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        def helper(idx, current_bitwise_and):\n            if current_bitwise_and == 0:\n                return 0\n            if idx == len(candidates):\n                return 0\n            \n            return max(1 + helper(idx + 1, current_bitwise_and & candidates[idx]), helper(idx + 1, current_bitwise_and))\n        \n        return helper(0, (1 << 30) - 1)\n\n", "difficulty": 2.0}
{"task_id": "LeetCode/2272", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        max_variance = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                char_counts = {}\n                for char in substring:\n                    if char in char_counts:\n                        char_counts[char] += 1\n                    else:\n                        char_counts[char] = 1\n                max_count = max(char_counts.values())\n                min_count = min(char_counts.values())\n                variance = max_count - min_count\n                max_variance = max(max_variance, variance)\n        return max_variance\n```", "extracted_code": "\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        max_variance = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                char_counts = {}\n                for char in substring:\n                    if char in char_counts:\n                        char_counts[char] += 1\n                    else:\n                        char_counts[char] = 1\n                max_count = max(char_counts.values())\n                min_count = min(char_counts.values())\n                variance = max_count - min_count\n                max_variance = max(max_variance, variance)\n        return max_variance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2271", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        max_white_tiles = 0\n        for tile in tiles:\n            l, r = tile\n            max_white_tiles = max(max_white_tiles, min(carpetLen, r - l + 1))\n            for other_tile in tiles:\n                if other_tile != tile:\n                    ol, or_ = other_tile\n                    if l <= ol <= r:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, r - ol + 1))\n                    elif l <= or_ <= r:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, or_ - l + 1))\n                    elif ol <= l <= or_:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, or_ - l + 1))\n                    elif ol <= r <= or_:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, r - ol + 1))\n        return max_white_tiles\n```", "extracted_code": "\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        max_white_tiles = 0\n        for tile in tiles:\n            l, r = tile\n            max_white_tiles = max(max_white_tiles, min(carpetLen, r - l + 1))\n            for other_tile in tiles:\n                if other_tile != tile:\n                    ol, or_ = other_tile\n                    if l <= ol <= r:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, r - ol + 1))\n                    elif l <= or_ <= r:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, or_ - l + 1))\n                    elif ol <= l <= or_:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, or_ - l + 1))\n                    elif ol <= r <= or_:\n                        max_white_tiles = max(max_white_tiles, min(carpetLen, r - ol + 1))\n        return max_white_tiles\n", "difficulty": 2.0}
{"task_id": "LeetCode/2270", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        result = 0\n        j = 0\n        for i in range(1, n):\n            while prefix_sum[j + 1] * 2 < prefix_sum[i + 1]:\n                j += 1\n            if j < i:\n                result += i - j\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        result = 0\n        j = 0\n        for i in range(1, n):\n            while prefix_sum[j + 1] * 2 < prefix_sum[i + 1]:\n                j += 1\n            if j < i:\n                result += i - j\n        \n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2269", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        num_str = str(num)\n        k_beauty = 0\n        for i in range(len(num_str) - k + 1):\n            substring = int(num_str[i:i + k])\n            if substring != 0 and num % substring == 0:\n                k_beauty += 1\n        return k_beauty\n```", "extracted_code": "\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        num_str = str(num)\n        k_beauty = 0\n        for i in range(len(num_str) - k + 1):\n            substring = int(num_str[i:i + k])\n            if substring != 0 and num % substring == 0:\n                k_beauty += 1\n        return k_beauty\n", "difficulty": 1.0}
{"task_id": "LeetCode/2267", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        stack = [(0, 0, 0)]\n        visited = set()\n\n        while stack:\n            x, y, opened = stack.pop()\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if x == m - 1 and y == n - 1:\n                return opened == 0\n\n            if 0 <= x + 1 < m:\n                if grid[x][y] == \"(\" and grid[x + 1][y] == \"(\":\n                    stack.append((x + 1, y, opened + 1))\n                elif grid[x][y] == \")\" and grid[x + 1][y] == \")\" and opened > 0:\n                    stack.append((x + 1, y, opened - 1))\n\n            if 0 <= y + 1 < n:\n                if grid[x][y] == \"(\" and grid[x][y + 1] == \"(\":\n                    stack.append((x, y + 1, opened + 1))\n                elif grid[x][y] == \")\" and grid[x][y + 1] == \")\" and opened > 0:\n                    stack.append((x, y + 1, opened - 1))\n\n        return False", "extracted_code": "class Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        stack = [(0, 0, 0)]\n        visited = set()\n\n        while stack:\n            x, y, opened = stack.pop()\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if x == m - 1 and y == n - 1:\n                return opened == 0\n\n            if 0 <= x + 1 < m:\n                if grid[x][y] == \"(\" and grid[x + 1][y] == \"(\":\n                    stack.append((x + 1, y, opened + 1))\n                elif grid[x][y] == \")\" and grid[x + 1][y] == \")\" and opened > 0:\n                    stack.append((x + 1, y, opened - 1))\n\n            if 0 <= y + 1 < n:\n                if grid[x][y] == \"(\" and grid[x][y + 1] == \"(\":\n                    stack.append((x, y + 1, opened + 1))\n                elif grid[x][y] == \")\" and grid[x][y + 1] == \")\" and opened > 0:\n                    stack.append((x, y + 1, opened - 1))\n\n        return False", "difficulty": 3.0}
{"task_id": "LeetCode/2262", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        total_appeal = 0\n        freq = [0] * 26\n\n        for i in range(len(s)):\n            temp = [0] * 26\n            for j in range(i, len(s)):\n                temp[ord(s[j]) - ord('a')] = 1\n                total_appeal += sum(temp)\n        return total_appeal\n```", "extracted_code": "\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        total_appeal = 0\n        freq = [0] * 26\n\n        for i in range(len(s)):\n            temp = [0] * 26\n            for j in range(i, len(s)):\n                temp[ord(s[j]) - ord('a')] = 1\n                total_appeal += sum(temp)\n        return total_appeal\n", "difficulty": 3.0}
{"task_id": "LeetCode/2259", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        idx = number.index(digit)\n        return number[:idx] + number[idx+1:]\n```", "extracted_code": "\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        idx = number.index(digit)\n        return number[:idx] + number[idx+1:]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2258", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        def bfs(grid, fire):\n            m, n = len(grid), len(grid[0])\n            visited = [[False] * n for _ in range(m)]\n            queue = [(0, 0, 0)]\n            visited[0][0] = True\n            max_minutes = 0\n            \n            while queue:\n                x, y, minutes = queue.pop(0)\n                max_minutes = max(max_minutes, minutes)\n                \n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\n                        if fire[nx][ny] is None or fire[nx][ny] > minutes + 1:\n                            if nx == m - 1 and ny == n - 1:\n                                return max_minutes + 1\n                            \n                            visited[nx][ny] = True\n                            queue.append((nx, ny, minutes + 1))\n            \n            return -1\n        \n        def spread_fire(grid):\n            m, n = len(grid), len(grid[0])\n            fire = [[None] * n for _ in range(m)]\n            queue = []\n            \n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        queue.append((i, j, 0))\n                        fire[i][j] = 0\n            \n            while queue:\n                x, y, minutes = queue.pop(0)\n                \n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0:\n                        if fire[nx][ny] is None or fire[nx][ny] > minutes + 1:\n                            fire[nx][ny] = minutes + 1\n                            queue.append((nx, ny, minutes + 1))\n            \n            return fire\n        \n        fire = spread_fire(grid)\n        \n        if fire[-1][-1] == 1:\n            return -1\n        \n        max_minutes = bfs(grid, fire)\n        \n        if max_minutes == -1:\n            return -1\n        \n        return min(max_minutes, 10**9)", "extracted_code": "class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        def bfs(grid, fire):\n            m, n = len(grid), len(grid[0])\n            visited = [[False] * n for _ in range(m)]\n            queue = [(0, 0, 0)]\n            visited[0][0] = True\n            max_minutes = 0\n            \n            while queue:\n                x, y, minutes = queue.pop(0)\n                max_minutes = max(max_minutes, minutes)\n                \n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\n                        if fire[nx][ny] is None or fire[nx][ny] > minutes + 1:\n                            if nx == m - 1 and ny == n - 1:\n                                return max_minutes + 1\n                            \n                            visited[nx][ny] = True\n                            queue.append((nx, ny, minutes + 1))\n            \n            return -1\n        \n        def spread_fire(grid):\n            m, n = len(grid), len(grid[0])\n            fire = [[None] * n for _ in range(m)]\n            queue = []\n            \n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        queue.append((i, j, 0))\n                        fire[i][j] = 0\n            \n            while queue:\n                x, y, minutes = queue.pop(0)\n                \n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0:\n                        if fire[nx][ny] is None or fire[nx][ny] > minutes + 1:\n                            fire[nx][ny] = minutes + 1\n                            queue.append((nx, ny, minutes + 1))\n            \n            return fire\n        \n        fire = spread_fire(grid)\n        \n        if fire[-1][-1] == 1:\n            return -1\n        \n        max_minutes = bfs(grid, fire)\n        \n        if max_minutes == -1:\n            return -1\n        \n        return min(max_minutes, 10**9)", "difficulty": 3.0}
{"task_id": "LeetCode/2251", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        answer = []\n        for p in people:\n            count = 0\n            for f in flowers:\n                if f[0] <= p <= f[1]:\n                    count += 1\n            answer.append(count)\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        answer = []\n        for p in people:\n            count = 0\n            for f in flowers:\n                if f[0] <= p <= f[1]:\n                    count += 1\n            answer.append(count)\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2248", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        result = set(nums[0])\n        for i in range(1, len(nums)):\n            result.intersection_update(nums[i])\n        return sorted(list(result))\n```", "extracted_code": "\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        result = set(nums[0])\n        for i in range(1, len(nums)):\n            result.intersection_update(nums[i])\n        return sorted(list(result))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2246", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        def dfs(node: int, parent_char: str) -> Tuple[int, int]:\n            max1 = max2 = 0\n            for child in tree[node]:\n                if s[child] != parent_char:\n                    path1, path2 = dfs(child, s[node])\n                    if path1 > max1:\n                        max2, max1 = max1, path1\n                    elif path1 > max2:\n                        max2 = path1\n            return max1 + 1, max2\n\n        tree = [[] for _ in range(len(parent))]\n        for i, p in enumerate(parent):\n            if p != -1:\n                tree[p].append(i)\n\n        path1, path2 = dfs(0, \"\")\n        return path1 + path2\n```", "extracted_code": "\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        def dfs(node: int, parent_char: str) -> Tuple[int, int]:\n            max1 = max2 = 0\n            for child in tree[node]:\n                if s[child] != parent_char:\n                    path1, path2 = dfs(child, s[node])\n                    if path1 > max1:\n                        max2, max1 = max1, path1\n                    elif path1 > max2:\n                        max2 = path1\n            return max1 + 1, max2\n\n        tree = [[] for _ in range(len(parent))]\n        for i, p in enumerate(parent):\n            if p != -1:\n                tree[p].append(i)\n\n        path1, path2 = dfs(0, \"\")\n        return path1 + path2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2245", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        def count_twos_and_fives(x):\n            twos, fives = 0, 0\n            while x % 2 == 0:\n                twos += 1\n                x //= 2\n            while x % 5 == 0:\n                fives += 1\n                x //= 5\n            return twos, fives\n\n        m, n = len(grid), len(grid[0])\n        dp = [[(0, 0) for _ in range(n)] for _ in range(m)]\n\n        dp[0][0] = count_twos_and_fives(grid[0][0])\n        for i in range(1, m):\n            twos, fives = count_twos_and_fives(grid[i][0])\n            dp[i][0] = twos + dp[i - 1][0][0], fives + dp[i - 1][0][1]\n        for j in range(1, n):\n            twos, fives = count_twos_and_fives(grid[0][j])\n            dp[0][j] = twos + dp[0][j - 1][0], fives + dp[0][j - 1][1]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                twos, fives = count_twos_and_fives(grid[i][j])\n                dp[i][j] = max(twos + dp[i - 1][j][0], twos + dp[i][j - 1][0]), max(fives + dp[i - 1][j][1], fives + dp[i][j - 1][1])\n\n        return min(dp[-1][-1])\n```", "extracted_code": "\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        def count_twos_and_fives(x):\n            twos, fives = 0, 0\n            while x % 2 == 0:\n                twos += 1\n                x //= 2\n            while x % 5 == 0:\n                fives += 1\n                x //= 5\n            return twos, fives\n\n        m, n = len(grid), len(grid[0])\n        dp = [[(0, 0) for _ in range(n)] for _ in range(m)]\n\n        dp[0][0] = count_twos_and_fives(grid[0][0])\n        for i in range(1, m):\n            twos, fives = count_twos_and_fives(grid[i][0])\n            dp[i][0] = twos + dp[i - 1][0][0], fives + dp[i - 1][0][1]\n        for j in range(1, n):\n            twos, fives = count_twos_and_fives(grid[0][j])\n            dp[0][j] = twos + dp[0][j - 1][0], fives + dp[0][j - 1][1]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                twos, fives = count_twos_and_fives(grid[i][j])\n                dp[i][j] = max(twos + dp[i - 1][j][0], twos + dp[i][j - 1][0]), max(fives + dp[i - 1][j][1], fives + dp[i][j - 1][1])\n\n        return min(dp[-1][-1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2242", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def maximumScore(scores: List[int], edges: List[List[int]]) -> int:\n    from collections import defaultdict\n    \n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    max_score = -1\n\n    for i in range(len(scores)):\n        for j in graph[i]:\n            for k in graph[j]:\n                if k != i:\n                    for l in graph[k]:\n                        if l not in (i, j) and i in graph[l]:\n                            max_score = max(max_score, scores[i] + scores[j] + scores[k] + scores[l])\n\n    return max_score", "extracted_code": "def maximumScore(scores: List[int], edges: List[List[int]]) -> int:\n    from collections import defaultdict\n    \n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    max_score = -1\n\n    for i in range(len(scores)):\n        for j in graph[i]:\n            for k in graph[j]:\n                if k != i:\n                    for l in graph[k]:\n                        if l not in (i, j) and i in graph[l]:\n                            max_score = max(max_score, scores[i] + scores[j] + scores[k] + scores[l])\n\n    return max_score", "difficulty": 3.0}
{"task_id": "LeetCode/2241", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount: List[int]) -> None:\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount: int) -> List[int]:\n        values = [20, 50, 100, 200, 500]\n        used_notes = [0, 0, 0, 0, 0]\n\n        for i in range(4, -1, -1):\n            while self.banknotes[i] > 0 and amount >= values[i]:\n                amount -= values[i]\n                self.banknotes[i] -= 1\n                used_notes[i] += 1\n\n            if amount == 0:\n                break\n\n        if amount != 0:\n            for i in range(5):\n                self.banknotes[i] += used_notes[i]\n            return [-1]\n\n        return used_notes", "extracted_code": "class ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount: List[int]) -> None:\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount: int) -> List[int]:\n        values = [20, 50, 100, 200, 500]\n        used_notes = [0, 0, 0, 0, 0]\n\n        for i in range(4, -1, -1):\n            while self.banknotes[i] > 0 and amount >= values[i]:\n                amount -= values[i]\n                self.banknotes[i] -= 1\n                used_notes[i] += 1\n\n            if amount == 0:\n                break\n\n        if amount != 0:\n            for i in range(5):\n                self.banknotes[i] += used_notes[i]\n            return [-1]\n\n        return used_notes", "difficulty": 2.0}
{"task_id": "LeetCode/2234", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        flowers.sort()\n        max_beauty = 0\n        \n        for i in range(len(flowers) + 1):\n            remaining_flowers = newFlowers\n            temp_beauty = full * i\n            temp_gardens = flowers[:i] + [flowers[j] - target for j in range(i, len(flowers))]\n            \n            if sum(temp_gardens) <= remaining_flowers:\n                temp_beauty += partial * min(temp_gardens + [remaining_flowers - sum(temp_gardens)])\n                max_beauty = max(max_beauty, temp_beauty)\n                \n            else:\n                temp_gardens.sort()\n                for j in range(len(temp_gardens)):\n                    if remaining_flowers >= temp_gardens[j]:\n                        remaining_flowers -= temp_gardens[j]\n                        temp_gardens[j] = 0\n                    else:\n                        temp_gardens[j] -= remaining_flowers\n                        remaining_flowers = 0\n                        break\n                \n                temp_beauty += partial * min(temp_gardens)\n                max_beauty = max(max_beauty, temp_beauty)\n        \n        return max_beauty\n```", "extracted_code": "\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        flowers.sort()\n        max_beauty = 0\n        \n        for i in range(len(flowers) + 1):\n            remaining_flowers = newFlowers\n            temp_beauty = full * i\n            temp_gardens = flowers[:i] + [flowers[j] - target for j in range(i, len(flowers))]\n            \n            if sum(temp_gardens) <= remaining_flowers:\n                temp_beauty += partial * min(temp_gardens + [remaining_flowers - sum(temp_gardens)])\n                max_beauty = max(max_beauty, temp_beauty)\n                \n            else:\n                temp_gardens.sort()\n                for j in range(len(temp_gardens)):\n                    if remaining_flowers >= temp_gardens[j]:\n                        remaining_flowers -= temp_gardens[j]\n                        temp_gardens[j] = 0\n                    else:\n                        temp_gardens[j] -= remaining_flowers\n                        remaining_flowers = 0\n                        break\n                \n                temp_beauty += partial * min(temp_gardens)\n                max_beauty = max(max_beauty, temp_beauty)\n        \n        return max_beauty\n", "difficulty": 3.0}
{"task_id": "LeetCode/2223", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        total_score = 0\n        for i in range(len(s)):\n            score = 0\n            for j in range(i + 1):\n                if s[i - j] == s[-j - 1]:\n                    score += 1\n                else:\n                    break\n            total_score += score\n        return total_score\n```", "extracted_code": "\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        total_score = 0\n        for i in range(len(s)):\n            score = 0\n            for j in range(i + 1):\n                if s[i - j] == s[-j - 1]:\n                    score += 1\n                else:\n                    break\n            total_score += score\n        return total_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2215", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        nums1_set, nums2_set = set(nums1), set(nums2)\n        answer = [list(nums1_set - nums2_set), list(nums2_set - nums1_set)]\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        nums1_set, nums2_set = set(nums1), set(nums2)\n        answer = [list(nums1_set - nums2_set), list(nums2_set - nums1_set)]\n        return answer\n", "difficulty": 1.0}
{"task_id": "LeetCode/2206", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(nums)\n        for num, freq in count.items():\n            if freq % 2 != 0:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(nums)\n        for num, freq in count.items():\n            if freq % 2 != 0:\n                return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2160", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        digits = list(str(num))\n        digits.sort()\n        new1, new2 = '', ''\n        for i, digit in enumerate(digits):\n            if i % 2 == 0:\n                new1 += digit\n            else:\n                new2 += digit\n        return int(new1) + int(new2)\n```", "extracted_code": "\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        digits = list(str(num))\n        digits.sort()\n        new1, new2 = '', ''\n        for i, digit in enumerate(digits):\n            if i % 2 == 0:\n                new1 += digit\n            else:\n                new2 += digit\n        return int(new1) + int(new2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2148", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        return sum(min(nums) < num < max(nums) for num in nums)\n```", "extracted_code": "\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        return sum(min(nums) < num < max(nums) for num in nums)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2068", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        freq_word1 = [0] * 26\n        freq_word2 = [0] * 26\n\n        for char in word1:\n            freq_word1[ord(char) - ord('a')] += 1\n\n        for char in word2:\n            freq_word2[ord(char) - ord('a')] += 1\n\n        for i in range(26):\n            if abs(freq_word1[i] - freq_word2[i]) > 3:\n                return False\n\n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        freq_word1 = [0] * 26\n        freq_word2 = [0] * 26\n\n        for char in word1:\n            freq_word1[ord(char) - ord('a')] += 1\n\n        for char in word2:\n            freq_word2[ord(char) - ord('a')] += 1\n\n        for i in range(26):\n            if abs(freq_word1[i] - freq_word2[i]) > 3:\n                return False\n\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2053", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = []\n        for s in arr:\n            if s not in distinct_strings and arr.count(s) == 1:\n                distinct_strings.append(s)\n        return distinct_strings[k-1] if len(distinct_strings) >= k else \"\"\n```", "extracted_code": "\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = []\n        for s in arr:\n            if s not in distinct_strings and arr.count(s) == 1:\n                distinct_strings.append(s)\n        return distinct_strings[k-1] if len(distinct_strings) >= k else \"\"\n", "difficulty": 1.0}
{"task_id": "LeetCode/2032", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        result = set()\n        for num in set(nums1):\n            if num in nums2 or num in nums3:\n                result.add(num)\n        for num in set(nums2):\n            if num in nums1 or num in nums3:\n                result.add(num)\n        for num in set(nums3):\n            if num in nums1 or num in nums2:\n                result.add(num)\n\n        return list(result)\n```", "extracted_code": "\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        result = set()\n        for num in set(nums1):\n            if num in nums2 or num in nums3:\n                result.add(num)\n        for num in set(nums2):\n            if num in nums1 or num in nums3:\n                result.add(num)\n        for num in set(nums3):\n            if num in nums1 or num in nums2:\n                result.add(num)\n\n        return list(result)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2027", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        moves = 0\n        i = 0\n        while i < len(s):\n            if s[i] == 'X':\n                moves += 1\n                i += 3\n            else:\n                i += 1\n        return moves\n```", "extracted_code": "\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        moves = 0\n        i = 0\n        while i < len(s):\n            if s[i] == 'X':\n                moves += 1\n                i += 3\n            else:\n                i += 1\n        return moves\n", "difficulty": 1.0}
{"task_id": "LeetCode/2006", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1995", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for a in range(n-3):\n            for b in range(a+1, n-2):\n                for c in range(b+1, n-1):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for a in range(n-3):\n            for b in range(a+1, n-2):\n                for c in range(b+1, n-1):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1974", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def minTimeToType(self, word: str) -> int:\n        time = 0\n        pointer = 'a'\n        \n        for char in word:\n            clockwise = ord(char) - ord(pointer)\n            counter_clockwise = ord(pointer) - ord(char)\n            \n            if clockwise < 0:\n                clockwise += 26\n            if counter_clockwise < 0:\n                counter_clockwise += 26\n                \n            time += min(clockwise, counter_clockwise) + 1\n            pointer = char\n            \n        return time", "extracted_code": "class Solution:\n    def minTimeToType(self, word: str) -> int:\n        time = 0\n        pointer = 'a'\n        \n        for char in word:\n            clockwise = ord(char) - ord(pointer)\n            counter_clockwise = ord(pointer) - ord(char)\n            \n            if clockwise < 0:\n                clockwise += 26\n            if counter_clockwise < 0:\n                counter_clockwise += 26\n                \n            time += min(clockwise, counter_clockwise) + 1\n            pointer = char\n            \n        return time", "difficulty": 1.0}
{"task_id": "LeetCode/1971", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        def dfs(vertex, visited):\n            if vertex == destination:\n                return True\n            visited.add(vertex)\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    if dfs(neighbor, visited):\n                        return True\n            return False\n        \n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        return dfs(source, set())\n```", "extracted_code": "\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        def dfs(vertex, visited):\n            if vertex == destination:\n                return True\n            visited.add(vertex)\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    if dfs(neighbor, visited):\n                        return True\n            return False\n        \n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        return dfs(source, set())\n", "difficulty": 1.0}
{"task_id": "LeetCode/1925", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a ** 2 + b ** 2) ** 0.5\n                if c <= n and c == int(c):\n                    count += 2\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a ** 2 + b ** 2) ** 0.5\n                if c <= n and c == int(c):\n                    count += 2\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1920", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n```", "extracted_code": "\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1886", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = [list(row[::-1]) for row in zip(*mat)]\n        return False\n```", "extracted_code": "\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = [list(row[::-1]) for row in zip(*mat)]\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1880", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def word_value(word: str) -> int:\n            return int(''.join(str(ord(c) - ord('a')) for c in word))\n        \n        return word_value(firstWord) + word_value(secondWord) == word_value(targetWord)\n```", "extracted_code": "\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def word_value(word: str) -> int:\n            return int(''.join(str(ord(c) - ord('a')) for c in word))\n        \n        return word_value(firstWord) + word_value(secondWord) == word_value(targetWord)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1854", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        population = [0] * 101\n        for birth, death in logs:\n            for year in range(birth - 1950, death - 1950):\n                population[year] += 1\n\n        max_population = max(population)\n        return population.index(max_population) + 1950\n```", "extracted_code": "\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        population = [0] * 101\n        for birth, death in logs:\n            for year in range(birth - 1950, death - 1950):\n                population[year] += 1\n\n        max_population = max(population)\n        return population.index(max_population) + 1950\n", "difficulty": 1.0}
{"task_id": "LeetCode/1837", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        def to_base_k(num: int, base: int) -> str:\n            if num == 0:\n                return \"0\"\n            res = []\n            while num:\n                res.append(str(num % base))\n                num //= base\n            return \"\".join(res[::-1])\n\n        n_base_k = to_base_k(n, k)\n        return sum(int(digit) for digit in n_base_k)\n```", "extracted_code": "\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        def to_base_k(num: int, base: int) -> str:\n            if num == 0:\n                return \"0\"\n            res = []\n            while num:\n                res.append(str(num % base))\n                num //= base\n            return \"\".join(res[::-1])\n\n        n_base_k = to_base_k(n, k)\n        return sum(int(digit) for digit in n_base_k)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1800", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = current_sum = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_sum += nums[i]\n            else:\n                current_sum = nums[i]\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = current_sum = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_sum += nums[i]\n            else:\n                current_sum = nums[i]\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n", "difficulty": 1.0}
{"task_id": "LeetCode/1768", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = []\n        for i in range(max(len(word1), len(word2))):\n            if i < len(word1):\n                merged.append(word1[i])\n            if i < len(word2):\n                merged.append(word2[i])\n        return ''.join(merged)\n```", "extracted_code": "\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = []\n        for i in range(max(len(word1), len(word2))):\n            if i < len(word1):\n                merged.append(word1[i])\n            if i < len(word2):\n                merged.append(word2[i])\n        return ''.join(merged)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1758", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        count1, count2 = 0, 0\n        for i in range(len(s)):\n            if i % 2 == 0:\n                if s[i] == '0':\n                    count1 += 1\n                else:\n                    count2 += 1\n            else:\n                if s[i] == '1':\n                    count1 += 1\n                else:\n                    count2 += 1\n\n        return min(count1, count2)\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        count1, count2 = 0, 0\n        for i in range(len(s)):\n            if i % 2 == 0:\n                if s[i] == '0':\n                    count1 += 1\n                else:\n                    count2 += 1\n            else:\n                if s[i] == '1':\n                    count1 += 1\n                else:\n                    count2 += 1\n\n        return min(count1, count2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1748", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        unique_nums = [num for num in set(nums) if nums.count(num) == 1]\n        return sum(unique_nums)\n```", "extracted_code": "\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        unique_nums = [num for num in set(nums) if nums.count(num) == 1]\n        return sum(unique_nums)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1656", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class OrderedStream:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.data = [None] * (n + 1)\n        self.ptr = 1\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        self.data[idKey] = value\n        result = []\n        if idKey == self.ptr:\n            while self.ptr < self.n + 1 and self.data[self.ptr]:\n                result.append(self.data[self.ptr])\n                self.ptr += 1\n        return result", "extracted_code": "class OrderedStream:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.data = [None] * (n + 1)\n        self.ptr = 1\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        self.data[idKey] = value\n        result = []\n        if idKey == self.ptr:\n            while self.ptr < self.n + 1 and self.data[self.ptr]:\n                result.append(self.data[self.ptr])\n                self.ptr += 1\n        return result", "difficulty": 1.0}
{"task_id": "LeetCode/1640", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        pieces_dict = {piece[0]: piece for piece in pieces}\n        result = []\n        for num in arr:\n            result += pieces_dict.get(num, [])\n        return result == arr\n```", "extracted_code": "\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        pieces_dict = {piece[0]: piece for piece in pieces}\n        result = []\n        for num in arr:\n            result += pieces_dict.get(num, [])\n        return result == arr\n", "difficulty": 1.0}
{"task_id": "LeetCode/1619", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        cut = n // 20\n        return sum(arr[cut:n - cut]) / (n - 2 * cut)\n```", "extracted_code": "\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        cut = n // 20\n        return sum(arr[cut:n - cut]) / (n - 2 * cut)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1614", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n```", "extracted_code": "\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n", "difficulty": 1.0}
{"task_id": "LeetCode/1582", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        row_sums = [sum(row) for row in mat]\n        col_sums = [sum(mat[i][j] for i in range(m)) for j in range(n)]\n        \n        special_positions = 0\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1 and row_sums[i] == 1 and col_sums[j] == 1:\n                    special_positions += 1\n        \n        return special_positions\n```", "extracted_code": "\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        row_sums = [sum(row) for row in mat]\n        col_sums = [sum(mat[i][j] for i in range(m)) for j in range(n)]\n        \n        special_positions = 0\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1 and row_sums[i] == 1 and col_sums[j] == 1:\n                    special_positions += 1\n        \n        return special_positions\n", "difficulty": 1.0}
{"task_id": "LeetCode/1566", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        if len(arr) < m * k:\n            return False\n        \n        for i in range(len(arr) - m * k + 1):\n            if arr[i:i + m] * k == arr[i:i + m * k]:\n                return True\n                \n        return False\n```", "extracted_code": "\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        if len(arr) < m * k:\n            return False\n        \n        for i in range(len(arr) - m * k + 1):\n            if arr[i:i + m] * k == arr[i:i + m * k]:\n                return True\n                \n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1556", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        num_str = str(n)\n        num_str = num_str[::-1]\n        result = \"\"\n        for i, digit in enumerate(num_str):\n            if i % 3 == 0 and i != 0:\n                result += \".\"\n            result += digit\n        return result[::-1]\n```", "extracted_code": "\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        num_str = str(n)\n        num_str = num_str[::-1]\n        result = \"\"\n        for i, digit in enumerate(num_str):\n            if i % 3 == 0 and i != 0:\n                result += \".\"\n            result += digit\n        return result[::-1]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1534", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if abs(arr[i] - arr[j]) <= a:\n                    for k in range(j + 1, len(arr)):\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if abs(arr[i] - arr[j]) <= a:\n                    for k in range(j + 1, len(arr)):\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                            count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1496", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y = 0, 0\n        visited = {(0, 0)}\n\n        for direction in path:\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            elif direction == 'W':\n                x -= 1\n\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y = 0, 0\n        visited = {(0, 0)}\n\n        for direction in path:\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            elif direction == 'W':\n                x -= 1\n\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1486", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        xor_result = 0\n        for i in range(n):\n            nums = start + 2 * i\n            xor_result ^= nums\n        return xor_result\n```", "extracted_code": "\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        xor_result = 0\n        for i in range(n):\n            nums = start + 2 * i\n            xor_result ^= nums\n        return xor_result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1464", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max1, max2 = 0, 0\n        for num in nums:\n            if num > max1:\n                max2 = max1\n                max1 = num\n            elif num > max2:\n                max2 = num\n        return (max1 - 1) * (max2 - 1)\n```", "extracted_code": "\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max1, max2 = 0, 0\n        for num in nums:\n            if num > max1:\n                max2 = max1\n                max1 = num\n            elif num > max2:\n                max2 = num\n        return (max1 - 1) * (max2 - 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1431", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candies = max(candies)\n        result = [candy + extraCandies >= max_candies for candy in candies]\n        return result\n```", "extracted_code": "\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candies = max(candies)\n        result = [candy + extraCandies >= max_candies for candy in candies]\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1422", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        left_zeros = 0\n        right_ones = s.count('1')\n        max_score = 0\n\n        for i in range(len(s) - 1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                right_ones -= 1\n            max_score = max(max_score, left_zeros + right_ones)\n\n        return max_score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        left_zeros = 0\n        right_ones = s.count('1')\n        max_score = 0\n\n        for i in range(len(s) - 1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                right_ones -= 1\n            max_score = max(max_score, left_zeros + right_ones)\n\n        return max_score\n", "difficulty": 1.0}
{"task_id": "LeetCode/1408", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        substrings = []\n        for word in words:\n            for other_word in words:\n                if word != other_word and word in other_word:\n                    substrings.append(word)\n                    break\n        return substrings\n```", "extracted_code": "\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        substrings = []\n        for word in words:\n            for other_word in words:\n                if word != other_word and word in other_word:\n                    substrings.append(word)\n                    break\n        return substrings\n", "difficulty": 1.0}
{"task_id": "LeetCode/1399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        def sum_digits(num):\n            return sum(int(digit) for digit in str(num))\n\n        groups = {}\n        for i in range(1, n + 1):\n            group_key = sum_digits(i)\n            if group_key in groups:\n                groups[group_key].append(i)\n            else:\n                groups[group_key] = [i]\n\n        max_group_size = max(len(group) for group in groups.values())\n        return sum(1 for group in groups.values() if len(group) == max_group_size)\n```", "extracted_code": "\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        def sum_digits(num):\n            return sum(int(digit) for digit in str(num))\n\n        groups = {}\n        for i in range(1, n + 1):\n            group_key = sum_digits(i)\n            if group_key in groups:\n                groups[group_key].append(i)\n            else:\n                groups[group_key] = [i]\n\n        max_group_size = max(len(group) for group in groups.values())\n        return sum(1 for group in groups.values() if len(group) == max_group_size)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1360", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        def is_leap_year(year):\n            return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n        def days_in_month(year, month):\n            if month in [4, 6, 9, 11]:\n                return 30\n            if month == 2:\n                return 29 if is_leap_year(year) else 28\n            return 31\n\n        def days_since_1971(year, month, day):\n            days = 0\n            for y in range(1971, year):\n                days += 366 if is_leap_year(y) else 365\n            for m in range(1, month):\n                days += days_in_month(year, m)\n            days += day - 1\n            return days\n\n        y1, m1, d1 = map(int, date1.split('-'))\n        y2, m2, d2 = map(int, date2.split('-'))\n        return abs(days_since_1971(y1, m1, d1) - days_since_1971(y2, m2, d2))\n ```", "extracted_code": "\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        def is_leap_year(year):\n            return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n        def days_in_month(year, month):\n            if month in [4, 6, 9, 11]:\n                return 30\n            if month == 2:\n                return 29 if is_leap_year(year) else 28\n            return 31\n\n        def days_since_1971(year, month, day):\n            days = 0\n            for y in range(1971, year):\n                days += 366 if is_leap_year(y) else 365\n            for m in range(1, month):\n                days += days_in_month(year, m)\n            days += day - 1\n            return days\n\n        y1, m1, d1 = map(int, date1.split('-'))\n        y2, m2, d2 = map(int, date2.split('-'))\n        return abs(days_since_1971(y1, m1, d1) - days_since_1971(y2, m2, d2))\n ", "difficulty": 1.0}
{"task_id": "LeetCode/1323", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def maximum69Number(self, num: int) -> int:\n        num_str = str(num)\n        num_str = num_str.replace('6', '9', 1)\n        return int(num_str)", "extracted_code": "class Solution:\n    def maximum69Number(self, num: int) -> int:\n        num_str = str(num)\n        num_str = num_str.replace('6', '9', 1)\n        return int(num_str)", "difficulty": 1.0}
{"task_id": "LeetCode/1304", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        result = list(range(1, n))\n        result.append(-sum(result))\n        return result\n```", "extracted_code": "\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        result = list(range(1, n))\n        result.append(-sum(result))\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1266", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time_taken = 0\n        for i in range(len(points) - 1):\n            x_diff = abs(points[i][0] - points[i + 1][0])\n            y_diff = abs(points[i][1] - points[i + 1][1])\n            time_taken += max(x_diff, y_diff)\n        return time_taken", "extracted_code": "class Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time_taken = 0\n        for i in range(len(points) - 1):\n            x_diff = abs(points[i][0] - points[i + 1][0])\n            y_diff = abs(points[i][1] - points[i + 1][1])\n            time_taken += max(x_diff, y_diff)\n        return time_taken", "difficulty": 1.0}
{"task_id": "LeetCode/1252", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        row_counts = [0] * m\n        col_counts = [0] * n\n        \n        for r, c in indices:\n            row_counts[r] += 1\n            col_counts[c] += 1\n\n        odd_cells = 0\n        for i in range(m):\n            for j in range(n):\n                if (row_counts[i] + col_counts[j]) % 2 == 1:\n                    odd_cells += 1\n\n        return odd_cells\n```", "extracted_code": "\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        row_counts = [0] * m\n        col_counts = [0] * n\n        \n        for r, c in indices:\n            row_counts[r] += 1\n            col_counts[c] += 1\n\n        odd_cells = 0\n        for i in range(m):\n            for j in range(n):\n                if (row_counts[i] + col_counts[j]) % 2 == 1:\n                    odd_cells += 1\n\n        return odd_cells\n", "difficulty": 1.0}
{"task_id": "LeetCode/1207", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(arr)\n        return len(count) == len(set(count.values()))\n```", "extracted_code": "\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(arr)\n        return len(count) == len(set(count.values()))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1200", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        min_diff = float('inf')\n        result = []\n        \n        for i in range(len(arr) - 1):\n            diff = arr[i+1] - arr[i]\n            if diff < min_diff:\n                min_diff = diff\n                result = [[arr[i], arr[i+1]]]\n            elif diff == min_diff:\n                result.append([arr[i], arr[i+1]])\n                \n        return result\n```", "extracted_code": "\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        min_diff = float('inf')\n        result = []\n        \n        for i in range(len(arr) - 1):\n            diff = arr[i+1] - arr[i]\n            if diff < min_diff:\n                min_diff = diff\n                result = [[arr[i], arr[i+1]]]\n            elif diff == min_diff:\n                result.append([arr[i], arr[i+1]])\n                \n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1175", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        def factorial(num):\n            result = 1\n            for i in range(1, num + 1):\n                result = (result * i) % (10**9 + 7)\n            return result\n\n        prime_count = sum(is_prime(num) for num in range(1, n + 1))\n        return (factorial(prime_count) * factorial(n - prime_count)) % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        def factorial(num):\n            result = 1\n            for i in range(1, num + 1):\n                result = (result * i) % (10**9 + 7)\n            return result\n\n        prime_count = sum(is_prime(num) for num in range(1, n + 1))\n        return (factorial(prime_count) * factorial(n - prime_count)) % (10**9 + 7)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1128", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        domino_dict = {}\n        count = 0\n        for domino in dominoes:\n            domino.sort()\n            key = tuple(domino)\n            if key in domino_dict:\n                count += domino_dict[key]\n                domino_dict[key] += 1\n            else:\n                domino_dict[key] = 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        domino_dict = {}\n        count = 0\n        for domino in dominoes:\n            domino.sort()\n            key = tuple(domino)\n            if key in domino_dict:\n                count += domino_dict[key]\n                domino_dict[key] += 1\n            else:\n                domino_dict[key] = 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1108", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace(\".\", \"[.]\")\n```", "extracted_code": "\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace(\".\", \"[.]\")\n", "difficulty": 1.0}
{"task_id": "LeetCode/1103", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        ans = [0] * num_people\n        i = 0\n        while candies > 0:\n            ans[i % num_people] += min(candies, i + 1)\n            candies -= i + 1\n            i += 1\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        ans = [0] * num_people\n        i = 0\n        while candies > 0:\n            ans[i % num_people] += min(candies, i + 1)\n            candies -= i + 1\n            i += 1\n        return ans\n", "difficulty": 1.0}
{"task_id": "LeetCode/1071", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        if str2 == \"\":\n            return str1\n        elif str1[:len(str2)] != str2:\n            return \"\"\n        else:\n            return self.gcdOfStrings(str1[len(str2):], str2)\n```", "extracted_code": "\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        if str2 == \"\":\n            return str1\n        elif str1[:len(str2)] != str2:\n            return \"\"\n        else:\n            return self.gcdOfStrings(str1[len(str2):], str2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1025", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        return n % 2 == 0\n```", "extracted_code": "\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        return n % 2 == 0\n", "difficulty": 1.0}
{"task_id": "LeetCode/1009", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        binary_representation = bin(n)[2:]\n        complement = ''.join('1' if bit == '0' else '0' for bit in binary_representation)\n        return int(complement, 2)\n```", "extracted_code": "\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        binary_representation = bin(n)[2:]\n        complement = ''.join('1' if bit == '0' else '0' for bit in binary_representation)\n        return int(complement, 2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/993", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        queue = [(root, 0, None)]\n        depth_x = depth_y = -1\n        parent_x = parent_y = None\n\n        while queue:\n            node, depth, parent = queue.pop(0)\n            if node.val == x:\n                depth_x = depth\n                parent_x = parent\n            if node.val == y:\n                depth_y = depth\n                parent_y = parent\n            if depth_x != -1 and depth_y != -1:\n                break\n            if node.left:\n                queue.append((node.left, depth + 1, node))\n            if node.right:\n                queue.append((node.right, depth + 1, node))\n\n        return depth_x == depth_y and parent_x != parent_y\n```", "extracted_code": "\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        queue = [(root, 0, None)]\n        depth_x = depth_y = -1\n        parent_x = parent_y = None\n\n        while queue:\n            node, depth, parent = queue.pop(0)\n            if node.val == x:\n                depth_x = depth\n                parent_x = parent\n            if node.val == y:\n                depth_y = depth\n                parent_y = parent\n            if depth_x != -1 and depth_y != -1:\n                break\n            if node.left:\n                queue.append((node.left, depth + 1, node))\n            if node.right:\n                queue.append((node.right, depth + 1, node))\n\n        return depth_x == depth_y and parent_x != parent_y\n", "difficulty": 1.0}
{"task_id": "LeetCode/965", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        if root.left and root.left.val != root.val:\n            return False\n        if root.right and root.right.val != root.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n```", "extracted_code": "\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        if root.left and root.left.val != root.val:\n            return False\n        if root.right and root.right.val != root.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/953", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        order_dict = {char: i for i, char in enumerate(order)}\n\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i + 1]\n\n            for j in range(min(len(word1), len(word2))):\n                if word1[j] != word2[j]:\n                    if order_dict[word1[j]] > order_dict[word2[j]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        order_dict = {char: i for i, char in enumerate(order)}\n\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i + 1]\n\n            for j in range(min(len(word1), len(word2))):\n                if word1[j] != word2[j]:\n                    if order_dict[word1[j]] > order_dict[word2[j]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/944", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        deletion_count = 0\n        for col in zip(*strs):\n            if list(col) != sorted(col):\n                deletion_count += 1\n        return deletion_count\n```", "extracted_code": "\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        deletion_count = 0\n        for col in zip(*strs):\n            if list(col) != sorted(col):\n                deletion_count += 1\n        return deletion_count\n", "difficulty": 1.0}
{"task_id": "LeetCode/933", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)\n\n# Your RecentCounter object will be instantiated and called as such:\n# obj = RecentCounter()\n# param_1 = obj.ping(t)", "extracted_code": "class RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)\n\n# Your RecentCounter object will be instantiated and called as such:\n# obj = RecentCounter()\n# param_1 = obj.ping(t)", "difficulty": 1.0}
{"task_id": "LeetCode/914", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        from collections import Counter\n        from math import gcd\n        from functools import reduce\n\n        count = Counter(deck)\n        return reduce(gcd, count.values()) > 1\n```", "extracted_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        from collections import Counter\n        from math import gcd\n        from functools import reduce\n\n        count = Counter(deck)\n        return reduce(gcd, count.values()) > 1\n", "difficulty": 1.0}
{"task_id": "LeetCode/892", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        total_area = 0\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    total_area += 2 + grid[i][j] * 4\n                    \n                    if i > 0:\n                        total_area -= min(grid[i][j], grid[i-1][j]) * 2\n                        \n                    if j > 0:\n                        total_area -= min(grid[i][j], grid[i][j-1]) * 2\n                        \n        return total_area\n```", "extracted_code": "\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        total_area = 0\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    total_area += 2 + grid[i][j] * 4\n                    \n                    if i > 0:\n                        total_area -= min(grid[i][j], grid[i-1][j]) * 2\n                        \n                    if j > 0:\n                        total_area -= min(grid[i][j], grid[i][j-1]) * 2\n                        \n        return total_area\n", "difficulty": 1.0}
{"task_id": "LeetCode/888", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        diff = (sum(aliceSizes) - sum(bobSizes)) // 2\n        alice_set = set(aliceSizes)\n        for box in bobSizes:\n            if diff + box in alice_set:\n                return [diff + box, box]\n```", "extracted_code": "\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        diff = (sum(aliceSizes) - sum(bobSizes)) // 2\n        alice_set = set(aliceSizes)\n        for box in bobSizes:\n            if diff + box in alice_set:\n                return [diff + box, box]\n", "difficulty": 1.0}
{"task_id": "LeetCode/867", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n```", "extracted_code": "\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/844", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        def process_string(string):\n            stack = []\n            for char in string:\n                if char == '#' and stack:\n                    stack.pop()\n                elif char != '#':\n                    stack.append(char)\n            return ''.join(stack)\n\n        return process_string(s) == process_string(t)\n```", "extracted_code": "\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        def process_string(string):\n            stack = []\n            for char in string:\n                if char == '#' and stack:\n                    stack.pop()\n                elif char != '#':\n                    stack.append(char)\n            return ''.join(stack)\n\n        return process_string(s) == process_string(t)\n", "difficulty": 1.0}
{"task_id": "LeetCode/830", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        result = []\n        i = 0\n        while i < len(s):\n            start = i\n            end = i\n            while end < len(s) - 1 and s[end] == s[end + 1]:\n                end += 1\n            if end - start >= 2:\n                result.append([start, end])\n            i = end + 1\n        return result\n```", "extracted_code": "\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        result = []\n        i = 0\n        while i < len(s):\n            start = i\n            end = i\n            while end < len(s) - 1 and s[end] == s[end + 1]:\n                end += 1\n            if end - start >= 2:\n                result.append([start, end])\n            i = end + 1\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/804", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        transformations = set()\n        \n        for word in words:\n            transformed_word = \"\".join([morse_codes[ord(letter) - ord('a')] for letter in word])\n            transformations.add(transformed_word)\n        \n        return len(transformations)\n```", "extracted_code": "\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse_codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        transformations = set()\n        \n        for word in words:\n            transformed_word = \"\".join([morse_codes[ord(letter) - ord('a')] for letter in word])\n            transformations.add(transformed_word)\n        \n        return len(transformations)\n", "difficulty": 1.0}
{"task_id": "LeetCode/762", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        count = 0\n        for num in range(left, right + 1):\n            set_bits = bin(num).count('1')\n            if is_prime(set_bits):\n                count += 1\n\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        count = 0\n        for num in range(left, right + 1):\n            set_bits = bin(num).count('1')\n            if is_prime(set_bits):\n                count += 1\n\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/728", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        def is_self_dividing(num):\n            for digit in str(num):\n                if digit == '0' or num % int(digit) > 0:\n                    return False\n            return True\n\n        return [num for num in range(left, right + 1) if is_self_dividing(num)]\n```", "extracted_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        def is_self_dividing(num):\n            for digit in str(num):\n                if digit == '0' or num % int(digit) > 0:\n                    return False\n            return True\n\n        return [num for num in range(left, right + 1) if is_self_dividing(num)]\n", "difficulty": 1.0}
{"task_id": "LeetCode/706", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class MyHashMap:\n\n    def __init__(self):\n        self.map = {}\n\n    def put(self, key: int, value: int) -> None:\n        self.map[key] = value\n\n    def get(self, key: int) -> int:\n        return self.map.get(key, -1)\n\n    def remove(self, key: int) -> None:\n        if key in self.map:\n            del self.map[key]\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)", "extracted_code": "class MyHashMap:\n\n    def __init__(self):\n        self.map = {}\n\n    def put(self, key: int, value: int) -> None:\n        self.map[key] = value\n\n    def get(self, key: int) -> int:\n        return self.map.get(key, -1)\n\n    def remove(self, key: int) -> None:\n        if key in self.map:\n            del self.map[key]\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)", "difficulty": 1.0}
{"task_id": "LeetCode/704", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/682", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        \n        for op in operations:\n            if op == '+':\n                record.append(record[-1] + record[-2])\n            elif op == 'D':\n                record.append(record[-1] * 2)\n            elif op == 'C':\n                record.pop()\n            else:\n                record.append(int(op))\n                \n        return sum(record)\n```", "extracted_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        \n        for op in operations:\n            if op == '+':\n                record.append(record[-1] + record[-2])\n            elif op == 'D':\n                record.append(record[-1] * 2)\n            elif op == 'C':\n                record.pop()\n            else:\n                record.append(int(op))\n                \n        return sum(record)\n", "difficulty": 1.0}
{"task_id": "LeetCode/680", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return is_palindrome(s[left:right]) or is_palindrome(s[left + 1:right + 1])\n            left += 1\n            right -= 1\n        return True\n```", "extracted_code": "\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return is_palindrome(s[left:right]) or is_palindrome(s[left + 1:right + 1])\n            left += 1\n            right -= 1\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/674", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        longest, current = 0, 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current += 1\n            else:\n                longest = max(longest, current)\n                current = 1\n        return max(longest, current)\n```", "extracted_code": "\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        longest, current = 0, 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current += 1\n            else:\n                longest = max(longest, current)\n                current = 1\n        return max(longest, current)\n", "difficulty": 1.0}
{"task_id": "LeetCode/671", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return -1\n            if node.val > root.val:\n                return node.val\n            left = dfs(node.left)\n            right = dfs(node.right)\n            if left == -1:\n                return right\n            if right == -1:\n                return left\n            return min(left, right)\n\n        return dfs(root)\n```", "extracted_code": "\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if not node:\n                return -1\n            if node.val > root.val:\n                return node.val\n            left = dfs(node.left)\n            right = dfs(node.right)\n            if left == -1:\n                return right\n            if right == -1:\n                return left\n            return min(left, right)\n\n        return dfs(root)\n", "difficulty": 1.0}
{"task_id": "LeetCode/645", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        sum_nums = sum(nums)\n        sum_unique_nums = sum(set(nums))\n        duplicate = sum_nums - sum_unique_nums\n        missing = (n * (n + 1)) // 2 - sum_unique_nums\n        return [duplicate, missing]\n```", "extracted_code": "\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        sum_nums = sum(nums)\n        sum_unique_nums = sum(set(nums))\n        duplicate = sum_nums - sum_unique_nums\n        missing = (n * (n + 1)) // 2 - sum_unique_nums\n        return [duplicate, missing]\n", "difficulty": 1.0}
{"task_id": "LeetCode/617", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n\n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n\n        return root1\n```", "extracted_code": "\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n\n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n\n        return root1\n", "difficulty": 1.0}
{"task_id": "LeetCode/599", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def findRestaurant(list1: List[str], list2: List[str]) -> List[str]:\n    common_strings = set(list1) & set(list2)\n    index_sums = {string: list1.index(string) + list2.index(string) for string in common_strings}\n    min_sum = min(index_sums.values())\n    return [string for string, index_sum in index_sums.items() if index_sum == min_sum]", "extracted_code": "def findRestaurant(list1: List[str], list2: List[str]) -> List[str]:\n    common_strings = set(list1) & set(list2)\n    index_sums = {string: list1.index(string) + list2.index(string) for string in common_strings}\n    min_sum = min(index_sums.values())\n    return [string for string, index_sum in index_sums.items() if index_sum == min_sum]", "difficulty": 1.0}
{"task_id": "LeetCode/572", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        def isSameTree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n            if not p and not q:\n                return True\n            if not p or not q:\n                return False\n            if p.val != q.val:\n                return False\n            return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n        if not root:\n            return False\n        if isSameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n```", "extracted_code": "\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        def isSameTree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n            if not p and not q:\n                return True\n            if not p or not q:\n                return False\n            if p.val != q.val:\n                return False\n            return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n        if not root:\n            return False\n        if isSameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n", "difficulty": 1.0}
{"task_id": "LeetCode/551", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        absences = 0\n        late_streak = 0\n        \n        for day in s:\n            if day == 'A':\n                absences += 1\n                if absences >= 2:\n                    return False\n            if day == 'L':\n                late_streak += 1\n                if late_streak >= 3:\n                    return False\n            else:\n                late_streak = 0\n                \n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        absences = 0\n        late_streak = 0\n        \n        for day in s:\n            if day == 'A':\n                absences += 1\n                if absences >= 2:\n                    return False\n            if day == 'L':\n                late_streak += 1\n                if late_streak >= 3:\n                    return False\n            else:\n                late_streak = 0\n                \n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/509", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            a, b = 0, 1\n            for _ in range(2, n + 1):\n                a, b = b, a + b\n            return b\n```", "extracted_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            a, b = 0, 1\n            for _ in range(2, n + 1):\n                a, b = b, a + b\n            return b\n", "difficulty": 1.0}
