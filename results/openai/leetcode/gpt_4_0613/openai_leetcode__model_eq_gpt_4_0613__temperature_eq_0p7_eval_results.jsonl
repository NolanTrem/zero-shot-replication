{"task_id": "LeetCode/2818", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumScore(self, nums: list[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        spf = [i for i in range(10**5+5)]\n        spf[1] = 1\n        for i in range(2, int(10**5**0.5)+1):\n            if spf[i] == i:\n                for multiple in range(i*i, 10**5+5, i):\n                    if spf[multiple] == multiple:\n                        spf[multiple] = i\n        def get_factor(n):\n            factors = set()\n            while n!=1:\n                factors.add(spf[n])\n                n = n // spf[n]\n            return len(factors)\n        score = [get_factor(i) for i in nums]\n        dp = [[0]*(k+1) for _ in range(n+1)]\n        for i in range(n-1,-1,-1):\n            dp[i][0] = max(nums[i],dp[i+1][0])\n            for j in range(1,min(i+2,k+1)):\n                dp[i][j] = max(dp[i+1][j],dp[i+1][j-1]*nums[i])\n        return dp[0][k] % mod\n```", "extracted_code": "\nclass Solution:\n    def maximumScore(self, nums: list[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        spf = [i for i in range(10**5+5)]\n        spf[1] = 1\n        for i in range(2, int(10**5**0.5)+1):\n            if spf[i] == i:\n                for multiple in range(i*i, 10**5+5, i):\n                    if spf[multiple] == multiple:\n                        spf[multiple] = i\n        def get_factor(n):\n            factors = set()\n            while n!=1:\n                factors.add(spf[n])\n                n = n // spf[n]\n            return len(factors)\n        score = [get_factor(i) for i in nums]\n        dp = [[0]*(k+1) for _ in range(n+1)]\n        for i in range(n-1,-1,-1):\n            dp[i][0] = max(nums[i],dp[i+1][0])\n            for j in range(1,min(i+2,k+1)):\n                dp[i][j] = max(dp[i+1][j],dp[i+1][j-1]*nums[i])\n        return dp[0][k] % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2813", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMaximumElegance(self, items, k):\n        from collections import defaultdict\n        from heapq import heapify, heappush, heappop\n\n        categories = defaultdict(list)\n        for profit, category in items:\n            heappush(categories[category], -profit)\n\n        profits, heap = [], []\n        for category in categories:\n            profit = heappop(categories[category])\n            profits.append(-profit)\n            if categories[category]:\n                heappush(heap, (profit + categories[category][0], categories[category]))\n\n        profits.sort()\n        total_profit, total_category = sum(profits[-k:]), min(k, len(categories))\n        result = total_profit + total_category * total_category\n\n        for _ in range(min(k, len(categories)) - 1, -1, -1):\n            if not heap:\n                break\n            next_profit, category = heappop(heap)\n            total_profit = total_profit - profits[_] + (-next_profit)\n            total_category += 1\n            if category:\n                heappush(heap, (next_profit + category[0], category))\n            result = max(result, total_profit + total_category * total_category)\n\n        return result\n```", "extracted_code": "\nclass Solution:\n    def findMaximumElegance(self, items, k):\n        from collections import defaultdict\n        from heapq import heapify, heappush, heappop\n\n        categories = defaultdict(list)\n        for profit, category in items:\n            heappush(categories[category], -profit)\n\n        profits, heap = [], []\n        for category in categories:\n            profit = heappop(categories[category])\n            profits.append(-profit)\n            if categories[category]:\n                heappush(heap, (profit + categories[category][0], categories[category]))\n\n        profits.sort()\n        total_profit, total_category = sum(profits[-k:]), min(k, len(categories))\n        result = total_profit + total_category * total_category\n\n        for _ in range(min(k, len(categories)) - 1, -1, -1):\n            if not heap:\n                break\n            next_profit, category = heappop(heap)\n            total_profit = total_profit - profits[_] + (-next_profit)\n            total_category += 1\n            if category:\n                heappush(heap, (next_profit + category[0], category))\n            result = max(result, total_profit + total_category * total_category)\n\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2812", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dist = [[float('inf')] * n for _ in range(n)]\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        queue = []\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    queue.append((i, j))\n                    dist[i][j] = 0\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and max(dist[x][y], abs(nx-x) + abs(ny-y)) < dist[nx][ny]:\n                    dist[nx][ny] = max(dist[x][y], abs(nx-x) + abs(ny-y))\n                    queue.append((nx, ny))\n        return dist[n-1][n-1]\n```", "extracted_code": "\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        dist = [[float('inf')] * n for _ in range(n)]\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        queue = []\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    queue.append((i, j))\n                    dist[i][j] = 0\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and max(dist[x][y], abs(nx-x) + abs(ny-y)) < dist[nx][ny]:\n                    dist[nx][ny] = max(dist[x][y], abs(nx-x) + abs(ny-y))\n                    queue.append((nx, ny))\n        return dist[n-1][n-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2811", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canSplitArray(self, nums, m):\n        stack = [(0, len(nums))]\n        while stack:\n            l, r = stack.pop()\n            if l+1 == r:\n                continue\n            total = sum(nums[l:r])\n            if total < m:\n                return False\n            for i in range(l+1, r):\n                if sum(nums[l:i]) >= m and sum(nums[i:r]) >= m:\n                    stack.append((l, i))\n                    stack.append((i, r))\n                    break\n            else:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def canSplitArray(self, nums, m):\n        stack = [(0, len(nums))]\n        while stack:\n            l, r = stack.pop()\n            if l+1 == r:\n                continue\n            total = sum(nums[l:r])\n            if total < m:\n                return False\n            for i in range(l+1, r):\n                if sum(nums[l:i]) >= m and sum(nums[i:r]) >= m:\n                    stack.append((l, i))\n                    stack.append((i, r))\n                    break\n            else:\n                return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2809", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total, n = sum(nums1), len(nums1)\n        if total <= x:\n            return 0\n        left, right, minTime = 0, 0, float('inf')\n        currentSum = total\n        while right < n:\n            currentSum -= nums1[right]\n            while currentSum + (right - left + 1) * nums2[left] > x:\n                currentSum += nums1[left] - nums2[left]\n                left += 1\n            if currentSum <= x:\n                minTime = min(minTime, right - left + 1)\n            right += 1\n        return minTime if minTime != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total, n = sum(nums1), len(nums1)\n        if total <= x:\n            return 0\n        left, right, minTime = 0, 0, float('inf')\n        currentSum = total\n        while right < n:\n            currentSum -= nums1[right]\n            while currentSum + (right - left + 1) * nums2[left] > x:\n                currentSum += nums1[left] - nums2[left]\n                left += 1\n            if currentSum <= x:\n                minTime = min(minTime, right - left + 1)\n            right += 1\n        return minTime if minTime != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2808", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums += nums\n        q = [(0, i) for i in range(n)]\n        dist = [float('inf')] * (2 * n)\n        for i in range(n):\n            dist[i] = 0\n        while q:\n            d, i = heapq.heappop(q)\n            for j in [i - 1, i + 1]:\n                nd = d + 1\n                if nd < dist[j]:\n                    dist[j] = nd\n                    heapq.heappush(q, (nd, j))\n        return min(dist[i:i + n] for i in range(n))\n```", "extracted_code": "\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums += nums\n        q = [(0, i) for i in range(n)]\n        dist = [float('inf')] * (2 * n)\n        for i in range(n):\n            dist[i] = 0\n        while q:\n            d, i = heapq.heappop(q)\n            for j in [i - 1, i + 1]:\n                nd = d + 1\n                if nd < dist[j]:\n                    dist[j] = nd\n                    heapq.heappush(q, (nd, j))\n        return min(dist[i:i + n] for i in range(n))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2807", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nimport math\n\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def gcd(node1, node2):\n            return math.gcd(node1.val, node2.val)\n        \n        curr = head\n        \n        while curr and curr.next:\n            new_node = ListNode(gcd(curr, curr.next))\n            new_node.next = curr.next\n            curr.next = new_node\n            curr = new_node.next\n            \n        return head\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nimport math\n\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def gcd(node1, node2):\n            return math.gcd(node1.val, node2.val)\n        \n        curr = head\n        \n        while curr and curr.next:\n            new_node = ListNode(gcd(curr, curr.next))\n            new_node.next = curr.next\n            curr.next = new_node\n            curr = new_node.next\n            \n        return head\n", "difficulty": 2.0}
{"task_id": "LeetCode/2806", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = ((purchaseAmount + 10 - 1) // 10 ) * 10\n        return 100 - roundedAmount\n```", "extracted_code": "\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = ((purchaseAmount + 10 - 1) // 10 ) * 10\n        return 100 - roundedAmount\n", "difficulty": 1.0}
{"task_id": "LeetCode/2801", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        low, high = int(low), int(high)\n\n        def dfs(n):\n            if n > high:\n                return 0\n            res = low <= n <= high\n            last_digit = n % 10\n            if last_digit > 0:\n                res += dfs(n * 10 + last_digit - 1)\n            if last_digit < 9:\n                res += dfs(n * 10 + last_digit + 1)\n            return res % MOD\n\n        return sum(dfs(i) for i in range(1, 10)) % MOD\n```", "extracted_code": "\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        low, high = int(low), int(high)\n\n        def dfs(n):\n            if n > high:\n                return 0\n            res = low <= n <= high\n            last_digit = n % 10\n            if last_digit > 0:\n                res += dfs(n * 10 + last_digit - 1)\n            if last_digit < 9:\n                res += dfs(n * 10 + last_digit + 1)\n            return res % MOD\n\n        return sum(dfs(i) for i in range(1, 10)) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2800", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        strings = [a, b, c]\n        strings.sort()\n        if strings[0] in strings[1] and strings[1] in strings[2]:\n            return strings[2]\n        elif strings[0] in strings[1]:\n            return strings[1] + strings[2].replace(strings[1], \"\", 1)\n        elif strings[0] in strings[2]:\n            return strings[1] + strings[2].replace(strings[0], \"\", 1)\n        elif strings[1] in strings[2]:\n            return strings[0] + strings[2].replace(strings[1], \"\", 1)\n        else:\n            return strings[0] + strings[1] + strings[2]\n```", "extracted_code": "\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        strings = [a, b, c]\n        strings.sort()\n        if strings[0] in strings[1] and strings[1] in strings[2]:\n            return strings[2]\n        elif strings[0] in strings[1]:\n            return strings[1] + strings[2].replace(strings[1], \"\", 1)\n        elif strings[0] in strings[2]:\n            return strings[1] + strings[2].replace(strings[0], \"\", 1)\n        elif strings[1] in strings[2]:\n            return strings[0] + strings[2].replace(strings[1], \"\", 1)\n        else:\n            return strings[0] + strings[1] + strings[2]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2799", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        distinct_elements = len(set(nums))\n        counter = collections.Counter()\n        left, right = 0, 0\n        complete_subarrays = 0\n        while right < len(nums):\n            counter[nums[right]] += 1\n            while len(counter) == distinct_elements:\n                counter[nums[left]] -= 1\n                if counter[nums[left]] == 0:\n                    del counter[nums[left]]\n                complete_subarrays += len(counter)\n                left += 1\n            right += 1\n        return complete_subarrays\n```", "extracted_code": "\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        distinct_elements = len(set(nums))\n        counter = collections.Counter()\n        left, right = 0, 0\n        complete_subarrays = 0\n        while right < len(nums):\n            counter[nums[right]] += 1\n            while len(counter) == distinct_elements:\n                counter[nums[left]] -= 1\n                if counter[nums[left]] == 0:\n                    del counter[nums[left]]\n                complete_subarrays += len(counter)\n                left += 1\n            right += 1\n        return complete_subarrays\n", "difficulty": 2.0}
{"task_id": "LeetCode/2791", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        from collections import Counter\n\n        graph = [[] for _ in range(len(parent))]\n        for i in range(1, len(parent)):\n            graph[i].append(parent[i])\n            graph[parent[i]].append(i)\n\n        res = [0]\n        count = [Counter()]\n\n        def dfs(node, parent):\n            cur = count[parent] + Counter(s[node])\n            res[0] += sum(v % 2 for v in cur.values()) <= 1\n            for child in graph[node]:\n                if child != parent:\n                    count.append(cur)\n                    dfs(child, len(count) - 1)\n                    count.pop()\n\n        dfs(0, 0)\n        return res[0] - 1\n```", "extracted_code": "\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        from collections import Counter\n\n        graph = [[] for _ in range(len(parent))]\n        for i in range(1, len(parent)):\n            graph[i].append(parent[i])\n            graph[parent[i]].append(i)\n\n        res = [0]\n        count = [Counter()]\n\n        def dfs(node, parent):\n            cur = count[parent] + Counter(s[node])\n            res[0] += sum(v % 2 for v in cur.values()) <= 1\n            for child in graph[node]:\n                if child != parent:\n                    count.append(cur)\n                    dfs(child, len(count) - 1)\n                    count.pop()\n\n        dfs(0, 0)\n        return res[0] - 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2790", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort(reverse=True)\n        groups = 0\n        current_group_size = 0\n        for limit in usageLimits:\n            if limit >= current_group_size + 1:\n                groups += 1\n                current_group_size += 1\n        return groups\n```", "extracted_code": "\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort(reverse=True)\n        groups = 0\n        current_group_size = 0\n        for limit in usageLimits:\n            if limit >= current_group_size + 1:\n                groups += 1\n                current_group_size += 1\n        return groups\n", "difficulty": 3.0}
{"task_id": "LeetCode/2788", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            result.extend([x for x in word.split(separator) if x])\n        return result\n```", "extracted_code": "\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            result.extend([x for x in word.split(separator) if x])\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/2787", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, int(n ** (1.0 / x)) + 1):\n            dp[i ** x:n + 1] = [(dp[j] + dp[j - i ** x]) % MOD for j in range(i ** x, n + 1)]\n        return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, int(n ** (1.0 / x)) + 1):\n            dp[i ** x:n + 1] = [(dp[j] + dp[j - i ** x]) % MOD for j in range(i ** x, n + 1)]\n        return dp[n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2785", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = 'aeiouAEIOU'\n        s_list = list(s)\n        vowel_list = sorted([c for c in s if c in vowels])\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)\n```", "extracted_code": "\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = 'aeiouAEIOU'\n        s_list = list(s)\n        vowel_list = sorted([c for c in s if c in vowels])\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2784", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = max(nums)\n        return nums.count(n) == 2 and sorted(nums) == sorted(list(range(1, n)) + [n, n])\n```", "extracted_code": "\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = max(nums)\n        return nums.count(n) == 2 and sorted(nums) == sorted(list(range(1, n)) + [n, n])\n", "difficulty": 1.0}
{"task_id": "LeetCode/2781", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n        max_len = 0\n        for i in range(len(word)):\n            for j in range(i + 1, len(word) + 1):\n                if all(f not in word[i:j] for f in forbidden):\n                    max_len = max(max_len, j - i)\n        return max_len\n```", "extracted_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n        max_len = 0\n        for i in range(len(word)):\n            for j in range(i + 1, len(word) + 1):\n                if all(f not in word[i:j] for f in forbidden):\n                    max_len = max(max_len, j - i)\n        return max_len\n", "difficulty": 3.0}
{"task_id": "LeetCode/2772", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        diff = [0]*len(nums)\n        acc = 0\n        for i in range(len(nums)):\n            acc += diff[i]\n            d = (acc - nums[i]) % k\n            if d != 0:\n                d = k - d\n            acc -= d\n            if i+k < len(nums):\n                diff[i+k] = d\n        return acc == 0\n```", "extracted_code": "\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        diff = [0]*len(nums)\n        acc = 0\n        for i in range(len(nums)):\n            acc += diff[i]\n            d = (acc - nums[i]) % k\n            if d != 0:\n                d = k - d\n            acc -= d\n            if i+k < len(nums):\n                diff[i+k] = d\n        return acc == 0\n", "difficulty": 2.0}
{"task_id": "LeetCode/2771", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNonDecreasingLength(self, nums1, nums2):\n        n = len(nums1)\n        dp1, dp2 = [0]*n, [0]*n\n        dp1[0] = dp2[0] = 1\n        for i in range(1, n):\n            if nums1[i] >= nums1[i-1] and nums2[i] >= nums2[i-1]:\n                dp1[i] = dp1[i-1] + 1\n                dp2[i] = dp2[i-1] + 1\n            if nums1[i] >= nums2[i-1] and nums2[i] >= nums1[i-1]:\n                dp1[i] = max(dp1[i], dp2[i-1] + 1)\n                dp2[i] = max(dp2[i], dp1[i-1] + 1)\n            if nums1[i] >= nums1[i-1] and nums2[i] >= nums1[i-1]:\n                dp1[i] = max(dp1[i], dp1[i-1] + 1)\n            if nums1[i] >= nums2[i-1] and nums2[i] >= nums2[i-1]:\n                dp2[i] = max(dp2[i], dp2[i-1] + 1)\n        return max(dp1[-1], dp2[-1])\n```", "extracted_code": "\nclass Solution:\n    def maxNonDecreasingLength(self, nums1, nums2):\n        n = len(nums1)\n        dp1, dp2 = [0]*n, [0]*n\n        dp1[0] = dp2[0] = 1\n        for i in range(1, n):\n            if nums1[i] >= nums1[i-1] and nums2[i] >= nums2[i-1]:\n                dp1[i] = dp1[i-1] + 1\n                dp2[i] = dp2[i-1] + 1\n            if nums1[i] >= nums2[i-1] and nums2[i] >= nums1[i-1]:\n                dp1[i] = max(dp1[i], dp2[i-1] + 1)\n                dp2[i] = max(dp2[i], dp1[i-1] + 1)\n            if nums1[i] >= nums1[i-1] and nums2[i] >= nums1[i-1]:\n                dp1[i] = max(dp1[i], dp1[i-1] + 1)\n            if nums1[i] >= nums2[i-1] and nums2[i] >= nums2[i-1]:\n                dp2[i] = max(dp2[i], dp2[i-1] + 1)\n        return max(dp1[-1], dp2[-1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2770", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] + [-1] * (n - 1)\n        for i in range(n):\n            if dp[i] == -1:\n                continue\n            j = i + 1\n            while j < n and nums[j] - nums[i] <= target:\n                dp[j] = max(dp[j], dp[i] + 1)\n                j += 1\n        return dp[-1]\n```", "extracted_code": "\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] + [-1] * (n - 1)\n        for i in range(n):\n            if dp[i] == -1:\n                continue\n            j = i + 1\n            while j < n and nums[j] - nums[i] <= target:\n                dp[j] = max(dp[j], dp[i] + 1)\n                j += 1\n        return dp[-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2768", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        block_count = [0]*5\n        coord_map = {}\n        for x, y in coordinates:\n            for dx, dy in [[0, 0], [0, 1], [1, 0], [1, 1]]:\n                if 0 <= x+dx < m-1 and 0 <= y+dy < n-1:\n                    key = (x+dx, y+dy)\n                    coord_map[key] = coord_map.get(key, 0) + 1\n        for count in coord_map.values():\n            block_count[count] += 1\n            \n        total_blocks = (m-1) * (n-1)\n        block_count[0] = total_blocks - sum(block_count)\n        return block_count\n```", "extracted_code": "\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        block_count = [0]*5\n        coord_map = {}\n        for x, y in coordinates:\n            for dx, dy in [[0, 0], [0, 1], [1, 0], [1, 1]]:\n                if 0 <= x+dx < m-1 and 0 <= y+dy < n-1:\n                    key = (x+dx, y+dy)\n                    coord_map[key] = coord_map.get(key, 0) + 1\n        for count in coord_map.values():\n            block_count[count] += 1\n            \n        total_blocks = (m-1) * (n-1)\n        block_count[0] = total_blocks - sum(block_count)\n        return block_count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2766", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def relocateMarbles(self, nums, moveFrom, moveTo):\n        marble_dict = {}\n        for marble in nums:\n            if marble not in marble_dict:\n                marble_dict[marble] = 0\n            marble_dict[marble] += 1\n            \n        for i in range(len(moveFrom)):\n            marble_dict[moveTo[i]] = marble_dict.get(moveTo[i], 0) + marble_dict.pop(moveFrom[i])\n\n        return sorted(list(marble_dict.keys()))\n```", "extracted_code": "\nclass Solution:\n    def relocateMarbles(self, nums, moveFrom, moveTo):\n        marble_dict = {}\n        for marble in nums:\n            if marble not in marble_dict:\n                marble_dict[marble] = 0\n            marble_dict[marble] += 1\n            \n        for i in range(len(moveFrom)):\n            marble_dict[moveTo[i]] = marble_dict.get(moveTo[i], 0) + marble_dict.pop(moveFrom[i])\n\n        return sorted(list(marble_dict.keys()))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2763", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumImbalanceNumbers(self, nums):\n        total_imbalance = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)+1):\n                s = sorted(nums[i:j])\n                imbalance = sum(s[k+1] - s[k] > 1 for k in range(len(s) - 1))\n                total_imbalance += imbalance\n        return total_imbalance\n```", "extracted_code": "\nclass Solution:\n    def sumImbalanceNumbers(self, nums):\n        total_imbalance = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)+1):\n                s = sorted(nums[i:j])\n                imbalance = sum(s[k+1] - s[k] > 1 for k in range(len(s) - 1))\n                total_imbalance += imbalance\n        return total_imbalance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2762", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        left = 0\n        right = 0\n        max_val = min_val = nums[0]\n        total = 0\n        while right < len(nums):\n            max_val = max(max_val, nums[right])\n            min_val = min(min_val, nums[right])\n            if max_val - min_val > 2:\n                left += 1\n                max_val = min_val = nums[left]\n                right = left\n            else:\n                total += right - left + 1\n                right += 1\n        return total\n```\nIn this solution, we use a sliding window approach to find all the continuous subarrays. The variables left and right define the boundaries of the window. The variables max_val and min_val keep track of the maximum and minimum values within the window. If the difference between max_val and min_val is greater than 2, we move the left boundary forward. Otherwise, we move the right boundary forward. The total number of continuous subarrays is updated after each movement of the right boundary. The time complexity of this solution is O(n), where n is the length of nums. The space complexity is O(1), as we only use a constant amount of space.", "extracted_code": "\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        left = 0\n        right = 0\n        max_val = min_val = nums[0]\n        total = 0\n        while right < len(nums):\n            max_val = max(max_val, nums[right])\n            min_val = min(min_val, nums[right])\n            if max_val - min_val > 2:\n                left += 1\n                max_val = min_val = nums[left]\n                right = left\n            else:\n                total += right - left + 1\n                right += 1\n        return total\n", "difficulty": 2.0}
{"task_id": "LeetCode/2751", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def survivedRobotsHealths(self, positions, healths, directions):\n        robots = sorted(zip(positions, healths, directions))\n        left = [robot for robot in robots if robot[2] == 'L']\n        right = [robot for robot in robots if robot[2] == 'R']\n        survivors = []\n        \n        while left and right:\n            if left[-1][0] > right[0][0]:\n                survivors.append(left.pop())\n            elif left[-1][0] < right[0][0]:\n                survivors.append(right.pop(0))\n            else:\n                if left[-1][1] > right[0][1]:\n                    left[-1] = (left[-1][0], left[-1][1] - 1, left[-1][2])\n                    right.pop(0)\n                elif left[-1][1] < right[0][1]:\n                    right[0] = (right[0][0], right[0][1] - 1, right[0][2])\n                    left.pop()\n                else:\n                    left.pop()\n                    right.pop(0)\n                    \n        survivors += left[::-1] + right\n        survivors = sorted(survivors, key=lambda robot: positions.index(robot[0]))\n        return [robot[1] for robot in survivors]\n```", "extracted_code": "\nclass Solution:\n    def survivedRobotsHealths(self, positions, healths, directions):\n        robots = sorted(zip(positions, healths, directions))\n        left = [robot for robot in robots if robot[2] == 'L']\n        right = [robot for robot in robots if robot[2] == 'R']\n        survivors = []\n        \n        while left and right:\n            if left[-1][0] > right[0][0]:\n                survivors.append(left.pop())\n            elif left[-1][0] < right[0][0]:\n                survivors.append(right.pop(0))\n            else:\n                if left[-1][1] > right[0][1]:\n                    left[-1] = (left[-1][0], left[-1][1] - 1, left[-1][2])\n                    right.pop(0)\n                elif left[-1][1] < right[0][1]:\n                    right[0] = (right[0][0], right[0][1] - 1, right[0][2])\n                    left.pop()\n                else:\n                    left.pop()\n                    right.pop(0)\n                    \n        survivors += left[::-1] + right\n        survivors = sorted(survivors, key=lambda robot: positions.index(robot[0]))\n        return [robot[1] for robot in survivors]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2750", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        ones = [i for i, num in enumerate(nums) if num == 1]\n        ones = [-1] + ones + [len(nums)]\n        return sum((b - a) * (c - b) for a, b, c in zip(ones, ones[1:], ones[2:])) % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        ones = [i for i, num in enumerate(nums) if num == 1]\n        ones = [-1] + ones + [len(nums)]\n        return sum((b - a) * (c - b) for a, b, c in zip(ones, ones[1:], ones[2:])) % (10**9 + 7)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2749", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        operations = 0\n        for i in reversed(range(61)):\n            while num1 >= 2 ** i + num2:\n                num1 -= 2 ** i + num2\n                operations += 1\n        if num1 == 0:\n            return operations\n        else:\n            return -1\n```", "extracted_code": "\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        operations = 0\n        for i in reversed(range(61)):\n            while num1 >= 2 ** i + num2:\n                num1 -= 2 ** i + num2\n                operations += 1\n        if num1 == 0:\n            return operations\n        else:\n            return -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2747", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countServers(self, n: int, logs: list[list[int]], x: int, queries: list[int]) -> list[int]:\n        from collections import defaultdict\n        logs_dict = defaultdict(list)\n        for server_id, time in logs:\n            logs_dict[server_id].append(time)\n        result = []\n        for query in queries:\n            count = 0\n            for server_id in range(1, n+1):\n                if not logs_dict[server_id] or max(logs_dict[server_id]) < query - x + 1:\n                    count += 1\n            result.append(count)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def countServers(self, n: int, logs: list[list[int]], x: int, queries: list[int]) -> list[int]:\n        from collections import defaultdict\n        logs_dict = defaultdict(list)\n        for server_id, time in logs:\n            logs_dict[server_id].append(time)\n        result = []\n        for query in queries:\n            count = 0\n            for server_id in range(1, n+1):\n                if not logs_dict[server_id] or max(logs_dict[server_id]) < query - x + 1:\n                    count += 1\n            result.append(count)\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2744", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        lookup = set(words)\n        count = 0\n        for word in words:\n            if word[::-1] in lookup:\n                count += 1\n                lookup.remove(word)\n        return count // 2\n```", "extracted_code": "\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        lookup = set(words)\n        count = 0\n        for word in words:\n            if word[::-1] in lookup:\n                count += 1\n                lookup.remove(word)\n        return count // 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2742", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def paintWalls(self, cost, time):\n        total_time = sum(time)\n        cost_time = list(zip(cost, time))\n        cost_time.sort(key=lambda x: (-x[1], x[0]))\n        total_cost = 0\n        for c, t in cost_time:\n            if total_time <= t:\n                total_cost += c\n            total_time -= 1\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def paintWalls(self, cost, time):\n        total_time = sum(time)\n        cost_time = list(zip(cost, time))\n        cost_time.sort(key=lambda x: (-x[1], x[0]))\n        total_cost = 0\n        for c, t in cost_time:\n            if total_time <= t:\n                total_cost += c\n            total_time -= 1\n        return total_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2736", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSumQueries(self, nums1, nums2, queries):\n        answer = []\n        for query in queries:\n            max_val = -1\n            for j in range(len(nums1)):\n                if nums1[j] >= query[0] and nums2[j] >= query[1]:\n                    max_val = max(max_val, nums1[j] + nums2[j])\n            answer.append(max_val)\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def maximumSumQueries(self, nums1, nums2, queries):\n        answer = []\n        for query in queries:\n            max_val = -1\n            for j in range(len(nums1)):\n                if nums1[j] >= query[0] and nums2[j] >= query[1]:\n                    max_val = max(max_val, nums1[j] + nums2[j])\n            answer.append(max_val)\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2734", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        res = ['']*n\n        res[0] = 'a' if s[0] != 'a' else 'b'\n        \n        for i in range(1, n):\n            res[i] = chr((ord(s[i]) - 1 - 97) % 26 + 97) if s[i] > res[i-1] else s[i]\n        \n        return \"\".join(res)\n```", "extracted_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        res = ['']*n\n        res[0] = 'a' if s[0] != 'a' else 'b'\n        \n        for i in range(1, n):\n            res[i] = chr((ord(s[i]) - 1 - 97) % 26 + 97) if s[i] > res[i-1] else s[i]\n        \n        return \"\".join(res)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2732", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            subset_sum = [sum(grid[i][j] for i in range(i+1)) for j in range(n)]\n            if all(s <= (i+1)//2 for s in subset_sum):\n                return list(range(i+1))\n        return []\n```", "extracted_code": "\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            subset_sum = [sum(grid[i][j] for i in range(i+1)) for j in range(n)]\n            if all(s <= (i+1)//2 for s in subset_sum):\n                return list(range(i+1))\n        return []\n", "difficulty": 3.0}
{"task_id": "LeetCode/2730", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                j = i + length - 1\n                if length == 2:\n                    dp[i][j] = 2\n                elif s[j] == s[j-1] and s[j] != s[j-2]:\n                    dp[i][j] = dp[i][j-1] + 1\n                elif s[j] != s[j-1]:\n                    dp[i][j] = max(dp[i][j], dp[i][j-1], dp[i+1][j]) + 1\n                else:\n                    dp[i][j] = 2\n        return max(max(row) for row in dp)\n```", "extracted_code": "\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                j = i + length - 1\n                if length == 2:\n                    dp[i][j] = 2\n                elif s[j] == s[j-1] and s[j] != s[j-2]:\n                    dp[i][j] = dp[i][j-1] + 1\n                elif s[j] != s[j-1]:\n                    dp[i][j] = max(dp[i][j], dp[i][j-1], dp[i+1][j]) + 1\n                else:\n                    dp[i][j] = 2\n        return max(max(row) for row in dp)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2729", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated_num = str(n) + str(n * 2) + str(n * 3)\n        return sorted(concatenated_num) == ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n```", "extracted_code": "\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated_num = str(n) + str(n * 2) + str(n * 3)\n        return sorted(concatenated_num) == ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n", "difficulty": 1.0}
{"task_id": "LeetCode/2719", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n\n        def dfs(i, flag1, flag2, s):\n            if i == -1: return min_sum <= s <= max_sum\n            if not flag1 and not flag2 and dp[i][s] != -1: return dp[i][s]\n            res = 0\n            for k in range((0 if flag1 else int(num1[i])), (9 if flag2 else int(num2[i])) + 1):\n                if s + k > max_sum: break\n                res += dfs(i - 1, flag1 and k == int(num1[i]), flag2 and k == int(num2[i]), s + k)\n            if not flag1 and not flag2: dp[i][s] = res\n            return res\n\n        dp = [[-1] * 400 for _ in range(30)]\n        num1 = num1.zfill(30)[::-1]\n        num2 = num2.zfill(30)[::-1]\n        return (dfs(29, True, True, 0) - (0 if num1 == '0' else dfs(29, True, False, 0))) % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n\n        def dfs(i, flag1, flag2, s):\n            if i == -1: return min_sum <= s <= max_sum\n            if not flag1 and not flag2 and dp[i][s] != -1: return dp[i][s]\n            res = 0\n            for k in range((0 if flag1 else int(num1[i])), (9 if flag2 else int(num2[i])) + 1):\n                if s + k > max_sum: break\n                res += dfs(i - 1, flag1 and k == int(num1[i]), flag2 and k == int(num2[i]), s + k)\n            if not flag1 and not flag2: dp[i][s] = res\n            return res\n\n        dp = [[-1] * 400 for _ in range(30)]\n        num1 = num1.zfill(30)[::-1]\n        num2 = num2.zfill(30)[::-1]\n        return (dfs(29, True, True, 0) - (0 if num1 == '0' else dfs(29, True, False, 0))) % (10**9 + 7)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2716", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if stack and stack[-1] == c:\n                stack.pop()\n            else:\n                stack.append(c)\n        return len(stack)\n```", "extracted_code": "\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if stack and stack[-1] == c:\n                stack.pop()\n            else:\n                stack.append(c)\n        return len(stack)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2713", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0]*n for _ in range(m)]\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        cells = sorted((val, i, j) for i, row in enumerate(mat) for j, val in enumerate(row))\n        for val, x, y in cells:\n            dp[x][y] = max(dp[nx][ny] for nx, ny in (x+dx, y+dy) for dx, dy in direction if 0<=nx<m and 0<=ny<n and mat[nx][ny] < mat[x][y]) + 1\n        return max(map(max, dp))\n```", "extracted_code": "\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0]*n for _ in range(m)]\n        direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        cells = sorted((val, i, j) for i, row in enumerate(mat) for j, val in enumerate(row))\n        for val, x, y in cells:\n            dp[x][y] = max(dp[nx][ny] for nx, ny in (x+dx, y+dy) for dx, dy in direction if 0<=nx<m and 0<=ny<n and mat[nx][ny] < mat[x][y]) + 1\n        return max(map(max, dp))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2712", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        prefix_cost = [0] * (n + 1)\n        suffix_cost = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_cost[i] = prefix_cost[i - 1] + (s[i - 1] == '1')\n        for i in range(n - 1, -1, -1):\n            suffix_cost[i] = suffix_cost[i + 1] + (s[i] == '0')\n        return min(prefix_cost[i] + suffix_cost[i] for i in range(n + 1))\n```\nThis solution works by creating two lists, `prefix_cost` and `suffix_cost`, to store the cumulative cost of inverting all characters from `0` to `i` and from `i` to `n - 1` respectively. It then iterates over the string `s` to calculate the prefix and suffix costs. Finally, it finds and returns the minimum total cost by iterating over the range `n + 1` and adding the prefix and suffix costs at each index.", "extracted_code": "\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        prefix_cost = [0] * (n + 1)\n        suffix_cost = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_cost[i] = prefix_cost[i - 1] + (s[i - 1] == '1')\n        for i in range(n - 1, -1, -1):\n            suffix_cost[i] = suffix_cost[i + 1] + (s[i] == '0')\n        return min(prefix_cost[i] + suffix_cost[i] for i in range(n + 1))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2709", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canTraverseAllPairs(self, nums):\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        def dfs(node):\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n\n        graph = {i: [] for i in range(len(nums))}\n        nums = sorted([(num, i) for i, num in enumerate(nums)])\n        primes = {2: [i for i in range(len(nums)) if nums[i][0] % 2 == 0]}\n\n        for i in range(len(nums)):\n            j = 2\n            while j * j <= nums[i][0]:\n                if nums[i][0] % j == 0:\n                    while nums[i][0] % j == 0:\n                        nums[i][0] //= j\n                    if j in primes:\n                        for k in primes[j]:\n                            if k < i:\n                                graph[nums[k][1]].append(nums[i][1])\n                                graph[nums[i][1]].append(nums[k][1])\n                        primes[j].append(i)\n                    else:\n                        primes[j] = [i]\n                j += 1\n            if nums[i][0] > 1:\n                if nums[i][0] in primes:\n                    for k in primes[nums[i][0]]:\n                        graph[nums[k][1]].append(nums[i][1])\n                        graph[nums[i][1]].append(nums[k][1])\n                    primes[nums[i][0]].append(i)\n                else:\n                    primes[nums[i][0]] = [i]\n\n        visited = [False] * len(nums)\n        dfs(nums[0][1])\n        return all(visited)\n```", "extracted_code": "\nclass Solution:\n    def canTraverseAllPairs(self, nums):\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        def dfs(node):\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n\n        graph = {i: [] for i in range(len(nums))}\n        nums = sorted([(num, i) for i, num in enumerate(nums)])\n        primes = {2: [i for i in range(len(nums)) if nums[i][0] % 2 == 0]}\n\n        for i in range(len(nums)):\n            j = 2\n            while j * j <= nums[i][0]:\n                if nums[i][0] % j == 0:\n                    while nums[i][0] % j == 0:\n                        nums[i][0] //= j\n                    if j in primes:\n                        for k in primes[j]:\n                            if k < i:\n                                graph[nums[k][1]].append(nums[i][1])\n                                graph[nums[i][1]].append(nums[k][1])\n                        primes[j].append(i)\n                    else:\n                        primes[j] = [i]\n                j += 1\n            if nums[i][0] > 1:\n                if nums[i][0] in primes:\n                    for k in primes[nums[i][0]]:\n                        graph[nums[k][1]].append(nums[i][1])\n                        graph[nums[i][1]].append(nums[k][1])\n                    primes[nums[i][0]].append(i)\n                else:\n                    primes[nums[i][0]] = [i]\n\n        visited = [False] * len(nums)\n        dfs(nums[0][1])\n        return all(visited)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2708", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "Here is the Python code that solves the problem:\n\n```python\nimport numpy as np\n\nclass Solution:\n    def maxStrength(self, nums):\n        nums.sort()\n        maxStrength = np.prod(nums)\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                maxStrength = max(maxStrength, np.prod(nums[i+1:]))\n            else:\n                break\n        return maxStrength\n```\n\nThe function sorts the list of scores in ascending order and calculates the product of all scores as the initial maximum strength. Then it iterates over the sorted list and checks if the current score is negative. If it is, it calculates the product of the scores from the current score's position + 1 to the end of the list, and compares this product with the current maximum strength. If the new product is greater, it updates the maximum strength. The function breaks the loop as soon as it encounters a non-negative score, because further calculations would only decrease the product. The function then returns the maximum strength.", "extracted_code": "\nimport numpy as np\n\nclass Solution:\n    def maxStrength(self, nums):\n        nums.sort()\n        maxStrength = np.prod(nums)\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                maxStrength = max(maxStrength, np.prod(nums[i+1:]))\n            else:\n                break\n        return maxStrength\n", "difficulty": 2.0}
{"task_id": "LeetCode/2707", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        n = len(s)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            for word in dictionary:\n                if s[i-len(word)+1:i+1] == word:\n                    dp[i+1] = min(dp[i+1], dp[i-len(word)+1] + len(word))\n            dp[i+1] = min(dp[i+1], dp[i] + 1)\n        return dp[-1] - len(s)\n```", "extracted_code": "\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        n = len(s)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            for word in dictionary:\n                if s[i-len(word)+1:i+1] == word:\n                    dp[i+1] = min(dp[i+1], dp[i-len(word)+1] + len(word))\n            dp[i+1] = min(dp[i+1], dp[i] + 1)\n        return dp[-1] - len(s)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2699", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        from collections import defaultdict\n        from heapq import heappop, heappush\n\n        graph = defaultdict(list)\n        edge_map = defaultdict(list)\n        for a, b, w in edges:\n            if w == -1:\n                w = 2 * 10**9\n                edge_map[(a, b)] = [a, b, w]\n                edge_map[(b, a)] = [a, b, w]\n            graph[a].append((b, w))\n            graph[b].append((a, w))\n\n        dist = [float('inf')] * n\n        dist[source] = 0\n        heap = [(0, source)]\n        parent = [0] * n\n        while heap:\n            d, node = heappop(heap)\n            if d != dist[node]:\n                continue\n            for neigh, w in graph[node]:\n                if dist[node] + w < dist[neigh]:\n                    dist[neigh] = dist[node] + w\n                    parent[neigh] = node\n                    heappush(heap, (dist[neigh], neigh))\n\n        if dist[destination] < target:\n            return []\n\n        node = destination\n        while dist[destination] > target:\n            if parent[node] == source and edge_map[(source, node)][2] > 1:\n                edge_map[(source, node)][2] -= dist[destination] - target\n                edge_map[(node, source)][2] -= dist[destination] - target\n            node = parent[node]\n\n        return [edge for edge in edge_map.values()]\n```", "extracted_code": "\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        from collections import defaultdict\n        from heapq import heappop, heappush\n\n        graph = defaultdict(list)\n        edge_map = defaultdict(list)\n        for a, b, w in edges:\n            if w == -1:\n                w = 2 * 10**9\n                edge_map[(a, b)] = [a, b, w]\n                edge_map[(b, a)] = [a, b, w]\n            graph[a].append((b, w))\n            graph[b].append((a, w))\n\n        dist = [float('inf')] * n\n        dist[source] = 0\n        heap = [(0, source)]\n        parent = [0] * n\n        while heap:\n            d, node = heappop(heap)\n            if d != dist[node]:\n                continue\n            for neigh, w in graph[node]:\n                if dist[node] + w < dist[neigh]:\n                    dist[neigh] = dist[node] + w\n                    parent[neigh] = node\n                    heappush(heap, (dist[neigh], neigh))\n\n        if dist[destination] < target:\n            return []\n\n        node = destination\n        while dist[destination] > target:\n            if parent[node] == source and edge_map[(source, node)][2] > 1:\n                edge_map[(source, node)][2] -= dist[destination] - target\n                edge_map[(node, source)][2] -= dist[destination] - target\n            node = parent[node]\n\n        return [edge for edge in edge_map.values()]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2698", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def can_partition(i, sq):\n            if i == 0 and sq == 0:\n                return True\n            if sq == 0 or i == 0:\n                return False\n            return can_partition(i//10, sq-int(str(i)[-1])) or can_partition(i//10, sq)\n        \n        return sum(i*i for i in range(1, n+1) if can_partition(i, i*i))\n```", "extracted_code": "\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def can_partition(i, sq):\n            if i == 0 and sq == 0:\n                return True\n            if sq == 0 or i == 0:\n                return False\n            return can_partition(i//10, sq-int(str(i)[-1])) or can_partition(i//10, sq)\n        \n        return sum(i*i for i in range(1, n+1) if can_partition(i, i*i))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2697", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "Here is the Python function that satisfies the given requirements:\n\n```python\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        s = list(s)\n        l = 0\n        r = len(s) - 1\n        while l < r:\n            if s[l] > s[r]:\n                s[l] = s[r]\n            elif s[l] < s[r]:\n                s[r] = s[l]\n            l += 1\n            r -= 1\n        return ''.join(s)\n```\n\nIn this function, we first convert the string into a list to allow element-wise replacement. We then initialize two pointers `l` and `r` at the start and end of the string, respectively. As long as `l` is less than `r`, we compare the characters at the `l` and `r` positions. If the character at position `l` is lexicographically larger than the character at `r`, we replace the character at `l` with the one at `r`. If the character at `l` is smaller, we replace the character at `r` with the one at `l`. Once we've processed all pairs of characters, we join the list back into a string and return it. This ensures that we make the minimum number of changes necessary to transform the string into a palindrome and that the resulting palindrome is lexicographically the smallest possible.", "extracted_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        s = list(s)\n        l = 0\n        r = len(s) - 1\n        while l < r:\n            if s[l] > s[r]:\n                s[l] = s[r]\n            elif s[l] < s[r]:\n                s[r] = s[l]\n            l += 1\n            r -= 1\n        return ''.join(s)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2681", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        power_all, power, right_min = [0]*n, [0]*n, [0]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] < nums[i]:\n                right_min[stack.pop()] = i\n            stack.append(i)\n        while stack:\n            right_min[stack.pop()] = n\n        stack = []\n        for i in range(n-1, -1, -1):\n            while stack and nums[stack[-1]] < nums[i]:\n                idx = stack.pop()\n                power_all[idx] = (power_all[idx] + power[idx] * (right_min[idx] - i)) % mod\n                power_all[i] = (power_all[i] + power[idx]) % mod\n                power[i] = (power[i] + power[idx]) % mod\n            power[i] = (power[i] + nums[i]) % mod\n            stack.append(i)\n        while stack:\n            idx = stack.pop()\n            power_all[idx] = (power_all[idx] + power[idx] * (right_min[idx] + 1)) % mod\n        return sum(power_all) % mod\n```", "extracted_code": "\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        power_all, power, right_min = [0]*n, [0]*n, [0]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] < nums[i]:\n                right_min[stack.pop()] = i\n            stack.append(i)\n        while stack:\n            right_min[stack.pop()] = n\n        stack = []\n        for i in range(n-1, -1, -1):\n            while stack and nums[stack[-1]] < nums[i]:\n                idx = stack.pop()\n                power_all[idx] = (power_all[idx] + power[idx] * (right_min[idx] - i)) % mod\n                power_all[i] = (power_all[i] + power[idx]) % mod\n                power[i] = (power[i] + power[idx]) % mod\n            power[i] = (power[i] + nums[i]) % mod\n            stack.append(i)\n        while stack:\n            idx = stack.pop()\n            power_all[idx] = (power_all[idx] + power[idx] * (right_min[idx] + 1)) % mod\n        return sum(power_all) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2680", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        heap = [-num for num in nums]\n        heapq.heapify(heap)\n        while k > 0 and heap[0] < -1:\n            min_num = -heapq.heappop(heap)\n            heapq.heappush(heap, -min_num * 2)\n            k -= 1\n        return sum(-num for num in heap)\n```", "extracted_code": "\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        heap = [-num for num in nums]\n        heapq.heapify(heap)\n        while k > 0 and heap[0] < -1:\n            min_num = -heapq.heappop(heap)\n            heapq.heappush(heap, -min_num * 2)\n            k -= 1\n        return sum(-num for num in heap)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2670", "status": "ERROR", "reward": 0, "done": "Complete.", "raw_completion": "```python\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix = set()\n        suffix = set(nums)\n        res = []\n        for i in range(n):\n            prefix.add(nums[i])\n            suffix.remove(nums[i])\n            res.append(len(prefix) - len(suffix))\n        return res\n```", "extracted_code": "\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix = set()\n        suffix = set(nums)\n        res = []\n        for i in range(n):\n            prefix.add(nums[i])\n            suffix.remove(nums[i])\n            res.append(len(prefix) - len(suffix))\n        return res\n", "difficulty": 1.0}
{"task_id": "LeetCode/2663", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        s = list(s)\n        n = len(s)\n        for i in range(n - 1, -1, -1):\n            for j in range(ord(s[i]) - ord('a') + 1, k):\n                if (i > 0 and s[i - 1] == alphabet[j]) or (i > 1 and s[i - 2] == alphabet[j]):\n                    continue\n                s[i] = alphabet[j]\n                for l in range(i + 1, n):\n                    for m in range(k):\n                        if (l > 0 and s[l - 1] == alphabet[m]) or (l > 1 and s[l - 2] == alphabet[m]):\n                            continue\n                        s[l] = alphabet[m]\n                        break\n                return ''.join(s)\n        return ''\n```", "extracted_code": "\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        s = list(s)\n        n = len(s)\n        for i in range(n - 1, -1, -1):\n            for j in range(ord(s[i]) - ord('a') + 1, k):\n                if (i > 0 and s[i - 1] == alphabet[j]) or (i > 1 and s[i - 2] == alphabet[j]):\n                    continue\n                s[i] = alphabet[j]\n                for l in range(i + 1, n):\n                    for m in range(k):\n                        if (l > 0 and s[l - 1] == alphabet[m]) or (l > 1 and s[l - 2] == alphabet[m]):\n                            continue\n                        s[l] = alphabet[m]\n                        break\n                return ''.join(s)\n        return ''\n", "difficulty": 3.0}
{"task_id": "LeetCode/2659", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: list[int]) -> int:\n        size = len(nums)\n        sorted_nums = sorted([(num, i) for i, num in enumerate(nums)])\n        position = [0] * size\n        for i in range(size):\n            position[sorted_nums[i][1]] = i\n\n        tree = [0] * (size + 1)\n        def update(i, delta):\n            i += 1\n            while i <= size:\n                tree[i] += delta\n                i += i & -i\n\n        def query(i):\n            i += 1\n            result = 0\n            while i > 0:\n                result += tree[i]\n                i -= i & -i\n            return result\n\n        operations = 0\n        for num, i in sorted_nums:\n            left = query(i)\n            right = i - left\n            operations += min(left, right) + 1\n            update(i, 1)\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: list[int]) -> int:\n        size = len(nums)\n        sorted_nums = sorted([(num, i) for i, num in enumerate(nums)])\n        position = [0] * size\n        for i in range(size):\n            position[sorted_nums[i][1]] = i\n\n        tree = [0] * (size + 1)\n        def update(i, delta):\n            i += 1\n            while i <= size:\n                tree[i] += delta\n                i += i & -i\n\n        def query(i):\n            i += 1\n            result = 0\n            while i > 0:\n                result += tree[i]\n                i -= i & -i\n            return result\n\n        operations = 0\n        for num, i in sorted_nums:\n            left = query(i)\n            right = i - left\n            operations += min(left, right) + 1\n            update(i, 1)\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2658", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMaxFish(self, grid):\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dp = [[-1 for _ in range(n)] for _ in range(m)]\n        \n        def dfs(r, c):\n            if dp[r][c] != -1:\n                return dp[r][c]\n            dp[r][c] = grid[r][c]\n            for dx, dy in directions:\n                nx, ny = r + dx, c + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 0:\n                    dp[r][c] = max(dp[r][c], dfs(nx, ny) + grid[r][c])\n            return dp[r][c]\n        \n        maxFish = 0\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] != 0:\n                    maxFish = max(maxFish, dfs(r, c))\n        return maxFish\n```", "extracted_code": "\nclass Solution:\n    def findMaxFish(self, grid):\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dp = [[-1 for _ in range(n)] for _ in range(m)]\n        \n        def dfs(r, c):\n            if dp[r][c] != -1:\n                return dp[r][c]\n            dp[r][c] = grid[r][c]\n            for dx, dy in directions:\n                nx, ny = r + dx, c + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 0:\n                    dp[r][c] = max(dp[r][c], dfs(nx, ny) + grid[r][c])\n            return dp[r][c]\n        \n        maxFish = 0\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] != 0:\n                    maxFish = max(maxFish, dfs(r, c))\n        return maxFish\n", "difficulty": 2.0}
{"task_id": "LeetCode/2657", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:\n        prefix_common_array = []\n        for i in range(len(A)):\n            prefix_common_array.append(len(set(A[:i+1]) & set(B[:i+1])))\n        return prefix_common_array\n```", "extracted_code": "\nclass Solution:\n    def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:\n        prefix_common_array = []\n        for i in range(len(A)):\n            prefix_common_array.append(len(set(A[:i+1]) & set(B[:i+1])))\n        return prefix_common_array\n", "difficulty": 2.0}
{"task_id": "LeetCode/2653", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        from heapq import nlargest\n        from collections import deque\n        n = len(nums)\n        beauty = [0] * (n - k + 1)\n        negatives = deque()\n        for i, num in enumerate(nums):\n            if num < 0:\n                negatives.append((num, i))\n            while negatives and negatives[0][1] <= i - k:\n                negatives.popleft()\n            if i >= k - 1:\n                if len(negatives) >= x:\n                    beauty[i - k + 1] = -nlargest(x, (num for num, _ in negatives))[x - 1]\n        return beauty\n```\nIn this solution, the deque `negatives` is used to store the negative numbers in the current subarray (along with their indices). For each number `num` in `nums`, if `num` is negative, it's appended to `negatives`. Then, any numbers that are no longer in the current subarray (i.e., their indices are less than `i - k`) are removed from the front of `negatives`. If the current index `i` is at least `k - 1` (meaning a full subarray's worth of numbers have been processed), the `x`th smallest negative number in the current subarray is computed and stored in `beauty`. If there are fewer than `x` negative numbers in `negatives`, the `x`th smallest negative number is 0 by definition. The `x`th smallest negative number is computed by taking the `x`th largest number from the negatives of the numbers in `negatives`, and then negating the result. This is because the negatives of a set of numbers have the same order but reversed, so the `x`th smallest negative number is the negative of the `x`th largest number. Finally, `beauty` is returned.", "extracted_code": "\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        from heapq import nlargest\n        from collections import deque\n        n = len(nums)\n        beauty = [0] * (n - k + 1)\n        negatives = deque()\n        for i, num in enumerate(nums):\n            if num < 0:\n                negatives.append((num, i))\n            while negatives and negatives[0][1] <= i - k:\n                negatives.popleft()\n            if i >= k - 1:\n                if len(negatives) >= x:\n                    beauty[i - k + 1] = -nlargest(x, (num for num, _ in negatives))[x - 1]\n        return beauty\n", "difficulty": 2.0}
{"task_id": "LeetCode/2652", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n```", "extracted_code": "\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2651", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24\n```", "extracted_code": "\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24\n", "difficulty": 1.0}
{"task_id": "LeetCode/2646", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        \n        G = [[] for _ in range(n)]\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n\n        dp = np.full((n, 2, 51), float('inf'))\n        dp[0][0][0] = 0\n        dp[0][1][1] = price[0] // 2\n\n        def dfs(v, p):\n            for u in G[v]:\n                if u == p: continue\n                dfs(u, v)\n                dp[v][0, :] = np.minimum(dp[v][0, :len(dp[u][0]) + 1] + dp[u][0, :], \n                                         dp[v][0, :len(dp[u][1]) + 1] + dp[u][1, :])\n                dp[v][1, :] = np.minimum(dp[v][1, :len(dp[u][0]) + 1] + dp[u][0, :], \n                                         dp[v][1, :len(dp[u][1]) + 1] + dp[u][1, :])\n\n        dfs(0, -1)\n\n        trips_cnt = [0] * n\n        for s, t in trips:\n            trips_cnt[s] += 1\n            trips_cnt[t] += 1\n\n        res = float('inf')\n        for x in range(n + 1):\n            if trips_cnt.count(x) >= n - x:\n                res = min(res, dp[0][0][x], dp[0][1][x])\n\n        return int(res)\n```", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        \n        G = [[] for _ in range(n)]\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n\n        dp = np.full((n, 2, 51), float('inf'))\n        dp[0][0][0] = 0\n        dp[0][1][1] = price[0] // 2\n\n        def dfs(v, p):\n            for u in G[v]:\n                if u == p: continue\n                dfs(u, v)\n                dp[v][0, :] = np.minimum(dp[v][0, :len(dp[u][0]) + 1] + dp[u][0, :], \n                                         dp[v][0, :len(dp[u][1]) + 1] + dp[u][1, :])\n                dp[v][1, :] = np.minimum(dp[v][1, :len(dp[u][0]) + 1] + dp[u][0, :], \n                                         dp[v][1, :len(dp[u][1]) + 1] + dp[u][1, :])\n\n        dfs(0, -1)\n\n        trips_cnt = [0] * n\n        for s, t in trips:\n            trips_cnt[s] += 1\n            trips_cnt[t] += 1\n\n        res = float('inf')\n        for x in range(n + 1):\n            if trips_cnt.count(x) >= n - x:\n                res = min(res, dp[0][0][x], dp[0][1][x])\n\n        return int(res)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2645", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        a, b, c = 0, 0, 0\n        for char in word:\n            if char == 'a':\n                a += 1\n            elif char == 'b':\n                b = min(a, b+1)\n            elif char == 'c':\n                c = min(b, c+1)\n        return len(word) + 2*c - 3*a\n```", "extracted_code": "\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        a, b, c = 0, 0, 0\n        for char in word:\n            if char == 'a':\n                a += 1\n            elif char == 'b':\n                b = min(a, b+1)\n            elif char == 'c':\n                c = min(b, c+1)\n        return len(word) + 2*c - 3*a\n", "difficulty": 2.0}
{"task_id": "LeetCode/2642", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nimport heapq\n\nclass Graph:\n    def __init__(self, n: int, edges: [[int]]):\n        self.n = n\n        self.graph = {i: {} for i in range(n)}\n        for from_i, to_i, cost in edges:\n            self.addEdge([from_i, to_i, cost])\n\n    def addEdge(self, edge: [int]) -> None:\n        from_i, to_i, cost = edge\n        self.graph[from_i][to_i] = cost\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        heap = [(0, node1)]\n        dist = {i: float('inf') for i in range(self.n)}\n        dist[node1] = 0\n        while heap:\n            curr_dist, curr_node = heapq.heappop(heap)\n            if curr_dist != dist[curr_node]:\n                continue\n            for neighbour, neighbour_dist in self.graph[curr_node].items():\n                if curr_dist + neighbour_dist < dist[neighbour]:\n                    dist[neighbour] = curr_dist + neighbour_dist\n                    heapq.heappush(heap, (dist[neighbour], neighbour))\n        return dist[node2] if dist[node2] != float('inf') else -1\n```", "extracted_code": "\nimport heapq\n\nclass Graph:\n    def __init__(self, n: int, edges: [[int]]):\n        self.n = n\n        self.graph = {i: {} for i in range(n)}\n        for from_i, to_i, cost in edges:\n            self.addEdge([from_i, to_i, cost])\n\n    def addEdge(self, edge: [int]) -> None:\n        from_i, to_i, cost = edge\n        self.graph[from_i][to_i] = cost\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        heap = [(0, node1)]\n        dist = {i: float('inf') for i in range(self.n)}\n        dist[node1] = 0\n        while heap:\n            curr_dist, curr_node = heapq.heappop(heap)\n            if curr_dist != dist[curr_node]:\n                continue\n            for neighbour, neighbour_dist in self.graph[curr_node].items():\n                if curr_dist + neighbour_dist < dist[neighbour]:\n                    dist[neighbour] = curr_dist + neighbour_dist\n                    heapq.heappush(heap, (dist[neighbour], neighbour))\n        return dist[node2] if dist[node2] != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2640", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findPrefixScore(self, nums):\n        prefix_max = 0\n        prefix_sum = 0\n        result = []\n\n        for num in nums:\n            prefix_max = max(prefix_max, num)\n            prefix_sum += (num + prefix_max)\n            result.append(prefix_sum)\n\n        return result\n```", "extracted_code": "\nclass Solution:\n    def findPrefixScore(self, nums):\n        prefix_max = 0\n        prefix_sum = 0\n        result = []\n\n        for num in nums:\n            prefix_max = max(prefix_max, num)\n            prefix_sum += (num + prefix_max)\n            result.append(prefix_sum)\n\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2617", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                for k in range(1, grid[i][j] + 1):\n                    if i + k < m:\n                        dp[i + k][j] = min(dp[i + k][j], dp[i][j] + 1)\n                    if j + k < n:\n                        dp[i][j + k] = min(dp[i][j + k], dp[i][j] + 1)\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                for k in range(1, grid[i][j] + 1):\n                    if i + k < m:\n                        dp[i + k][j] = min(dp[i + k][j], dp[i][j] + 1)\n                    if j + k < n:\n                        dp[i][j + k] = min(dp[i][j + k], dp[i][j] + 1)\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2616", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        arr = [(val, idx) for idx, val in enumerate(nums)]\n        arr.sort()\n        results = [float('inf')] * len(nums)\n        pairs = []\n        for i in range(len(nums)):\n            while pairs and arr[i][0] - arr[pairs[0]][0] >= results[i - 1]:\n                _, idx = pairs.pop(0)\n                if i - idx > 1:\n                    results[i] = min(results[i], max(results[idx], arr[i][0] - arr[idx + 1][0]))\n            pairs.append(i)\n            if i >= p:\n                results[i] = min(results[i], max(results[i - p], arr[i][0] - arr[i - p + 1][0]))\n        return results[-1]\n```", "extracted_code": "\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        arr = [(val, idx) for idx, val in enumerate(nums)]\n        arr.sort()\n        results = [float('inf')] * len(nums)\n        pairs = []\n        for i in range(len(nums)):\n            while pairs and arr[i][0] - arr[pairs[0]][0] >= results[i - 1]:\n                _, idx = pairs.pop(0)\n                if i - idx > 1:\n                    results[i] = min(results[i], max(results[idx], arr[i][0] - arr[idx + 1][0]))\n            pairs.append(i)\n            if i >= p:\n                results[i] = min(results[i], max(results[i - p], arr[i][0] - arr[i - p + 1][0]))\n        return results[-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2615", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        from collections import defaultdict\n        indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            indices[num].append(i)\n        arr = [0] * len(nums)\n        for i, num in enumerate(nums):\n            for j in indices[num]:\n                if i != j:\n                    arr[i] += abs(i - j)\n        return arr\n```", "extracted_code": "\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        from collections import defaultdict\n        indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            indices[num].append(i)\n        arr = [0] * len(nums)\n        for i, num in enumerate(nums):\n            for j in indices[num]:\n                if i != j:\n                    arr[i] += abs(i - j)\n        return arr\n", "difficulty": 2.0}
{"task_id": "LeetCode/2612", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        ops = [0]*n\n        blocked = [0]*n\n        for ban in banned:\n            blocked[ban] = 1\n        ops[p] = 0\n        for i in range(p-1,-1,-1):\n            if not blocked[i+1]:\n                ops[i] = ops[i+k] + 1 if i + k < n else -1\n            else:\n                ops[i] = -1\n        for i in range(p+1,n):\n            if not blocked[i-1]:\n                ops[i] = ops[i-k] + 1 if i - k >= 0 else -1\n            else:\n                ops[i] = -1\n        return ops\n```", "extracted_code": "\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        ops = [0]*n\n        blocked = [0]*n\n        for ban in banned:\n            blocked[ban] = 1\n        ops[p] = 0\n        for i in range(p-1,-1,-1):\n            if not blocked[i+1]:\n                ops[i] = ops[i+k] + 1 if i + k < n else -1\n            else:\n                ops[i] = -1\n        for i in range(p+1,n):\n            if not blocked[i-1]:\n                ops[i] = ops[i-k] + 1 if i - k >= 0 else -1\n            else:\n                ops[i] = -1\n        return ops\n", "difficulty": 3.0}
{"task_id": "LeetCode/2608", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nfrom collections import defaultdict\nimport numpy as np\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        shortest_cycle = n + 1\n        for node in graph:\n            stack = [(node, 0, [node])]\n            visited = set()\n\n            while stack:\n                curr, depth, path = stack.pop()\n                if curr not in visited:\n                    visited.add(curr)\n                    if depth > 1 and curr == node:\n                        shortest_cycle = min(shortest_cycle, len(path))\n                        continue\n\n                    for neighbor in graph[curr]:\n                        if neighbor not in path or neighbor == node:\n                            stack.append((neighbor, depth + 1, path + [neighbor]))\n\n        if shortest_cycle == n + 1:\n            return -1\n        else:\n            return shortest_cycle\n```", "extracted_code": "\nfrom typing import List\nfrom collections import defaultdict\nimport numpy as np\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        shortest_cycle = n + 1\n        for node in graph:\n            stack = [(node, 0, [node])]\n            visited = set()\n\n            while stack:\n                curr, depth, path = stack.pop()\n                if curr not in visited:\n                    visited.add(curr)\n                    if depth > 1 and curr == node:\n                        shortest_cycle = min(shortest_cycle, len(path))\n                        continue\n\n                    for neighbor in graph[curr]:\n                        if neighbor not in path or neighbor == node:\n                            stack.append((neighbor, depth + 1, path + [neighbor]))\n\n        if shortest_cycle == n + 1:\n            return -1\n        else:\n            return shortest_cycle\n", "difficulty": 3.0}
{"task_id": "LeetCode/2603", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def collectTheCoins(self, coins, edges):\n        tree = [[] for _ in range(len(coins))]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n            \n        def dfs(node, parent):\n            total, dist = 0, 0\n            for child in tree[node]:\n                if child == parent:\n                    continue\n                sub_total, sub_dist = dfs(child, node)\n                total += sub_total\n                dist += sub_dist\n            if coins[node] or total > 0:\n                total += 1\n                dist += 2\n            return total, max(dist - 2, 0)\n        \n        total, dist = dfs(0, -1)\n        return total + dist\n```", "extracted_code": "\nclass Solution:\n    def collectTheCoins(self, coins, edges):\n        tree = [[] for _ in range(len(coins))]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n            \n        def dfs(node, parent):\n            total, dist = 0, 0\n            for child in tree[node]:\n                if child == parent:\n                    continue\n                sub_total, sub_dist = dfs(child, node)\n                total += sub_total\n                dist += sub_dist\n            if coins[node] or total > 0:\n                total += 1\n                dist += 2\n            return total, max(dist - 2, 0)\n        \n        total, dist = dfs(0, -1)\n        return total + dist\n", "difficulty": 3.0}
{"task_id": "LeetCode/2601", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def primeSubOperation(self, nums):\n        def prime(n):\n            if n == 1:\n                return 2\n            i = n - 1\n            while i > 1:\n                if n % i == 0:\n                    n -= 1\n                    i = n - 1\n                else:\n                    i -= 1\n            return n\n\n        for i in range(len(nums) - 1):\n            if nums[i] >= nums[i + 1]:\n                p = prime(nums[i + 1] - 1)\n                if p >= nums[i + 1]:\n                    return False\n                nums[i] -= p\n        return True\n```", "extracted_code": "\nclass Solution:\n    def primeSubOperation(self, nums):\n        def prime(n):\n            if n == 1:\n                return 2\n            i = n - 1\n            while i > 1:\n                if n % i == 0:\n                    n -= 1\n                    i = n - 1\n                else:\n                    i -= 1\n            return n\n\n        for i in range(len(nums) - 1):\n            if nums[i] >= nums[i + 1]:\n                p = prime(nums[i + 1] - 1)\n                if p >= nums[i + 1]:\n                    return False\n                nums[i] -= p\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2592", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort()\n        l = len(nums)\n        mid = l // 2\n        res = 0\n        for i in range(mid): \n            if nums[i] < nums[i + mid]:\n                res += 1\n            elif i < mid - 1 and nums[i] < nums[i + mid + 1]:\n                res += 1\n        return res\n```", "extracted_code": "\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort()\n        l = len(nums)\n        mid = l // 2\n        res = 0\n        for i in range(mid): \n            if nums[i] < nums[i + mid]:\n                res += 1\n            elif i < mid - 1 and nums[i] < nums[i + mid + 1]:\n                res += 1\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2591", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children or money == 4 * children:\n            return -1\n        else:\n            max_eight = min(money // 8, children)\n            remaining_money = money - max_eight * 8\n            if remaining_money >= children - max_eight and remaining_money != 4 * (children - max_eight):\n                return max_eight\n            else:\n                return max_eight - 1\n```", "extracted_code": "\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children or money == 4 * children:\n            return -1\n        else:\n            max_eight = min(money // 8, children)\n            remaining_money = money - max_eight * 8\n            if remaining_money >= children - max_eight and remaining_money != 4 * (children - max_eight):\n                return max_eight\n            else:\n                return max_eight - 1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2589", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMinimumTime(self, tasks):\n        tasks.sort(key=lambda x: (x[1], -x[2]))\n        heap = []\n        for s, e, d in tasks:\n            if heap and heap[0] <= s:\n                d -= min(d, s - heap[0])\n                if heap and heap[0] < s:\n                    heap.pop(0)\n            while d > 0:\n                if heap and heap[0] <= e - d:\n                    d -= min(d, e - heap[0])\n                    if heap and heap[0] < e - d:\n                        heap.pop(0)\n                else:\n                    heap.append(e - d + 1)\n                    d = 0\n        return sum(heap)\n```", "extracted_code": "\nclass Solution:\n    def findMinimumTime(self, tasks):\n        tasks.sort(key=lambda x: (x[1], -x[2]))\n        heap = []\n        for s, e, d in tasks:\n            if heap and heap[0] <= s:\n                d -= min(d, s - heap[0])\n                if heap and heap[0] < s:\n                    heap.pop(0)\n            while d > 0:\n                if heap and heap[0] <= e - d:\n                    d -= min(d, e - heap[0])\n                    if heap and heap[0] < e - d:\n                        heap.pop(0)\n                else:\n                    heap.append(e - d + 1)\n                    d = 0\n        return sum(heap)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2587", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort()\n        prefix_sum = 0\n        score = 0\n        for num in nums:\n            if prefix_sum + num < 0:\n                break\n            prefix_sum += num\n            if prefix_sum > 0:\n                score += 1\n        return score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort()\n        prefix_sum = 0\n        score = 0\n        for num in nums:\n            if prefix_sum + num < 0:\n                break\n            prefix_sum += num\n            if prefix_sum > 0:\n                score += 1\n        return score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2585", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToReachTarget(self, target: int, types: [[int]]) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for counts, marks in types:\n            for i in range(marks, target + 1):\n                for j in range(1, min(i//marks, counts) + 1):\n                    dp[i] = (dp[i] + dp[i - j * marks]) % mod\n        return dp[target]\n```", "extracted_code": "\nclass Solution:\n    def waysToReachTarget(self, target: int, types: [[int]]) -> int:\n        mod = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for counts, marks in types:\n            for i in range(marks, target + 1):\n                for j in range(1, min(i//marks, counts) + 1):\n                    dp[i] = (dp[i] + dp[i - j * marks]) % mod\n        return dp[target]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2584", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\nimport math\n\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        prefix = np.cumprod(nums)\n        suffix = np.cumprod(nums[::-1])[::-1]\n        for i in range(len(nums)-1):\n            if math.gcd(prefix[i], suffix[i+1]) == 1:\n                return i\n        return -1\n```", "extracted_code": "\nfrom typing import List\nimport numpy as np\nimport math\n\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        prefix = np.cumprod(nums)\n        suffix = np.cumprod(nums[::-1])[::-1]\n        for i in range(len(nums)-1):\n            if math.gcd(prefix[i], suffix[i+1]) == 1:\n                return i\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2581", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def rootCount(self, edges, guesses, k):\n        n = len(edges) + 1\n        count = [0] * n\n        guess_set = set(tuple(x) for x in guesses)\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n            if (u, v) in guess_set or (v, u) in guess_set:\n                count[u] -= 1\n                count[v] += 1\n        for u, v in guesses:\n            if count[u] >= k and (count[u] - ((v, u) in guess_set)) < k:\n                count[u] = -n\n            if count[v] >= k and (count[v] - ((u, v) in guess_set)) < k:\n                count[v] = -n\n        return len([1 for x in count if x >= k])\n```", "extracted_code": "\nclass Solution:\n    def rootCount(self, edges, guesses, k):\n        n = len(edges) + 1\n        count = [0] * n\n        guess_set = set(tuple(x) for x in guesses)\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n            if (u, v) in guess_set or (v, u) in guess_set:\n                count[u] -= 1\n                count[v] += 1\n        for u, v in guesses:\n            if count[u] >= k and (count[u] - ((v, u) in guess_set)) < k:\n                count[u] = -n\n            if count[v] >= k and (count[v] - ((u, v) in guess_set)) < k:\n                count[v] = -n\n        return len([1 for x in count if x >= k])\n", "difficulty": 3.0}
{"task_id": "LeetCode/2579", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        return 2*n*n - 2*n + 1\n```\nIn the first minute, we color one cell. For every minute thereafter, we color all the uncolored cells that touch a blue cell. Thus, the number of cells colored in minute `n` is `4(n-1)`. Therefore, the total number of colored cells after `n` minutes is the sum of arithmetic progression: `1 + 4*1 + 4*2 + ... + 4*(n-1) = 2n^2 - 2n + 1`.", "extracted_code": "\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        return 2*n*n - 2*n + 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2577", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        pq = [(grid[0][0], 0, 0)]\n        visited = [[0] * n for _ in range(m)]\n        visited[0][0] = 1\n        dirs = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n        \n        while pq:\n            time, x, y = heapq.heappop(pq)\n            if (x, y) == (m - 1, n - 1):\n                return time\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    heapq.heappush(pq, (max(time, grid[nx][ny]), nx, ny))\n        return -1\n```", "extracted_code": "\nimport heapq\nfrom typing import List\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        pq = [(grid[0][0], 0, 0)]\n        visited = [[0] * n for _ in range(m)]\n        visited[0][0] = 1\n        dirs = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n        \n        while pq:\n            time, x, y = heapq.heappop(pq)\n            if (x, y) == (m - 1, n - 1):\n                return time\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    heapq.heappush(pq, (max(time, grid[nx][ny]), nx, ny))\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2576", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums = sorted([(num, i) for i, num in enumerate(nums)])\n        dp = [0]*len(nums)\n        j = 0\n        for i in range(1, len(nums)):\n            while j < i and nums[j][0]*2 <= nums[i][0]:\n                j += 1\n            dp[i] = max(dp[i-1], dp[j-1]+2) if j != i else dp[i-1]\n        return dp[-1]\n```", "extracted_code": "\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums = sorted([(num, i) for i, num in enumerate(nums)])\n        dp = [0]*len(nums)\n        j = 0\n        for i in range(1, len(nums)):\n            while j < i and nums[j][0]*2 <= nums[i][0]:\n                j += 1\n            dp[i] = max(dp[i-1], dp[j-1]+2) if j != i else dp[i-1]\n        return dp[-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2573", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findTheString(self, lcp):\n        n = len(lcp)\n        word = [''] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] > lcp[i][j - 1] + 1:\n                    return ''\n                if lcp[i][j] <= lcp[i][j - 1]:\n                    continue\n                word[j] = word[j - 1] + chr(ord('a') + lcp[i][j] - 1)\n        return ''.join(word)\n```", "extracted_code": "\nclass Solution:\n    def findTheString(self, lcp):\n        n = len(lcp)\n        word = [''] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] > lcp[i][j - 1] + 1:\n                    return ''\n                if lcp[i][j] <= lcp[i][j - 1]:\n                    continue\n                word[j] = word[j - 1] + chr(ord('a') + lcp[i][j] - 1)\n        return ''.join(word)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2570", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeArrays(self, nums1: list[list[int]], nums2: list[list[int]]) -> list[list[int]]:\n        i, j = 0, 0\n        result = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i][0] < nums2[j][0]:\n                result.append(nums1[i])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                result.append(nums2[j])\n                j += 1\n            else:\n                result.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n        while i < len(nums1):\n            result.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            result.append(nums2[j])\n            j += 1\n        return result\n```", "extracted_code": "\nclass Solution:\n    def mergeArrays(self, nums1: list[list[int]], nums2: list[list[int]]) -> list[list[int]]:\n        i, j = 0, 0\n        result = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i][0] < nums2[j][0]:\n                result.append(nums1[i])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                result.append(nums2[j])\n                j += 1\n            else:\n                result.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n        while i < len(nums1):\n            result.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            result.append(nums2[j])\n            j += 1\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/2569", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def handleQuery(self, nums1, nums2, queries):\n        result = []\n        for q in queries:\n            if q[0] == 1:\n                for i in range(q[1], q[2] + 1):\n                    nums1[i] = 1 - nums1[i]\n            elif q[0] == 2:\n                for i in range(len(nums1)):\n                    nums2[i] += nums1[i] * q[1]\n            elif q[0] == 3:\n                result.append(sum(nums2))\n        return result\n```", "extracted_code": "\nclass Solution:\n    def handleQuery(self, nums1, nums2, queries):\n        result = []\n        for q in queries:\n            if q[0] == 1:\n                for i in range(q[1], q[2] + 1):\n                    nums1[i] = 1 - nums1[i]\n            elif q[0] == 2:\n                for i in range(len(nums1)):\n                    nums2[i] += nums1[i] * q[1]\n            elif q[0] == 3:\n                result.append(sum(nums2))\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2568", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        nums.sort()\n        res = 1\n        for num in nums:\n            if num > res:\n                break\n            res += num\n        return res\n```", "extracted_code": "\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        nums.sort()\n        res = 1\n        for num in nums:\n            if num > res:\n                break\n            res += num\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2565", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        left, right = float('inf'), float('-inf')\n        position = {c: [] for c in set(s)}\n        for i, c in enumerate(s):\n            position[c].append(i)\n        for c in t:\n            if not position[c]:\n                left = min(left, right)\n                right = float('-inf')\n            elif position[c][0] > right:\n                right = position[c].pop(0)\n            else:\n                left = min(left, position[c][0])\n                right = position[c].pop(0)\n        return right - left + 1 if left != float('inf') else len(t)\n```", "extracted_code": "\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        left, right = float('inf'), float('-inf')\n        position = {c: [] for c in set(s)}\n        for i, c in enumerate(s):\n            position[c].append(i)\n        for c in t:\n            if not position[c]:\n                left = min(left, right)\n                right = float('-inf')\n            elif position[c][0] > right:\n                right = position[c].pop(0)\n            else:\n                left = min(left, position[c][0])\n                right = position[c].pop(0)\n        return right - left + 1 if left != float('inf') else len(t)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2564", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def substringXorQueries(self, s: str, queries: [[int]]) -> [[int]]:\n\n        prefix = [0]\n        for i in range(len(s)):\n            prefix.append(prefix[-1] ^ int(s[i]))\n\n        ans = []\n        for first, second in queries:\n            target = first ^ second\n            start = end = -1\n            for i in range(len(prefix)):\n                for j in range(i + 1, len(prefix)):\n                    if prefix[j] ^ prefix[i] == target:\n                        start, end = i, j - 1\n                        break\n                if start != -1:\n                    break\n            ans.append([start, end])\n\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def substringXorQueries(self, s: str, queries: [[int]]) -> [[int]]:\n\n        prefix = [0]\n        for i in range(len(s)):\n            prefix.append(prefix[-1] ^ int(s[i]))\n\n        ans = []\n        for first, second in queries:\n            target = first ^ second\n            start = end = -1\n            for i in range(len(prefix)):\n                for j in range(i + 1, len(prefix)):\n                    if prefix[j] ^ prefix[i] == target:\n                        start, end = i, j - 1\n                        break\n                if start != -1:\n                    break\n            ans.append([start, end])\n\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2563", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if lower <= nums[i] + nums[j] <= upper:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if lower <= nums[i] + nums[j] <= upper:\n                    count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2561", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, basket1, basket2):\n        basket1.sort()\n        basket2.sort()\n        cost = 0\n        i = j = 0\n        while i < len(basket1) and j < len(basket2):\n            if basket1[i] < basket2[j]:\n                cost += basket1[i]\n                i += 1\n            elif basket1[i] > basket2[j]:\n                cost += basket2[j]\n                j += 1\n            else:\n                i += 1\n                j += 1\n        if i < len(basket1) or j < len(basket2):\n            return -1\n        else:\n            return cost\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, basket1, basket2):\n        basket1.sort()\n        basket2.sort()\n        cost = 0\n        i = j = 0\n        while i < len(basket1) and j < len(basket2):\n            if basket1[i] < basket2[j]:\n                cost += basket1[i]\n                i += 1\n            elif basket1[i] > basket2[j]:\n                cost += basket2[j]\n                j += 1\n            else:\n                i += 1\n                j += 1\n        if i < len(basket1) or j < len(basket2):\n            return -1\n        else:\n            return cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2560", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        def check(mid):\n            cnt = dp = 0\n            for i in range(len(nums)):\n                if nums[i] > mid:\n                    return False\n                if dp + nums[i] > mid:\n                    dp = nums[i]\n                    cnt += 1\n                else:\n                    dp += nums[i]\n            cnt += dp > 0\n            return cnt <= k\n\n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n```", "extracted_code": "\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        def check(mid):\n            cnt = dp = 0\n            for i in range(len(nums)):\n                if nums[i] > mid:\n                    return False\n                if dp + nums[i] > mid:\n                    dp = nums[i]\n                    cnt += 1\n                else:\n                    dp += nums[i]\n            cnt += dp > 0\n            return cnt <= k\n\n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "difficulty": 2.0}
{"task_id": "LeetCode/2556", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0)]\n        visited = [[0]*n for _ in range(m)]\n        \n        def dfs(x, y):\n            if x == m - 1 and y == n - 1:\n                return True\n            if visited[x][y]:\n                return False\n            visited[x][y] = 1\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and dfs(nx, ny):\n                    return True\n            return False\n        \n        if not dfs(0, 0):\n            return False\n        visited = [[0]*n for _ in range(m)]\n        if dfs(0, 0):\n            return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0)]\n        visited = [[0]*n for _ in range(m)]\n        \n        def dfs(x, y):\n            if x == m - 1 and y == n - 1:\n                return True\n            if visited[x][y]:\n                return False\n            visited[x][y] = 1\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and dfs(nx, ny):\n                    return True\n            return False\n        \n        if not dfs(0, 0):\n            return False\n        visited = [[0]*n for _ in range(m)]\n        if dfs(0, 0):\n            return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2555", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        prizePositions.append(float('inf'))\n        left = count = best = 0\n        for right in range(len(prizePositions)):\n            while prizePositions[right] - prizePositions[left] > k:\n                if prizePositions[left] == prizePositions[left+1]:\n                    count -= 1\n                left += 1\n            count += 1\n            best = max(best, count)\n        return best\n```", "extracted_code": "\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        prizePositions.append(float('inf'))\n        left = count = best = 0\n        for right in range(len(prizePositions)):\n            while prizePositions[right] - prizePositions[left] > k:\n                if prizePositions[left] == prizePositions[left+1]:\n                    count -= 1\n                left += 1\n            count += 1\n            best = max(best, count)\n        return best\n", "difficulty": 2.0}
{"task_id": "LeetCode/2554", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        count = 0\n        total = 0\n        for i in range(n, 0, -1):\n            if i not in banned:\n                if total + i <= maxSum:\n                    total += i\n                    count += 1\n                else:\n                    break\n        return count\n```", "extracted_code": "\nclass Solution:\n    def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        count = 0\n        total = 0\n        for i in range(n, 0, -1):\n            if i not in banned:\n                if total + i <= maxSum:\n                    total += i\n                    count += 1\n                else:\n                    break\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2552", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2551", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        prefix_sum = [0] * (len(weights)+1)\n        for i in range(len(weights)):\n            prefix_sum[i+1] = prefix_sum[i] + weights[i]\n        dp = [0] + [float('inf')] * len(weights)\n        for _ in range(k):\n            new_dp = [0] * (len(weights)+1)\n            j = 0\n            for i in range(1, len(weights)+1):\n                while dp[j] <= prefix_sum[i] - dp[j]:\n                    j += 1\n                new_dp[i] = max(dp[j-1], prefix_sum[i] - dp[j-1])\n                if j < i:\n                    new_dp[i] = min(new_dp[i], max(dp[j], prefix_sum[i] - dp[j]))\n            dp = new_dp\n        return dp[-1] - dp[0]\n```", "extracted_code": "\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        prefix_sum = [0] * (len(weights)+1)\n        for i in range(len(weights)):\n            prefix_sum[i+1] = prefix_sum[i] + weights[i]\n        dp = [0] + [float('inf')] * len(weights)\n        for _ in range(k):\n            new_dp = [0] * (len(weights)+1)\n            j = 0\n            for i in range(1, len(weights)+1):\n                while dp[j] <= prefix_sum[i] - dp[j]:\n                    j += 1\n                new_dp[i] = max(dp[j-1], prefix_sum[i] - dp[j-1])\n                if j < i:\n                    new_dp[i] = min(new_dp[i], max(dp[j], prefix_sum[i] - dp[j]))\n            dp = new_dp\n        return dp[-1] - dp[0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2550", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        mod = 10**9 + 7\n        two = [1]\n        for i in range(50):\n            two.append(two[-1]*2%mod)\n        ans = two[n]-1\n        for i in range(1, min(n, 50)):\n            ans = (ans + mod - two[n-i]*two[i]%mod) % mod\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        mod = 10**9 + 7\n        two = [1]\n        for i in range(50):\n            two.append(two[-1]*2%mod)\n        ans = two[n]-1\n        for i in range(1, min(n, 50)):\n            ans = (ans + mod - two[n-i]*two[i]%mod) % mod\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2547", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums, k):\n        n = len(nums)\n        dp, acc = [0]*(n+1), [0]*(n+1)\n        count = [0]*n\n        stack = []\n        for i, num in enumerate(nums):\n            while stack and nums[stack[-1]] == num:\n                j = stack.pop()\n                count[j] = 0 if not stack or nums[stack[-1]] != num else stack[-1] - j + 1\n            stack.append(i)\n        while stack:\n            j = stack.pop()\n            count[j] = 0 if not stack or nums[stack[-1]] != nums[j] else stack[-1] - j + 1\n        for i in range(n-1, -1, -1):\n            acc[i] = acc[i+1] + count[i]\n        for i in range(1, n+1):\n            dp[i] = dp[i-1] + k + acc[i-1]\n            j = i-1\n            while j >= 1 and nums[j-1] == nums[i-1]:\n                j -= count[j]\n                dp[i] = min(dp[i], dp[j] + k + acc[j])\n        return dp[-1]\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums, k):\n        n = len(nums)\n        dp, acc = [0]*(n+1), [0]*(n+1)\n        count = [0]*n\n        stack = []\n        for i, num in enumerate(nums):\n            while stack and nums[stack[-1]] == num:\n                j = stack.pop()\n                count[j] = 0 if not stack or nums[stack[-1]] != num else stack[-1] - j + 1\n            stack.append(i)\n        while stack:\n            j = stack.pop()\n            count[j] = 0 if not stack or nums[stack[-1]] != nums[j] else stack[-1] - j + 1\n        for i in range(n-1, -1, -1):\n            acc[i] = acc[i+1] + count[i]\n        for i in range(1, n+1):\n            dp[i] = dp[i-1] + k + acc[i-1]\n            j = i-1\n            while j >= 1 and nums[j-1] == nums[i-1]:\n                j -= count[j]\n                dp[i] = min(dp[i], dp[j] + k + acc[j])\n        return dp[-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2546", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        s_count = s.count('1')\n        target_count = target.count('1')\n        return s_count >= target_count\n```", "extracted_code": "\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        s_count = s.count('1')\n        target_count = target.count('1')\n        return s_count >= target_count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2545", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortTheStudents(self, score, k):\n        score.sort(key=lambda x: -x[k])\n        return score\n```", "extracted_code": "\nclass Solution:\n    def sortTheStudents(self, score, k):\n        score.sort(key=lambda x: -x[k])\n        return score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2543", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        while targetX >= 1 and targetY >= 1:\n            if targetX > targetY:\n                targetX, targetY = targetY, targetX % targetY\n            else:\n                targetX, targetY = targetX % targetY, targetX\n        return targetX == targetY == 1\n```", "extracted_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        while targetX >= 1 and targetY >= 1:\n            if targetX > targetY:\n                targetX, targetY = targetY, targetX % targetY\n            else:\n                targetX, targetY = targetX % targetY, targetX\n        return targetX == targetY == 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2538", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        sz, dp, ans = [0] * n, [0] * n, [0] * n\n        def dfs1(u: int, f: int) -> None:\n            dp[u] = price[u]\n            sz[u] = 1\n            for v in g[u]:\n                if v == f:\n                    continue\n                dfs1(v, u)\n                dp[u] += dp[v]\n                sz[u] += sz[v]\n        def dfs2(u: int, f: int) -> None:\n            ans[u] = dp[u]\n            for v in g[u]:\n                if v == f:\n                    continue\n                dp_u, dp_v, sz_u, sz_v = dp[u], dp[v], sz[u], sz[v]\n                dp[u] -= dp[v]\n                sz[u] -= sz[v]\n                dp[v] += dp[u]\n                sz[v] += sz[u]\n                dfs2(v, u)\n                dp[u], dp[v], sz[u], sz[v] = dp_u, dp_v, sz_u, sz_v\n        dfs1(0, -1)\n        dfs2(0, -1)\n        return max(ans)\n```", "extracted_code": "\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        sz, dp, ans = [0] * n, [0] * n, [0] * n\n        def dfs1(u: int, f: int) -> None:\n            dp[u] = price[u]\n            sz[u] = 1\n            for v in g[u]:\n                if v == f:\n                    continue\n                dfs1(v, u)\n                dp[u] += dp[v]\n                sz[u] += sz[v]\n        def dfs2(u: int, f: int) -> None:\n            ans[u] = dp[u]\n            for v in g[u]:\n                if v == f:\n                    continue\n                dp_u, dp_v, sz_u, sz_v = dp[u], dp[v], sz[u], sz[v]\n                dp[u] -= dp[v]\n                sz[u] -= sz[v]\n                dp[v] += dp[u]\n                sz[v] += sz[u]\n                dfs2(v, u)\n                dp[u], dp[v], sz[u], sz[v] = dp_u, dp_v, sz_u, sz_v\n        dfs1(0, -1)\n        dfs2(0, -1)\n        return max(ans)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2532", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        time = sorted([(t[0] + t[2], t[1] + t[3], t[0], t[2]) for t in time])\n        left, right = [0]*k, [0]*k\n        for _ in range(n):\n            if max(left) >= max(right):\n                i = left.index(max(left))\n                right[i] = max(left) + time[i][1]\n                left[i] = right[i] + time[i][2]\n            else:\n                i = right.index(max(right))\n                right[i] = max(right) + time[i][1]\n        return max(right)\n```", "extracted_code": "\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        time = sorted([(t[0] + t[2], t[1] + t[3], t[0], t[2]) for t in time])\n        left, right = [0]*k, [0]*k\n        for _ in range(n):\n            if max(left) >= max(right):\n                i = left.index(max(left))\n                right[i] = max(left) + time[i][1]\n                left[i] = right[i] + time[i][2]\n            else:\n                i = right.index(max(right))\n                right[i] = max(right) + time[i][1]\n        return max(right)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2531", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        set1, set2 = set(word1), set(word2)\n        if abs(len(set1) - len(set2)) > 1:\n            return False\n        elif len(set1) == len(set2):\n            return True\n        else:\n            bigger_set = set1 if len(set1) > len(set2) else set2\n            smaller_set = set1 if len(set1) < len(set2) else set2\n            return any(letter not in smaller_set for letter in bigger_set)\n```", "extracted_code": "\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        set1, set2 = set(word1), set(word2)\n        if abs(len(set1) - len(set2)) > 1:\n            return False\n        elif len(set1) == len(set2):\n            return True\n        else:\n            bigger_set = set1 if len(set1) > len(set2) else set2\n            smaller_set = set1 if len(set1) < len(set2) else set2\n            return any(letter not in smaller_set for letter in bigger_set)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2528", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPower(self, stations, r, k):\n        n = len(stations)\n        prefix = [0] * (n + 2 * r + 1)\n        for i in range(n):\n            prefix[i + r + 1] = prefix[i + r] + stations[i]\n        left = [0] * n\n        right = [0] * n\n        q = []\n        for i in range(n):\n            while q and q[0][1] < i - r:\n                q.pop(0)\n            if q:\n                left[i] = max(left[i], q[0][0] + prefix[i + r + 1])\n            while q and q[-1][0] <= prefix[i + r + 1] - left[i]:\n                q.pop()\n            q.append((prefix[i + r + 1] - left[i], i))\n        q = []\n        for i in range(n - 1, -1, -1):\n            while q and q[0][1] > i + r:\n                q.pop(0)\n            if q:\n                right[i] = max(right[i], q[0][0] + prefix[i + r + 2])\n            while q and q[-1][0] <= prefix[i + r + 2] - right[i]:\n                q.pop()\n            q.append((prefix[i + r + 2] - right[i], i))\n        answer = 0\n        for i in range(n):\n            answer = max(answer, min(left[i] + right[i] + k, prefix[i + r + 1] + prefix[n + r + 1] - prefix[i + 1]))\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def maxPower(self, stations, r, k):\n        n = len(stations)\n        prefix = [0] * (n + 2 * r + 1)\n        for i in range(n):\n            prefix[i + r + 1] = prefix[i + r] + stations[i]\n        left = [0] * n\n        right = [0] * n\n        q = []\n        for i in range(n):\n            while q and q[0][1] < i - r:\n                q.pop(0)\n            if q:\n                left[i] = max(left[i], q[0][0] + prefix[i + r + 1])\n            while q and q[-1][0] <= prefix[i + r + 1] - left[i]:\n                q.pop()\n            q.append((prefix[i + r + 1] - left[i], i))\n        q = []\n        for i in range(n - 1, -1, -1):\n            while q and q[0][1] > i + r:\n                q.pop(0)\n            if q:\n                right[i] = max(right[i], q[0][0] + prefix[i + r + 2])\n            while q and q[-1][0] <= prefix[i + r + 2] - right[i]:\n                q.pop()\n            q.append((prefix[i + r + 2] - right[i], i))\n        answer = 0\n        for i in range(n):\n            answer = max(answer, min(left[i] + right[i] + k, prefix[i + r + 1] + prefix[n + r + 1] - prefix[i + 1]))\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2523", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> list[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            if n == 2:\n                return True\n            if n % 2 == 0:\n                return False\n            for i in range(3, int(n**0.5)+1, 2):\n                if n % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right+1) if is_prime(i)]\n        if len(primes) < 2:\n            return [-1, -1]\n\n        min_diff = primes[1] - primes[0]\n        result = [primes[0], primes[1]]\n        for i in range(2, len(primes)):\n            diff = primes[i] - primes[i-1]\n            if diff < min_diff:\n                min_diff = diff\n                result = [primes[i-1], primes[i]]\n        return result\n```", "extracted_code": "\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> list[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            if n == 2:\n                return True\n            if n % 2 == 0:\n                return False\n            for i in range(3, int(n**0.5)+1, 2):\n                if n % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right+1) if is_prime(i)]\n        if len(primes) < 2:\n            return [-1, -1]\n\n        min_diff = primes[1] - primes[0]\n        result = [primes[0], primes[1]]\n        for i in range(2, len(primes)):\n            diff = primes[i] - primes[i-1]\n            if diff < min_diff:\n                min_diff = diff\n                result = [primes[i-1], primes[i]]\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2521", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def primeFactors(n):\n            factors = set()\n            while n % 2 == 0:\n                factors.add(2),\n                n = n / 2\n            for i in range(3, int(n ** 0.5) + 1, 2):\n                while n % i == 0:\n                    factors.add(i)\n                    n = n / i\n            if n > 2:\n                factors.add(n)\n            return factors\n\n        product = 1\n        for num in nums:\n            product *= num\n        distinct_primes = primeFactors(product)\n        return len(distinct_primes)\n```", "extracted_code": "\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def primeFactors(n):\n            factors = set()\n            while n % 2 == 0:\n                factors.add(2),\n                n = n / 2\n            for i in range(3, int(n ** 0.5) + 1, 2):\n                while n % i == 0:\n                    factors.add(i)\n                    n = n / i\n            if n > 2:\n                factors.add(n)\n            return factors\n\n        product = 1\n        for num in nums:\n            product *= num\n        distinct_primes = primeFactors(product)\n        return len(distinct_primes)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2518", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n        dp[0][0] = 1\n        sumNums = [0] * (n + 2)\n        for i in range(1, n + 1):\n            sumNums[i] = sumNums[i - 1] + nums[i - 1]\n        for i in range(n):\n            for j in range(i + 1):\n                if sumNums[i + 1] - sumNums[j] >= k and sumNums[j] >= k:\n                    dp[i + 1][j + 1] += dp[i][j]\n                    dp[i + 1][j + 1] %= MOD\n                dp[i + 1][j] += dp[i][j]\n                dp[i + 1][j] %= MOD\n        res = 0\n        for i in range(n + 1):\n            res += dp[n][i]\n            res %= MOD\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]\n        dp[0][0] = 1\n        sumNums = [0] * (n + 2)\n        for i in range(1, n + 1):\n            sumNums[i] = sumNums[i - 1] + nums[i - 1]\n        for i in range(n):\n            for j in range(i + 1):\n                if sumNums[i + 1] - sumNums[j] >= k and sumNums[j] >= k:\n                    dp[i + 1][j + 1] += dp[i][j]\n                    dp[i + 1][j + 1] %= MOD\n                dp[i + 1][j] += dp[i][j]\n                dp[i + 1][j] %= MOD\n        res = 0\n        for i in range(n + 1):\n            res += dp[n][i]\n            res %= MOD\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2517", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        l, r = 0, len(price) - 1\n        result = float('inf')\n        while r - l + 1 > k:\n            result = min(result, price[r] - price[l])\n            if price[r] - price[r - 1] > price[l + 1] - price[l]:\n                r -= 1\n            else:\n                l += 1\n        return min(result, price[r] - price[l])\n```", "extracted_code": "\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        l, r = 0, len(price) - 1\n        result = float('inf')\n        while r - l + 1 > k:\n            result = min(result, price[r] - price[l])\n            if price[r] - price[r - 1] > price[l + 1] - price[l]:\n                r -= 1\n            else:\n                l += 1\n        return min(result, price[r] - price[l])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2516", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        from collections import Counter\n        left_counter = Counter()\n        right_counter = Counter(s)\n        left_index = 0\n        right_index = len(s)\n        while left_index < right_index:\n            if left_counter['a'] < k or left_counter['b'] < k or left_counter['c'] < k:\n                if right_counter[s[left_index]] >= k:\n                    left_counter[s[left_index]] += 1\n                    left_index += 1\n                elif right_counter[s[right_index-1]] >= k:\n                    right_counter[s[right_index-1]] -= 1\n                    right_index -= 1\n                else:\n                    return -1\n            else:\n                break\n        if left_counter['a'] < k or left_counter['b'] < k or left_counter['c'] < k:\n            return -1\n        return len(s) - right_index + left_index\n```", "extracted_code": "\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        from collections import Counter\n        left_counter = Counter()\n        right_counter = Counter(s)\n        left_index = 0\n        right_index = len(s)\n        while left_index < right_index:\n            if left_counter['a'] < k or left_counter['b'] < k or left_counter['c'] < k:\n                if right_counter[s[left_index]] >= k:\n                    left_counter[s[left_index]] += 1\n                    left_index += 1\n                elif right_counter[s[right_index-1]] >= k:\n                    right_counter[s[right_index-1]] -= 1\n                    right_index -= 1\n                else:\n                    return -1\n            else:\n                break\n        if left_counter['a'] < k or left_counter['b'] < k or left_counter['c'] < k:\n            return -1\n        return len(s) - right_index + left_index\n", "difficulty": 2.0}
{"task_id": "LeetCode/2514", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        words = s.split(' ')\n        MOD = 10**9 + 7\n        factorial = [1] * (len(s) + 1)\n        for i in range(1, len(s) + 1):\n            factorial[i] = (factorial[i - 1] * i) % MOD\n        res = 1\n        for word in words:\n            count = [0] * 26\n            for c in word:\n                count[ord(c) - ord('a')] += 1\n            cur = factorial[len(word)]\n            for c in count:\n                cur = (cur * pow(factorial[c], MOD - 2, MOD)) % MOD\n            res = (res * cur) % MOD\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        words = s.split(' ')\n        MOD = 10**9 + 7\n        factorial = [1] * (len(s) + 1)\n        for i in range(1, len(s) + 1):\n            factorial[i] = (factorial[i - 1] * i) % MOD\n        res = 1\n        for word in words:\n            count = [0] * 26\n            for c in word:\n                count[ord(c) - ord('a')] += 1\n            cur = factorial[len(word)]\n            for c in count:\n                cur = (cur * pow(factorial[c], MOD - 2, MOD)) % MOD\n            res = (res * cur) % MOD\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2513", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        max1 = divisor1 * uniqueCnt1\n        max2 = divisor2 * uniqueCnt2\n        common = min(max1, max2)\n        if max1 < max2:\n            uniqueCnt1, uniqueCnt2 = uniqueCnt2, uniqueCnt1\n            divisor1, divisor2 = divisor2, divisor1\n        while uniqueCnt1 > 0 or uniqueCnt2 > 0:\n            if common % divisor1 != 0 and uniqueCnt1 > 0:\n                uniqueCnt1 -= 1\n            elif common % divisor2 != 0 and uniqueCnt2 > 0:\n                uniqueCnt2 -= 1\n            common += 1\n        return common - 1\n```", "extracted_code": "\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        max1 = divisor1 * uniqueCnt1\n        max2 = divisor2 * uniqueCnt2\n        common = min(max1, max2)\n        if max1 < max2:\n            uniqueCnt1, uniqueCnt2 = uniqueCnt2, uniqueCnt1\n            divisor1, divisor2 = divisor2, divisor1\n        while uniqueCnt1 > 0 or uniqueCnt2 > 0:\n            if common % divisor1 != 0 and uniqueCnt1 > 0:\n                uniqueCnt1 -= 1\n            elif common % divisor2 != 0 and uniqueCnt2 > 0:\n                uniqueCnt2 -= 1\n            common += 1\n        return common - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2509", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dist(a, b):\n            d = 0\n            while a != b:\n                if a < b:\n                    a, b = b, a\n                a >>= 1\n                d += 1\n            return d\n        \n        return [dist(a, b) + 1 for a, b in queries]\n```", "extracted_code": "\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def dist(a, b):\n            d = 0\n            while a != b:\n                if a < b:\n                    a, b = b, a\n                a >>= 1\n                d += 1\n            return d\n        \n        return [dist(a, b) + 1 for a, b in queries]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2508", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for u, v in edges:\n            degree[u] += 1\n            degree[v] += 1\n\n        odd_degree_nodes = [i for i in range(1, n + 1) if degree[i] % 2 == 1]\n        if len(odd_degree_nodes) > 2:\n            return False\n        elif len(odd_degree_nodes) == 2:\n            return True\n        else:\n            return len(odd_degree_nodes) == 0 or len(edges) % 2 == 0\n```", "extracted_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for u, v in edges:\n            degree[u] += 1\n            degree[v] += 1\n\n        odd_degree_nodes = [i for i in range(1, n + 1) if degree[i] % 2 == 1]\n        if len(odd_degree_nodes) > 2:\n            return False\n        elif len(odd_degree_nodes) == 2:\n            return True\n        else:\n            return len(odd_degree_nodes) == 0 or len(edges) % 2 == 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2507", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(n):\n            i = 2\n            factors = []\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            if n > 1:\n                factors.append(n)\n            return factors\n        \n        while True:\n            factors = prime_factors(n)\n            new_n = sum(factors)\n            if new_n == n:\n                return n\n            n = new_n\n```", "extracted_code": "\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(n):\n            i = 2\n            factors = []\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            if n > 1:\n                factors.append(n)\n            return factors\n        \n        while True:\n            factors = prime_factors(n)\n            new_n = sum(factors)\n            if new_n == n:\n                return n\n            n = new_n\n", "difficulty": 2.0}
{"task_id": "LeetCode/2503", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        sorted_grid = sorted((i, j) for i in range(m) for j in range(n))\n        sorted_grid.sort(key = lambda x: -grid[x[0]][x[1]])\n\n        prefix = [0] * (m*n)\n        prefix[0] = grid[sorted_grid[0][0]][sorted_grid[0][1]]\n        for i in range(1, m*n):\n            prefix[i] = max(prefix[i-1], grid[sorted_grid[i][0]][sorted_grid[i][1]])\n\n        answer = []\n        for q in queries:\n            index = len(sorted_grid) - 1\n            while index >= 0 and grid[sorted_grid[index][0]][sorted_grid[index][1]] >= q:\n                index -= 1\n            answer.append(prefix[index] if index >= 0 else 0)\n\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        sorted_grid = sorted((i, j) for i in range(m) for j in range(n))\n        sorted_grid.sort(key = lambda x: -grid[x[0]][x[1]])\n\n        prefix = [0] * (m*n)\n        prefix[0] = grid[sorted_grid[0][0]][sorted_grid[0][1]]\n        for i in range(1, m*n):\n            prefix[i] = max(prefix[i-1], grid[sorted_grid[i][0]][sorted_grid[i][1]])\n\n        answer = []\n        for q in queries:\n            index = len(sorted_grid) - 1\n            while index >= 0 and grid[sorted_grid[index][0]][sorted_grid[index][1]] >= q:\n                index -= 1\n            answer.append(prefix[index] if index >= 0 else 0)\n\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2501", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSquareStreak(self, nums):\n        nums.sort()\n        dp = [0]*len(nums)\n        res = 0\n        for i in range(len(nums)):\n            j = i - 1\n            while j >= 0:\n                if nums[i] == nums[j] * nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n                    res = max(res, dp[i])\n                elif nums[i] > nums[j] * nums[j]:\n                    break\n                j -= 1\n        return res+1 if res > 0 else -1\n```", "extracted_code": "\nclass Solution:\n    def longestSquareStreak(self, nums):\n        nums.sort()\n        dp = [0]*len(nums)\n        res = 0\n        for i in range(len(nums)):\n            j = i - 1\n            while j >= 0:\n                if nums[i] == nums[j] * nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n                    res = max(res, dp[i])\n                elif nums[i] > nums[j] * nums[j]:\n                    break\n                j -= 1\n        return res+1 if res > 0 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2499", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        min_cost = [float('inf')] * (n + 1)\n        counts = [0] * (n + 1)\n        indices = [[] for _ in range(n + 1)]\n        for i in range(n):\n            counts[nums1[i]] += 1\n            indices[nums1[i]].append(i)\n        for i in range(n):\n            if counts[nums2[i]] > 0:\n                counts[nums2[i]] -= 1\n                min_cost[nums2[i]] = min(min_cost[nums2[i]], indices[nums2[i]][counts[nums2[i]]])\n        total_cost = 0\n        for i in range(1, n + 1):\n            if min_cost[i] != float('inf'):\n                total_cost += min_cost[i]\n        return total_cost if total_cost < float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        min_cost = [float('inf')] * (n + 1)\n        counts = [0] * (n + 1)\n        indices = [[] for _ in range(n + 1)]\n        for i in range(n):\n            counts[nums1[i]] += 1\n            indices[nums1[i]].append(i)\n        for i in range(n):\n            if counts[nums2[i]] > 0:\n                counts[nums2[i]] -= 1\n                min_cost[nums2[i]] = min(min_cost[nums2[i]], indices[nums2[i]][counts[nums2[i]]])\n        total_cost = 0\n        for i in range(1, n + 1):\n            if min_cost[i] != float('inf'):\n                total_cost += min_cost[i]\n        return total_cost if total_cost < float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2498", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        left, right = 0, stones[-1]\n        while left < right:\n            mid = (left + right + 1) // 2\n            current, count = 0, 0\n            for stone in stones:\n                if stone - current >= mid:\n                    current = stone\n                    count += 1\n            if count >= 3:\n                left = mid\n            else:\n                right = mid - 1\n        return right\n```", "extracted_code": "\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        left, right = 0, stones[-1]\n        while left < right:\n            mid = (left + right + 1) // 2\n            current, count = 0, 0\n            for stone in stones:\n                if stone - current >= mid:\n                    current = stone\n                    count += 1\n            if count >= 3:\n                left = mid\n            else:\n                right = mid - 1\n        return right\n", "difficulty": 2.0}
{"task_id": "LeetCode/2497", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "Here is the complete function that solves the problem:\n\n```python\nimport heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        adj = defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        \n        max_sum = max(vals)\n        for node, neighbors in adj.items():\n            if len(neighbors) <= k:\n                max_sum = max(max_sum, sum(heapq.nlargest(k, (vals[i] for i in neighbors))) + vals[node])\n            \n        return max_sum\n```\nThis function first constructs an adjacency list representation of the graph. Then it iterates over each node. If the node has `k` or fewer neighbors, it calculates the sum of the values of the `k` highest-valued neighbors and the value of the node itself, and updates `max_sum` if this sum is greater than the current `max_sum`. The function finally returns `max_sum`. The use of a heap ensures that the `k` highest-valued neighbors can be found in `O(n log k)` time, where `n` is the number of neighbors.", "extracted_code": "\nimport heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        adj = defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        \n        max_sum = max(vals)\n        for node, neighbors in adj.items():\n            if len(neighbors) <= k:\n                max_sum = max(max_sum, sum(heapq.nlargest(k, (vals[i] for i in neighbors))) + vals[node])\n            \n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2493", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        group = [0] * (n + 1)\n        max_group = 0\n\n        def dfs(node, parent, g):\n            nonlocal max_group\n            group[node] = g\n            max_group = max(max_group, g)\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                if group[neighbor] == 0:\n                    dfs(neighbor, node, 3 - g)\n                elif group[neighbor] == g:\n                    return False\n            return True\n\n        for i in range(1, n + 1):\n            if group[i] == 0 and not dfs(i, None, 1):\n                return -1\n\n        return max_group\n```\nIn the above solution, we use depth-first search (DFS) to traverse the graph. If the graph can be divided into two groups (group 1 and group 2), we assign each node to a group. If we encounter a situation where a node should be in group 1 but it's already been assigned to group 2 (or vice versa), then we return -1 as it's impossible to group the nodes with the given conditions. If we successfully assign all nodes to a group, we return the maximum group number.", "extracted_code": "\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        group = [0] * (n + 1)\n        max_group = 0\n\n        def dfs(node, parent, g):\n            nonlocal max_group\n            group[node] = g\n            max_group = max(max_group, g)\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                if group[neighbor] == 0:\n                    dfs(neighbor, node, 3 - g)\n                elif group[neighbor] == g:\n                    return False\n            return True\n\n        for i in range(1, n + 1):\n            if group[i] == 0 and not dfs(i, None, 1):\n                return -1\n\n        return max_group\n", "difficulty": 3.0}
{"task_id": "LeetCode/2488", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums, k):\n        pre, res, left, right = [0], 0, 0, 0\n        for i in range(1, len(nums) + 1):\n            pre.append(pre[-1] + (nums[i - 1] >= k))\n        for i in range(len(nums)):\n            if nums[i] != k: continue\n            cnt1, cnt2 = [0] * len(nums), [0] * len(nums)\n            left = right = i\n            while left >= 0 and nums[left] <= nums[i]:\n                cnt1[nums[left] <= nums[i]] += 1\n                left -= 1\n            while right < len(nums) and nums[right] <= nums[i]:\n                cnt2[nums[right] <= nums[i]] += 1\n                right += 1\n            res += cnt1[0] * cnt2[1] + cnt1[1] * cnt2[0]\n            res -= min(cnt1[0], cnt2[1]) + min(cnt1[1], cnt2[0])\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums, k):\n        pre, res, left, right = [0], 0, 0, 0\n        for i in range(1, len(nums) + 1):\n            pre.append(pre[-1] + (nums[i - 1] >= k))\n        for i in range(len(nums)):\n            if nums[i] != k: continue\n            cnt1, cnt2 = [0] * len(nums), [0] * len(nums)\n            left = right = i\n            while left >= 0 and nums[left] <= nums[i]:\n                cnt1[nums[left] <= nums[i]] += 1\n                left -= 1\n            while right < len(nums) and nums[right] <= nums[i]:\n                cnt2[nums[right] <= nums[i]] += 1\n                right += 1\n            res += cnt1[0] * cnt2[1] + cnt1[1] * cnt2[0]\n            res -= min(cnt1[0], cnt2[1]) + min(cnt1[1], cnt2[0])\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2487", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        new_head = self.removeNodes(head.next)\n        if new_head.val > head.val:\n            return new_head\n        else:\n            head.next = new_head\n            return head\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        new_head = self.removeNodes(head.next)\n        if new_head.val > head.val:\n            return new_head\n        else:\n            head.next = new_head\n            return head\n", "difficulty": 2.0}
{"task_id": "LeetCode/2484", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*10 for _ in range(10)]\n        prefix = [0]*10\n        res = 0\n        for ch in s:\n            digit = int(ch)\n            for i in range(10):\n                res = (res + dp[i][digit]) % MOD\n            new_prefix = prefix[:]\n            for i in range(10):\n                new_prefix[digit] = (new_prefix[digit] + dp[i][digit]) % MOD\n            new_prefix[digit] = (new_prefix[digit] + 1) % MOD\n            dp, prefix = [new_prefix[:] for _ in range(10)], new_prefix\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*10 for _ in range(10)]\n        prefix = [0]*10\n        res = 0\n        for ch in s:\n            digit = int(ch)\n            for i in range(10):\n                res = (res + dp[i][digit]) % MOD\n            new_prefix = prefix[:]\n            for i in range(10):\n                new_prefix[digit] = (new_prefix[digit] + dp[i][digit]) % MOD\n            new_prefix[digit] = (new_prefix[digit] + 1) % MOD\n            dp, prefix = [new_prefix[:] for _ in range(10)], new_prefix\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2483", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        penalty = [0] * (len(customers) + 1)\n        total_customers = customers.count('Y')\n        count_customers = 0\n        for i in range(len(customers)):\n            if customers[i] == 'Y':\n                count_customers += 1\n            penalty[i+1] = penalty[i] + (i + 1 - 2 * count_customers)\n        min_penalty = min(penalty)\n        return penalty.index(min_penalty)\n```", "extracted_code": "\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        penalty = [0] * (len(customers) + 1)\n        total_customers = customers.count('Y')\n        count_customers = 0\n        for i in range(len(customers)):\n            if customers[i] == 'Y':\n                count_customers += 1\n            penalty[i+1] = penalty[i] + (i + 1 - 2 * count_customers)\n        min_penalty = min(penalty)\n        return penalty.index(min_penalty)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2482", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow, onesCol = [0] * m, [0] * n\n        zerosRow, zerosCol = [0] * m, [0] * n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    onesRow[i] += 1\n                    onesCol[j] += 1\n                else:\n                    zerosRow[i] += 1\n                    zerosCol[j] += 1\n        diff = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]\n        return diff\n```", "extracted_code": "\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow, onesCol = [0] * m, [0] * n\n        zerosRow, zerosCol = [0] * m, [0] * n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    onesRow[i] += 1\n                    onesCol[j] += 1\n                else:\n                    zerosRow[i] += 1\n                    zerosCol[j] += 1\n        diff = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]\n        return diff\n", "difficulty": 2.0}
{"task_id": "LeetCode/2481", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        return n if n == 1 or n % 2 == 1 else n-1\n```", "extracted_code": "\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        return n if n == 1 or n % 2 == 1 else n-1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2476", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestNodes(self, root, queries):\n        def inorder(node):\n            if node:\n                inorder(node.left)\n                inorder_list.append(node.val)\n                inorder(node.right)\n                \n        inorder_list = []\n        inorder(root)\n        answer = []\n        for query in queries:\n            min_i = max([x for x in inorder_list if x <= query], default=-1)\n            max_i = min([x for x in inorder_list if x >= query], default=-1)\n            answer.append([min_i, max_i])\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def closestNodes(self, root, queries):\n        def inorder(node):\n            if node:\n                inorder(node.left)\n                inorder_list.append(node.val)\n                inorder(node.right)\n                \n        inorder_list = []\n        inorder(root)\n        answer = []\n        for query in queries:\n            min_i = max([x for x in inorder_list if x <= query], default=-1)\n            max_i = min([x for x in inorder_list if x >= query], default=-1)\n            answer.append([min_i, max_i])\n        return answer\n", "difficulty": 2.0}
{"task_id": "LeetCode/2471", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\nfrom heapq import nlargest\n\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        level_values = defaultdict(list)\n        \n        def dfs(node, level):\n            if node is not None:\n                level_values[level].append(node.val)\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n        \n        dfs(root, 0)\n        \n        swaps = 0\n        for values in level_values.values():\n            sorted_values = sorted(values)\n            for i, val in enumerate(nlargest(len(values), values)):\n                if val != sorted_values[i]:\n                    swaps += 1\n                    \n        return swaps // 2\n```", "extracted_code": "\nfrom collections import defaultdict\nfrom heapq import nlargest\n\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        level_values = defaultdict(list)\n        \n        def dfs(node, level):\n            if node is not None:\n                level_values[level].append(node.val)\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n        \n        dfs(root, 0)\n        \n        swaps = 0\n        for values in level_values.values():\n            sorted_values = sorted(values)\n            for i, val in enumerate(nlargest(len(values), values)):\n                if val != sorted_values[i]:\n                    swaps += 1\n                    \n        return swaps // 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2470", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            product = 1\n            for j in range(i, len(nums)):\n                product *= nums[j]\n                if product % k == 0 and product // k != 0:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            product = 1\n            for j in range(i, len(nums)):\n                product *= nums[j]\n                if product % k == 0 and product // k != 0:\n                    count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2466", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*(high+10) for _ in range(2)]\n        dp[0][0] = dp[1][0] = 1\n        for i in range(1, high+1):\n            for j in range(i, max(-1, i-zero)-1, -1):\n                dp[0][j] = (dp[0][j] + dp[0][j-1]) % MOD\n            for j in range(i, max(-1, i-one)-1, -1):\n                dp[1][j] = (dp[1][j] + dp[1][j-1]) % MOD\n            dp[0][i] = (dp[0][i] + dp[1][i-1]) % MOD\n            dp[1][i] = (dp[1][i] + dp[0][i-1]) % MOD\n        return (sum(dp[0][low:high+1]) + sum(dp[1][low:high+1])) % MOD\n```", "extracted_code": "\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*(high+10) for _ in range(2)]\n        dp[0][0] = dp[1][0] = 1\n        for i in range(1, high+1):\n            for j in range(i, max(-1, i-zero)-1, -1):\n                dp[0][j] = (dp[0][j] + dp[0][j-1]) % MOD\n            for j in range(i, max(-1, i-one)-1, -1):\n                dp[1][j] = (dp[1][j] + dp[1][j-1]) % MOD\n            dp[0][i] = (dp[0][i] + dp[1][i-1]) % MOD\n            dp[1][i] = (dp[1][i] + dp[0][i-1]) % MOD\n        return (sum(dp[0][low:high+1]) + sum(dp[1][low:high+1])) % MOD\n", "difficulty": 2.0}
{"task_id": "LeetCode/2462", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalCost(self, costs, k, candidates):\n        total_cost = 0\n        workers = [(c, i) for i, c in enumerate(costs)]\n        workers.sort()\n\n        first = workers[:candidates]\n        last = workers[-candidates:]\n        for _ in range(k):\n            if not first and not last:\n                break\n            if not first:\n                total_cost += last.pop(0)[0]\n            elif not last:\n                total_cost += first.pop(0)[0]\n            elif first[0] < last[0]:\n                total_cost += first.pop(0)[0]\n            else:\n                total_cost += last.pop(0)[0]\n        return total_cost\n```\nThis solution creates a sorted list of tuples, where each tuple contains the cost of hiring a worker and their index. It then creates two new lists: one with the first 'candidates' number of workers and another with the last 'candidates' number of workers. For 'k' iterations, it checks which worker has the lowest cost out of the first and last 'candidates' and hires them, adding their cost to the total cost. If there are no more workers in either the first or last 'candidates', it hires the remaining workers based on their cost. It finally returns the total cost.", "extracted_code": "\nclass Solution:\n    def totalCost(self, costs, k, candidates):\n        total_cost = 0\n        workers = [(c, i) for i, c in enumerate(costs)]\n        workers.sort()\n\n        first = workers[:candidates]\n        last = workers[-candidates:]\n        for _ in range(k):\n            if not first and not last:\n                break\n            if not first:\n                total_cost += last.pop(0)[0]\n            elif not last:\n                total_cost += first.pop(0)[0]\n            elif first[0] < last[0]:\n                total_cost += first.pop(0)[0]\n            else:\n                total_cost += last.pop(0)[0]\n        return total_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2461", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSubarraySum(self, nums, k):\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSubarraySum(self, nums, k):\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2457", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        def digit_sum(n):\n            return sum(int(digit) for digit in str(n))\n\n        x = 0\n        while digit_sum(n) > target:\n            n += 1\n            x += 1\n\n        return x\n```", "extracted_code": "\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        def digit_sum(n):\n            return sum(int(digit) for digit in str(n))\n\n        x = 0\n        while digit_sum(n) > target:\n            n += 1\n            x += 1\n\n        return x\n", "difficulty": 2.0}
{"task_id": "LeetCode/2455", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_div_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if len(even_div_by_3) > 0:\n            return sum(even_div_by_3) // len(even_div_by_3)\n        else:\n            return 0\n```", "extracted_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_div_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if len(even_div_by_3) > 0:\n            return sum(even_div_by_3) // len(even_div_by_3)\n        else:\n            return 0\n", "difficulty": 1.0}
{"task_id": "LeetCode/2443", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool: \n        for i in range(num//2+1):\n            if i + int(str(i)[::-1]) == num:\n                return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool: \n        for i in range(num//2+1):\n            if i + int(str(i)[::-1]) == num:\n                return True\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2442", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        nums += [int(str(num)[::-1]) for num in nums]\n        return len(set(nums))\n```", "extracted_code": "\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        nums += [int(str(num)[::-1]) for num in nums]\n        return len(set(nums))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2438", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 10**9 + 7\n        powers = []\n        while n:\n            count = 1\n            while (count << 1) <= n:\n                count <<= 1\n            n -= count\n            powers.append(count)\n        powers = powers[::-1]\n        prefix = [1]\n        for x in powers:\n            prefix.append(prefix[-1] * x % MOD)\n        return [prefix[right + 1] * pow(prefix[left], MOD - 2, MOD) % MOD for left, right in queries]\n```", "extracted_code": "\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 10**9 + 7\n        powers = []\n        while n:\n            count = 1\n            while (count << 1) <= n:\n                count <<= 1\n            n -= count\n            powers.append(count)\n        powers = powers[::-1]\n        prefix = [1]\n        for x in powers:\n            prefix.append(prefix[-1] * x % MOD)\n        return [prefix[right + 1] * pow(prefix[left], MOD - 2, MOD) % MOD for left, right in queries]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2434", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = []\n        p = []\n        for c in sorted(s):\n            while t and t[-1] <= c:\n                p.append(t.pop())\n            t.append(c)\n        return ''.join(p + list(reversed(t)))\n```", "extracted_code": "\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = []\n        p = []\n        for c in sorted(s):\n            while t and t[-1] <= c:\n                p.append(t.pop())\n            t.append(c)\n        return ''.join(p + list(reversed(t)))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2432", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        task_times = [0]*n\n        prev_time = 0\n        for log in logs:\n            task_times[log[0]] += log[1] - prev_time\n            prev_time = log[1]\n        return task_times.index(max(task_times))\n```", "extracted_code": "\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        task_times = [0]*n\n        prev_time = 0\n        for log in logs:\n            task_times[log[0]] += log[1] - prev_time\n            prev_time = log[1]\n        return task_times.index(max(task_times))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2429", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        bit_num2 = bin(num2).count('1')\n        for x in range(num1+1):\n            if bin(x).count('1') == bit_num2:\n                return x\n        return num1\n```", "extracted_code": "\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        bit_num2 = bin(num2).count('1')\n        for x in range(num1+1):\n            if bin(x).count('1') == bit_num2:\n                return x\n        return num1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2427", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        return sum(1 for i in range(1, min(a, b) + 1) if a % i == 0 and b % i == 0)\n```", "extracted_code": "\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        return sum(1 for i in range(1, min(a, b) + 1) if a % i == 0 and b % i == 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2425", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_all = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_all ^= (num1 ^ num2)\n        return xor_all\n```", "extracted_code": "\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_all = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_all ^= (num1 ^ num2)\n        return xor_all\n", "difficulty": 2.0}
{"task_id": "LeetCode/2424", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass LUPrefix:\n    def __init__(self, n: int):\n        self.uploaded = [0] * (n + 1)\n        self.max_uploaded = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded[video] = self.uploaded[video - 1] + 1\n        self.max_uploaded = max(self.max_uploaded, self.uploaded[video])\n\n    def longest(self) -> int:\n        return self.max_uploaded\n```", "extracted_code": "\nclass LUPrefix:\n    def __init__(self, n: int):\n        self.uploaded = [0] * (n + 1)\n        self.max_uploaded = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded[video] = self.uploaded[video - 1] + 1\n        self.max_uploaded = max(self.max_uploaded, self.uploaded[video])\n\n    def longest(self) -> int:\n        return self.max_uploaded\n", "difficulty": 2.0}
{"task_id": "LeetCode/2419", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def longestSubarray(self, nums):\n        max_bitwise_and = max(nums)\n        longest_subarray = max_len = 0\n        for num in nums:\n            if num == max_bitwise_and:\n                max_len += 1\n                longest_subarray = max(longest_subarray, max_len)\n            else:\n                max_len = 0\n        return longest_subarray\n```", "extracted_code": "\nclass Solution:\n    def longestSubarray(self, nums):\n        max_bitwise_and = max(nums)\n        longest_subarray = max_len = 0\n        for num in nums:\n            if num == max_bitwise_and:\n                max_len += 1\n                longest_subarray = max(longest_subarray, max_len)\n            else:\n                max_len = 0\n        return longest_subarray\n", "difficulty": 2.0}
{"task_id": "LeetCode/2413", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n if n % 2 == 0 else n * 2\n```", "extracted_code": "\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n if n % 2 == 0 else n * 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2409", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        arriveAlice = sum(daysInMonth[:int(arriveAlice[:2])-1]) + int(arriveAlice[3:])\n        leaveAlice = sum(daysInMonth[:int(leaveAlice[:2])-1]) + int(leaveAlice[3:])\n        arriveBob = sum(daysInMonth[:int(arriveBob[:2])-1]) + int(arriveBob[3:])\n        leaveBob = sum(daysInMonth[:int(leaveBob[:2])-1]) + int(leaveBob[3:])\n        return max(0, min(leaveAlice, leaveBob) - max(arriveAlice, arriveBob) + 1)\n```", "extracted_code": "\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        arriveAlice = sum(daysInMonth[:int(arriveAlice[:2])-1]) + int(arriveAlice[3:])\n        leaveAlice = sum(daysInMonth[:int(leaveAlice[:2])-1]) + int(leaveAlice[3:])\n        arriveBob = sum(daysInMonth[:int(arriveBob[:2])-1]) + int(arriveBob[3:])\n        leaveBob = sum(daysInMonth[:int(leaveBob[:2])-1]) + int(leaveBob[3:])\n        return max(0, min(leaveAlice, leaveBob) - max(arriveAlice, arriveBob) + 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        alpha_dict = {chr(97 + i): [-1, -1] for i in range(26)}\n        for i in range(len(s)):\n            if alpha_dict[s[i]][0] == -1:\n                alpha_dict[s[i]][0] = i\n            else:\n                alpha_dict[s[i]][1] = i\n        for k, v in alpha_dict.items():\n            if v[1] != -1 and v[1] - v[0] - 1 != distance[ord(k) - 97]:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        alpha_dict = {chr(97 + i): [-1, -1] for i in range(26)}\n        for i in range(len(s)):\n            if alpha_dict[s[i]][0] == -1:\n                alpha_dict[s[i]][0] = i\n            else:\n                alpha_dict[s[i]][1] = i\n        for k, v in alpha_dict.items():\n            if v[1] != -1 and v[1] - v[0] - 1 != distance[ord(k) - 97]:\n                return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2325", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        substitution_table = {}\n        cipher = \"\"\n        for c in key:\n            if c != ' ' and c not in cipher:\n                cipher += c\n        for i, c in enumerate(cipher):\n            substitution_table[c] = chr(97 + i)\n        return ''.join(substitution_table[c] if c != ' ' else ' ' for c in message)\n```", "extracted_code": "\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        substitution_table = {}\n        cipher = \"\"\n        for c in key:\n            if c != ' ' and c not in cipher:\n                cipher += c\n        for i, c in enumerate(cipher):\n            substitution_table[c] = chr(97 + i)\n        return ''.join(substitution_table[c] if c != ' ' else ' ' for c in message)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2269", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        num_str = str(num)\n        substrings = [num_str[i:i+k] for i in range(len(num_str)-k+1)]\n        k_beauty = 0\n        for substring in substrings:\n            if int(substring) != 0 and num % int(substring) == 0:\n                k_beauty += 1\n        return k_beauty\n```", "extracted_code": "\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        num_str = str(num)\n        substrings = [num_str[i:i+k] for i in range(len(num_str)-k+1)]\n        k_beauty = 0\n        for substring in substrings:\n            if int(substring) != 0 and num % int(substring) == 0:\n                k_beauty += 1\n        return k_beauty\n", "difficulty": 1.0}
{"task_id": "LeetCode/2259", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        max_num = \"\"\n        for i in range(len(number)):\n            if number[i] == digit:\n                temp = number[:i] + number[i+1:]\n                if int(temp) > int(max_num):\n                    max_num = temp\n        return max_num\n```", "extracted_code": "\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        max_num = \"\"\n        for i in range(len(number)):\n            if number[i] == digit:\n                temp = number[:i] + number[i+1:]\n                if int(temp) > int(max_num):\n                    max_num = temp\n        return max_num\n", "difficulty": 1.0}
{"task_id": "LeetCode/2248", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def intersection(self, nums: list[list[int]]) -> list[int]:\n        return sorted(list(set(nums[0]).intersection(*nums[1:])))\n```", "extracted_code": "\nclass Solution:\n    def intersection(self, nums: list[list[int]]) -> list[int]:\n        return sorted(list(set(nums[0]).intersection(*nums[1:])))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2215", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        set1, set2 = set(nums1), set(nums2)\n        return [list(set1 - set2), list(set2 - set1)]\n```", "extracted_code": "\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        set1, set2 = set(nums1), set(nums2)\n        return [list(set1 - set2), list(set2 - set1)]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2206", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(nums)\n        return all(val % 2 == 0 for val in count.values())\n```", "extracted_code": "\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(nums)\n        return all(val % 2 == 0 for val in count.values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/2160", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        num = str(num)\n        num = sorted(num)\n        new1 = new2 = ''\n        for i in range(4):\n            if i % 2 == 0:\n                new1 += num[i]\n            else:\n                new2 += num[i]\n        return int(new1) + int(new2)\n```", "extracted_code": "\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        num = str(num)\n        num = sorted(num)\n        new1 = new2 = ''\n        for i in range(4):\n            if i % 2 == 0:\n                new1 += num[i]\n            else:\n                new2 += num[i]\n        return int(new1) + int(new2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2148", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        min_elem, max_elem = min(nums), max(nums)\n        return sum(min_elem < num < max_elem for num in nums)\n```", "extracted_code": "\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        min_elem, max_elem = min(nums), max(nums)\n        return sum(min_elem < num < max_elem for num in nums)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2068", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        word1_counts = [0]*26\n        word2_counts = [0]*26\n\n        for i in range(len(word1)):\n            word1_counts[ord(word1[i])-ord('a')] += 1\n            word2_counts[ord(word2[i])-ord('a')] += 1\n\n        for i in range(26):\n            if abs(word1_counts[i] - word2_counts[i]) > 3:\n                return False\n\n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        word1_counts = [0]*26\n        word2_counts = [0]*26\n\n        for i in range(len(word1)):\n            word1_counts[ord(word1[i])-ord('a')] += 1\n            word2_counts[ord(word2[i])-ord('a')] += 1\n\n        for i in range(26):\n            if abs(word1_counts[i] - word2_counts[i]) > 3:\n                return False\n\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2053", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct = []\n        for word in arr:\n            if word not in distinct and arr.count(word) == 1:\n                distinct.append(word)\n        return distinct[k-1] if k <= len(distinct) else \"\"\n```", "extracted_code": "\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct = []\n        for word in arr:\n            if word not in distinct and arr.count(word) == 1:\n                distinct.append(word)\n        return distinct[k-1] if k <= len(distinct) else \"\"\n", "difficulty": 1.0}
{"task_id": "LeetCode/2032", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def twoOutOfThree(self, nums1: list[int], nums2: list[int], nums3: list[int]) -> list[int]:\n        return list(set([i for i in set(nums1) if i in nums2 or i in nums3] + [i for i in set(nums2) if i in nums3]))\n```", "extracted_code": "\nclass Solution:\n    def twoOutOfThree(self, nums1: list[int], nums2: list[int], nums3: list[int]) -> list[int]:\n        return list(set([i for i in set(nums1) if i in nums2 or i in nums3] + [i for i in set(nums2) if i in nums3]))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2027", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i] == 'X':\n                count += 1\n                i += 3\n            else:\n                i += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i] == 'X':\n                count += 1\n                i += 3\n            else:\n                i += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2006", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1995", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: list[int]) -> int:\n        count = 0\n        for a in range(len(nums)):\n            for b in range(a + 1, len(nums)):\n                for c in range(b + 1, len(nums)):\n                    for d in range(c + 1, len(nums)):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: list[int]) -> int:\n        count = 0\n        for a in range(len(nums)):\n            for b in range(a + 1, len(nums)):\n                for c in range(b + 1, len(nums)):\n                    for d in range(c + 1, len(nums)):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1974", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        prev, ans = 'a', 0\n        for c in word:\n            clockwise = abs(ord(c) - ord(prev))\n            counter_clockwise = 26 - clockwise\n            ans += min(clockwise, counter_clockwise) + 1\n            prev = c\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        prev, ans = 'a', 0\n        for c in word:\n            clockwise = abs(ord(c) - ord(prev))\n            counter_clockwise = 26 - clockwise\n            ans += min(clockwise, counter_clockwise) + 1\n            prev = c\n        return ans\n", "difficulty": 1.0}
{"task_id": "LeetCode/1971", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = set()\n        def dfs(node):\n            if node == destination:\n                return True\n            if node in visited:\n                return False\n            visited.add(node)\n            return any(dfs(neighbour) for neighbour in graph[node])\n        return dfs(source)\n```", "extracted_code": "\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = set()\n        def dfs(node):\n            if node == destination:\n                return True\n            if node in visited:\n                return False\n            visited.add(node)\n            return any(dfs(neighbour) for neighbour in graph[node])\n        return dfs(source)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1925", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a**2 + b**2)**0.5\n                if c <= n and c == int(c):\n                    count += 2 if a != b else 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a**2 + b**2)**0.5\n                if c <= n and c == int(c):\n                    count += 2 if a != b else 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1920", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n```", "extracted_code": "\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1886", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = [list(x)[::-1] for x in zip(*mat)]\n        return False\n```", "extracted_code": "\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = [list(x)[::-1] for x in zip(*mat)]\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1880", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def get_num(word):\n            return int(''.join(str(ord(c) - ord('a')) for c in word))\n        return get_num(firstWord) + get_num(secondWord) == get_num(targetWord)\n```\nThis function works by converting each character in a string to its corresponding letter value, concatenating these values, and then converting the resulting string to an integer. This is done for each of the three input strings. The function then checks if the sum of the numerical values of the first two strings is equal to the numerical value of the third string, returning True if it is and False if it is not.", "extracted_code": "\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def get_num(word):\n            return int(''.join(str(ord(c) - ord('a')) for c in word))\n        return get_num(firstWord) + get_num(secondWord) == get_num(targetWord)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1854", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumPopulation(self, logs: list[list[int]]) -> int:\n        years = [0]*101\n        for birth, death in logs:\n            years[birth - 1950] += 1\n            years[death - 1950] -= 1\n        max_population = max_year = years[0]\n        for i in range(1, 101):\n            years[i] += years[i - 1]\n            if years[i] > max_population:\n                max_population = years[i]\n                max_year = i\n        return max_year + 1950\n```", "extracted_code": "\nclass Solution:\n    def maximumPopulation(self, logs: list[list[int]]) -> int:\n        years = [0]*101\n        for birth, death in logs:\n            years[birth - 1950] += 1\n            years[death - 1950] -= 1\n        max_population = max_year = years[0]\n        for i in range(1, 101):\n            years[i] += years[i - 1]\n            if years[i] > max_population:\n                max_population = years[i]\n                max_year = i\n        return max_year + 1950\n", "difficulty": 1.0}
{"task_id": "LeetCode/1837", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        newBase = ''\n        while n:\n            n, r = divmod(n, k)\n            newBase = str(r) + newBase\n        return sum(int(digit) for digit in newBase)\n```", "extracted_code": "\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        newBase = ''\n        while n:\n            n, r = divmod(n, k)\n            newBase = str(r) + newBase\n        return sum(int(digit) for digit in newBase)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1800", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = curr_sum = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i-1] < nums[i]:\n                curr_sum += nums[i]\n            else:\n                curr_sum = nums[i]\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = curr_sum = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i-1] < nums[i]:\n                curr_sum += nums[i]\n            else:\n                curr_sum = nums[i]\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n", "difficulty": 1.0}
{"task_id": "LeetCode/1768", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = [None]*(len(word1)+len(word2))\n        merged[::2] = word1\n        merged[1::2] = word2\n        return ''.join(merged)\n```", "extracted_code": "\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = [None]*(len(word1)+len(word2))\n        merged[::2] = word1\n        merged[1::2] = word2\n        return ''.join(merged)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1758", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        s1 = s2 = 0\n        for i in range(len(s)):\n            if i % 2 == int(s[i]):\n                s1 += 1\n            else:\n                s2 += 1\n        return min(s1, s2)\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        s1 = s2 = 0\n        for i in range(len(s)):\n            if i % 2 == int(s[i]):\n                s1 += 1\n            else:\n                s2 += 1\n        return min(s1, s2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1748", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(i for i in nums if nums.count(i) == 1)\n```", "extracted_code": "\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        return sum(i for i in nums if nums.count(i) == 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1656", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass OrderedStream:\n    def __init__(self, n: int):\n        self.ptr = 0\n        self.arr = [None]*n\n\n    def insert(self, idKey: int, value: str) -> list[str]:\n        idKey -= 1\n        self.arr[idKey] = value\n        if idKey > self.ptr:\n            return []\n        while self.ptr < len(self.arr) and self.arr[self.ptr] is not None:\n            self.ptr += 1\n        return self.arr[idKey:self.ptr]\n```", "extracted_code": "\nclass OrderedStream:\n    def __init__(self, n: int):\n        self.ptr = 0\n        self.arr = [None]*n\n\n    def insert(self, idKey: int, value: str) -> list[str]:\n        idKey -= 1\n        self.arr[idKey] = value\n        if idKey > self.ptr:\n            return []\n        while self.ptr < len(self.arr) and self.arr[self.ptr] is not None:\n            self.ptr += 1\n        return self.arr[idKey:self.ptr]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1640", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def canFormArray(self, arr, pieces):\n        mp = {x[0]: x for x in pieces}\n        res = []\n        for num in arr:\n            res += mp.get(num, [])\n        return res == arr\n```", "extracted_code": "\nclass Solution:\n    def canFormArray(self, arr, pieces):\n        mp = {x[0]: x for x in pieces}\n        res = []\n        for num in arr:\n            res += mp.get(num, [])\n        return res == arr\n", "difficulty": 1.0}
{"task_id": "LeetCode/1619", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        k = int(n * 0.05)\n        return sum(arr[k:n-k]) / (n-2*k)\n```", "extracted_code": "\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        k = int(n * 0.05)\n        return sum(arr[k:n-k]) / (n-2*k)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1614", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        max_depth = 0\n        current_depth = 0\n\n        for char in s:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n\n        return max_depth\n```", "extracted_code": "\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        max_depth = 0\n        current_depth = 0\n\n        for char in s:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n\n        return max_depth\n", "difficulty": 1.0}
{"task_id": "LeetCode/1582", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        rowSum = [sum(row) for row in mat]\n        colSum = [sum(col) for col in zip(*mat)]\n        return sum(rowSum[i] == colSum[j] == 1 for i, row in enumerate(mat) for j, val in enumerate(row) if val)\n```", "extracted_code": "\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        rowSum = [sum(row) for row in mat]\n        colSum = [sum(col) for col in zip(*mat)]\n        return sum(rowSum[i] == colSum[j] == 1 for i, row in enumerate(mat) for j, val in enumerate(row) if val)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1566", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        n = len(arr)\n        for i in range(n - m * k + 1):\n            if arr[i:i + m * k] == arr[i:i + m] * k:\n                return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        n = len(arr)\n        for i in range(n - m * k + 1):\n            if arr[i:i + m * k] == arr[i:i + m] * k:\n                return True\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1556", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        return '{:,}'.format(n).replace(',', '.')\n```", "extracted_code": "\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        return '{:,}'.format(n).replace(',', '.')\n", "difficulty": 1.0}
{"task_id": "LeetCode/1534", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if abs(arr[i] - arr[j]) <= a:\n                    for k in range(j + 1, len(arr)):\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if abs(arr[i] - arr[j]) <= a:\n                    for k in range(j + 1, len(arr)):\n                        if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                            count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1496", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y = 0, 0\n        visited = {(x, y)}\n        for move in path:\n            if move == 'N':\n                y += 1\n            elif move == 'S':\n                y -= 1\n            elif move == 'E':\n                x += 1\n            elif move == 'W':\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y = 0, 0\n        visited = {(x, y)}\n        for move in path:\n            if move == 'N':\n                y += 1\n            elif move == 'S':\n                y -= 1\n            elif move == 'E':\n                x += 1\n            elif move == 'W':\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1486", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n```", "extracted_code": "\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1464", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums.sort()\n        return (nums[-1] - 1) * (nums[-2] - 1)\n```\nThis function sorts the list in ascending order and picks the last two elements (which are the two largest numbers in the list), subtracts 1 from each of them, and multiplies the results to get the maximum product. The time complexity of the function is O(n log n) due to the sort operation.", "extracted_code": "\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums.sort()\n        return (nums[-1] - 1) * (nums[-2] - 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1431", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kidsWithCandies(self, candies: list[int], extraCandies: int) -> list[bool]:\n        max_candies = max(candies)\n        return [candy + extraCandies >= max_candies for candy in candies]\n```", "extracted_code": "\nclass Solution:\n    def kidsWithCandies(self, candies: list[int], extraCandies: int) -> list[bool]:\n        max_candies = max(candies)\n        return [candy + extraCandies >= max_candies for candy in candies]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1422", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        total_ones = s.count('1')\n        left_zeros = 0\n        max_score = 0\n        for i in range(len(s)-1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                total_ones -= 1\n            max_score = max(max_score, left_zeros + total_ones)\n        return max_score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        total_ones = s.count('1')\n        left_zeros = 0\n        max_score = 0\n        for i in range(len(s)-1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                total_ones -= 1\n            max_score = max(max_score, left_zeros + total_ones)\n        return max_score\n", "difficulty": 1.0}
{"task_id": "LeetCode/1408", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def stringMatching(self, words):\n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and words[i] in words[j]:\n                    res.append(words[i])\n                    break\n        return res\n```", "extracted_code": "\nclass Solution:\n    def stringMatching(self, words):\n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and words[i] in words[j]:\n                    res.append(words[i])\n                    break\n        return res\n", "difficulty": 1.0}
{"task_id": "LeetCode/1399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        from collections import defaultdict\n        groups = defaultdict(list)\n\n        for i in range(1, n+1):\n            key = sum(int(digit) for digit in str(i))\n            groups[key].append(i)\n\n        largest_group_size = max(len(group) for group in groups.values())\n        return sum(1 for group in groups.values() if len(group) == largest_group_size)\n```", "extracted_code": "\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        from collections import defaultdict\n        groups = defaultdict(list)\n\n        for i in range(1, n+1):\n            key = sum(int(digit) for digit in str(i))\n            groups[key].append(i)\n\n        largest_group_size = max(len(group) for group in groups.values())\n        return sum(1 for group in groups.values() if len(group) == largest_group_size)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1360", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        d1 = datetime.strptime(date1, '%Y-%m-%d')\n        d2 = datetime.strptime(date2, '%Y-%m-%d')\n        return abs((d2 - d1).days)\n```", "extracted_code": "\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        d1 = datetime.strptime(date1, '%Y-%m-%d')\n        d2 = datetime.strptime(date2, '%Y-%m-%d')\n        return abs((d2 - d1).days)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1323", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num = list(str(num))\n        for i in range(len(num)):\n            if num[i] == '6':\n                num[i] = '9'\n                break\n        return int(''.join(num))\n```", "extracted_code": "\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num = list(str(num))\n        for i in range(len(num)):\n            if num[i] == '6':\n                num[i] = '9'\n                break\n        return int(''.join(num))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1304", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumZero(self, n: int) -> list[int]:\n        return list(range(1-n, n, 2))\n```", "extracted_code": "\nclass Solution:\n    def sumZero(self, n: int) -> list[int]:\n        return list(range(1-n, n, 2))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1266", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        return sum(max(abs(points[i][0] - points[i - 1][0]), abs(points[i][1] - points[i - 1][1])) for i in range(1, len(points)))\n```", "extracted_code": "\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        return sum(max(abs(points[i][0] - points[i - 1][0]), abs(points[i][1] - points[i - 1][1])) for i in range(1, len(points)))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1252", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        row = [0] * m\n        col = [0] * n\n        for r, c in indices:\n            row[r] ^= 1\n            col[c] ^= 1\n        return sum((row[i] + col[j]) % 2 for i in range(m) for j in range(n))\n```", "extracted_code": "\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        row = [0] * m\n        col = [0] * n\n        for r, c in indices:\n            row[r] ^= 1\n            col[c] ^= 1\n        return sum((row[i] + col[j]) % 2 for i in range(m) for j in range(n))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1207", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(arr)\n        occurences = list(count.values())\n        return len(occurences) == len(set(occurences))\n```", "extracted_code": "\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        from collections import Counter\n        count = Counter(arr)\n        occurences = list(count.values())\n        return len(occurences) == len(set(occurences))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1200", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumAbsDifference(self, arr):\n        arr.sort()\n        min_diff = min(b - a for a, b in zip(arr, arr[1:]))\n        return [[a, b] for a, b in zip(arr, arr[1:]) if b - a == min_diff]\n```", "extracted_code": "\nclass Solution:\n    def minimumAbsDifference(self, arr):\n        arr.sort()\n        min_diff = min(b - a for a, b in zip(arr, arr[1:]))\n        return [[a, b] for a, b in zip(arr, arr[1:]) if b - a == min_diff]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1175", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        def factorial(n):\n            result = 1\n            for i in range(1, n + 1):\n                result = (result * i) % (10**9 + 7)\n            return result\n\n        primes = [2]\n        for i in range(3, n + 1, 2):\n            for p in primes:\n                if p * p > i:\n                    primes.append(i)\n                    break\n                if i % p == 0:\n                    break\n        return (factorial(len(primes)) * factorial(n - len(primes))) % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        def factorial(n):\n            result = 1\n            for i in range(1, n + 1):\n                result = (result * i) % (10**9 + 7)\n            return result\n\n        primes = [2]\n        for i in range(3, n + 1, 2):\n            for p in primes:\n                if p * p > i:\n                    primes.append(i)\n                    break\n                if i % p == 0:\n                    break\n        return (factorial(len(primes)) * factorial(n - len(primes))) % (10**9 + 7)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1128", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: list[list[int]]) -> int:\n        from collections import defaultdict\n        from itertools import combinations\n        d = defaultdict(int)\n        for domino in dominoes:\n            d[tuple(sorted(domino))] += 1\n        return sum(len(list(combinations([1]*v, 2))) for v in d.values())\n```", "extracted_code": "\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: list[list[int]]) -> int:\n        from collections import defaultdict\n        from itertools import combinations\n        d = defaultdict(int)\n        for domino in dominoes:\n            d[tuple(sorted(domino))] += 1\n        return sum(len(list(combinations([1]*v, 2))) for v in d.values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/1108", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n```", "extracted_code": "\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n", "difficulty": 1.0}
{"task_id": "LeetCode/1103", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> list[int]:\n        res = [0] * num_people\n        i = 0\n        while candies > 0:\n            res[i % num_people] += min(candies, i + 1)\n            candies -= min(candies, i + 1)\n            i += 1\n        return res\n```", "extracted_code": "\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> list[int]:\n        res = [0] * num_people\n        i = 0\n        while candies > 0:\n            res[i % num_people] += min(candies, i + 1)\n            candies -= min(candies, i + 1)\n            i += 1\n        return res\n", "difficulty": 1.0}
{"task_id": "LeetCode/1071", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            return self.gcdOfStrings(str2, str1)\n        elif str1[:len(str2)] == str2:\n            if str1[len(str2):] == '':\n                return str2\n            else:\n                return self.gcdOfStrings(str1[len(str2):], str2)\n        else:\n            return ''\n```", "extracted_code": "\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            return self.gcdOfStrings(str2, str1)\n        elif str1[:len(str2)] == str2:\n            if str1[len(str2):] == '':\n                return str2\n            else:\n                return self.gcdOfStrings(str1[len(str2):], str2)\n        else:\n            return ''\n", "difficulty": 1.0}
{"task_id": "LeetCode/1025", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        return n % 2 == 0\n```\nIn the divisor game, Alice always starts first. If the number is even, Alice can always choose 1, making the number odd for Bob's turn. Since Bob can only choose numbers that are factors of the current number (which is odd), Bob can only choose 1, making the number even again for Alice's turn. This cycle continues until the number is 1, at which point Bob cannot make a move and loses. Therefore, if the starting number is even, Alice will always win. If the starting number is odd, Alice will always lose.", "extracted_code": "\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        return n % 2 == 0\n", "difficulty": 1.0}
{"task_id": "LeetCode/1009", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        return int(''.join('0' if bit == '1' else '1' for bit in bin(n)[2:]), 2)\n```", "extracted_code": "\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        return int(''.join('0' if bit == '1' else '1' for bit in bin(n)[2:]), 2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/993", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isCousins(self, root, x, y):\n        def dfs(node, parent, depth, val):\n            if node is None:\n                return False\n            if node.val == val:\n                return depth, parent\n            return dfs(node.left, node, depth + 1, val) or dfs(node.right, node, depth + 1, val)\n        dx, px, dy, py = dfs(root, None, 0, x) + dfs(root, None, 0, y)\n        return dx == dy and px != py\n```", "extracted_code": "\nclass Solution:\n    def isCousins(self, root, x, y):\n        def dfs(node, parent, depth, val):\n            if node is None:\n                return False\n            if node.val == val:\n                return depth, parent\n            return dfs(node.left, node, depth + 1, val) or dfs(node.right, node, depth + 1, val)\n        dx, px, dy, py = dfs(root, None, 0, x) + dfs(root, None, 0, y)\n        return dx == dy and px != py\n", "difficulty": 1.0}
{"task_id": "LeetCode/2512", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        scores = {id: 0 for id in student_id}\n        for feedback, id in zip(report, student_id):\n            for word in feedback.split():\n                if word in positive_feedback:\n                    scores[id] += 3\n                elif word in negative_feedback:\n                    scores[id] -= 1\n        return sorted(scores, key=lambda x: (-scores[x], x))[:k]\n```", "extracted_code": "\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        scores = {id: 0 for id in student_id}\n        for feedback, id in zip(report, student_id):\n            for word in feedback.split():\n                if word in positive_feedback:\n                    scores[id] += 3\n                elif word in negative_feedback:\n                    scores[id] -= 1\n        return sorted(scores, key=lambda x: (-scores[x], x))[:k]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2478", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        cum = [0] * (n + 1)\n        dp[0] = cum[0] = 1\n        primes = set('2357')\n        for i in range(1, n + 1):\n            l = max(0, i - minLength)\n            if s[i - 1] not in primes:\n                dp[i] = cum[l] if l >= 0 else 0\n            if s[i - minLength] in primes:\n                dp[i] -= cum[l - 1] if l - 1 >= 0 else 0\n            dp[i] %= MOD\n            cum[i] = (cum[i - 1] + dp[i]) % MOD\n        return sum(dp[n - i * minLength:n - (i - 1) * minLength] for i in range(1, k + 1)) % MOD\n```", "extracted_code": "\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        cum = [0] * (n + 1)\n        dp[0] = cum[0] = 1\n        primes = set('2357')\n        for i in range(1, n + 1):\n            l = max(0, i - minLength)\n            if s[i - 1] not in primes:\n                dp[i] = cum[l] if l >= 0 else 0\n            if s[i - minLength] in primes:\n                dp[i] -= cum[l - 1] if l - 1 >= 0 else 0\n            dp[i] %= MOD\n            cum[i] = (cum[i - 1] + dp[i]) % MOD\n        return sum(dp[n - i * minLength:n - (i - 1) * minLength] for i in range(1, k + 1)) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2472", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        is_palindrome = [[0]*n for _ in range(n)]\n\n        for i in range(n-1, -1, -1):\n            dp[i][i] = 1\n            is_palindrome[i][i] = 1\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    if j - i == 1 or is_palindrome[i+1][j-1]:\n                        is_palindrome[i][j] = 1\n                        dp[i][j] = dp[i+1][j-1] + 2\n                    else:\n                        dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\n        max_palindromes = 0\n        for i in range(n):\n            for j in range(i+k-1, n):\n                if is_palindrome[i][j]:\n                    max_palindromes += 1\n\n        return max_palindromes\n```", "extracted_code": "\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[0]*n for _ in range(n)]\n        is_palindrome = [[0]*n for _ in range(n)]\n\n        for i in range(n-1, -1, -1):\n            dp[i][i] = 1\n            is_palindrome[i][i] = 1\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    if j - i == 1 or is_palindrome[i+1][j-1]:\n                        is_palindrome[i][j] = 1\n                        dp[i][j] = dp[i+1][j-1] + 2\n                    else:\n                        dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\n        max_palindromes = 0\n        for i in range(n):\n            for j in range(i+k-1, n):\n                if is_palindrome[i][j]:\n                    max_palindromes += 1\n\n        return max_palindromes\n", "difficulty": 3.0}
{"task_id": "LeetCode/2468", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> list[str]:\n        n = len(message)\n        suffix_len = len(\"<1/1>\")\n        if limit < suffix_len: return []\n        \n        parts = (n + limit - suffix_len - 1) // (limit - suffix_len)\n        if parts > 10: suffix_len += 1\n        if parts > 100: suffix_len += 1\n        if parts > 1000: suffix_len += 1\n        if limit < suffix_len: return []\n        \n        if (limit - suffix_len) * parts < n: return []\n        \n        res = []\n        for i in range(parts):\n            start = i * (limit - suffix_len)\n            end = min((i+1) * (limit - suffix_len), n)\n            part = message[start:end] + \"<{}/{}>\".format(i+1, parts)\n            res.append(part)\n        return res\n```", "extracted_code": "\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> list[str]:\n        n = len(message)\n        suffix_len = len(\"<1/1>\")\n        if limit < suffix_len: return []\n        \n        parts = (n + limit - suffix_len - 1) // (limit - suffix_len)\n        if parts > 10: suffix_len += 1\n        if parts > 100: suffix_len += 1\n        if parts > 1000: suffix_len += 1\n        if limit < suffix_len: return []\n        \n        if (limit - suffix_len) * parts < n: return []\n        \n        res = []\n        for i in range(parts):\n            start = i * (limit - suffix_len)\n            end = min((i+1) * (limit - suffix_len), n)\n            part = message[start:end] + \"<{}/{}>\".format(i+1, parts)\n            res.append(part)\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2463", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort(key = lambda x: x[0])\n        heap = []\n        total, j = 0, 0\n        for i in range(len(factory)):\n            while j < len(robot) and robot[j] <= factory[i][0]:\n                heapq.heappush(heap, -robot[j])\n                j += 1\n            while len(heap) > factory[i][1]:\n                total += factory[i][0] + heapq.heappop(heap)\n        while heap:\n            total += robot[-1] + heapq.heappop(heap)\n        return total\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort(key = lambda x: x[0])\n        heap = []\n        total, j = 0, 0\n        for i in range(len(factory)):\n            while j < len(robot) and robot[j] <= factory[i][0]:\n                heapq.heappush(heap, -robot[j])\n                j += 1\n            while len(heap) > factory[i][1]:\n                total += factory[i][0] + heapq.heappop(heap)\n        while heap:\n            total += robot[-1] + heapq.heappop(heap)\n        return total\n", "difficulty": 3.0}
{"task_id": "LeetCode/2458", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        nodes = [None] * 100001\n        depth = [0] * 100001\n        answer = []\n        \n        def dfs(node, d):\n            nodes[node.val] = node\n            depth[node.val] = d\n            if node.left:\n                dfs(node.left, d + 1)\n            if node.right:\n                dfs(node.right, d + 1)\n        \n        def getHeight(node):\n            if not node:\n                return 0\n            left = getHeight(node.left)\n            right = getHeight(node.right)\n            return max(left, right) + 1\n\n        dfs(root, 1)\n        \n        for query in queries:\n            nodes[query].left = None\n            nodes[query].right = None\n            answer.append(getHeight(root) - 1)\n        \n        return answer\n```", "extracted_code": "\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        nodes = [None] * 100001\n        depth = [0] * 100001\n        answer = []\n        \n        def dfs(node, d):\n            nodes[node.val] = node\n            depth[node.val] = d\n            if node.left:\n                dfs(node.left, d + 1)\n            if node.right:\n                dfs(node.right, d + 1)\n        \n        def getHeight(node):\n            if not node:\n                return 0\n            left = getHeight(node.left)\n            right = getHeight(node.right)\n            return max(left, right) + 1\n\n        dfs(root, 1)\n        \n        for query in queries:\n            nodes[query].left = None\n            nodes[query].right = None\n            answer.append(getHeight(root) - 1)\n        \n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2454", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def secondGreaterElement(self, nums):\n        n = len(nums)\n        next_greater = [-1]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] < nums[i]:\n                next_greater[stack.pop()] = nums[i]\n            stack.append(i)\n        for i in range(n):\n            if next_greater[i] != -1:\n                j = i+1\n                while j < n and nums[j] <= next_greater[i]:\n                    j += 1\n                if j < n:\n                    next_greater[i] = nums[j]\n                else:\n                    next_greater[i] = -1\n        return next_greater\n```", "extracted_code": "\nclass Solution:\n    def secondGreaterElement(self, nums):\n        n = len(nums)\n        next_greater = [-1]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] < nums[i]:\n                next_greater[stack.pop()] = nums[i]\n            stack.append(i)\n        for i in range(n):\n            if next_greater[i] != -1:\n                j = i+1\n                while j < n and nums[j] <= next_greater[i]:\n                    j += 1\n                if j < n:\n                    next_greater[i] = nums[j]\n                else:\n                    next_greater[i] = -1\n        return next_greater\n", "difficulty": 3.0}
{"task_id": "LeetCode/2385", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        graph = collections.defaultdict(list)\n        queue = collections.deque([(root, 0)])\n        while queue:\n            node, parent = queue.popleft()\n            graph[node.val].append(parent)\n            graph[parent].append(node.val)\n            if node.left:\n                queue.append((node.left, node.val))\n            if node.right:\n                queue.append((node.right, node.val))\n\n        seen = {start}\n        queue = collections.deque([(start, 0)])\n        while queue:\n            node, minutes = queue.popleft()\n            for neighbour in graph[node]:\n                if neighbour not in seen:\n                    seen.add(neighbour)\n                    queue.append((neighbour, minutes+1))\n        return minutes\n```", "extracted_code": "\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        graph = collections.defaultdict(list)\n        queue = collections.deque([(root, 0)])\n        while queue:\n            node, parent = queue.popleft()\n            graph[node.val].append(parent)\n            graph[parent].append(node.val)\n            if node.left:\n                queue.append((node.left, node.val))\n            if node.right:\n                queue.append((node.right, node.val))\n\n        seen = {start}\n        queue = collections.deque([(start, 0)])\n        while queue:\n            node, minutes = queue.popleft()\n            for neighbour in graph[node]:\n                if neighbour not in seen:\n                    seen.add(neighbour)\n                    queue.append((neighbour, minutes+1))\n        return minutes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2368", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u,v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0]*n\n        for node in restricted:\n            visited[node] = 1\n\n        def dfs(node):\n            if visited[node]: return 0\n            visited[node] = 1\n            return 1 + sum(dfs(nei) for nei in graph[node])\n        \n        return dfs(0)\n```", "extracted_code": "\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for u,v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0]*n\n        for node in restricted:\n            visited[node] = 1\n\n        def dfs(node):\n            if visited[node]: return 0\n            visited[node] = 1\n            return 1 + sum(dfs(nei) for nei in graph[node])\n        \n        return dfs(0)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2359", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        dist = [[float('inf')] * n for _ in range(2)]\n        dist[0][node1] = dist[1][node2] = 0\n        queue = [(node1, 0), (node2, 1)]\n        for node, idx in queue:\n            for next_node in [edges[node], node]:\n                if next_node != -1 and dist[idx][node] + 1 < dist[idx][next_node]:\n                    dist[idx][next_node] = dist[idx][node] + 1\n                    queue.append((next_node, idx))\n        min_dist, min_node = min(max(dist[0][i], dist[1][i]) for i in range(n)), -1\n        for i in range(n):\n            if max(dist[0][i], dist[1][i]) == min_dist:\n                return i\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        dist = [[float('inf')] * n for _ in range(2)]\n        dist[0][node1] = dist[1][node2] = 0\n        queue = [(node1, 0), (node2, 1)]\n        for node, idx in queue:\n            for next_node in [edges[node], node]:\n                if next_node != -1 and dist[idx][node] + 1 < dist[idx][next_node]:\n                    dist[idx][next_node] = dist[idx][node] + 1\n                    queue.append((next_node, idx))\n        min_dist, min_node = min(max(dist[0][i], dist[1][i]) for i in range(n)), -1\n        for i in range(n):\n            if max(dist[0][i], dist[1][i]) == min_dist:\n                return i\n        return -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2353", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nfrom collections import defaultdict\nfrom bisect import insort\n\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.foods = {food: (rating, i) for i, (food, rating) in enumerate(zip(foods, ratings))}\n        self.cuisines = defaultdict(list)\n        for food, cuisine in zip(foods, cuisines):\n            insort(self.cuisines[cuisine], (-self.foods[food][0], self.foods[food][1], food))\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        oldRating, index = self.foods[food]\n        self.foods[food] = (newRating, index)\n        for cuisine in self.cuisines:\n            if food in (item[2] for item in self.cuisines[cuisine]):\n                self.cuisines[cuisine].remove((oldRating, index, food))\n                insort(self.cuisines[cuisine], (-newRating, index, food))\n\n    def highestRated(self, cuisine: str) -> str:\n        return self.cuisines[cuisine][0][2]\n```\nThe above Python code snippet defines the FoodRatings class. The class has three methods, the __init__ method initializes the class with foods, cuisines and ratings as parameters. The changeRating method changes the rating of a specific food and the highestRated method returns the name of the highest rated food for a specific cuisine. The insort function from the bisect module is used to keep the list of foods for each cuisine sorted according to their ratings in descending order and their names in lexicographically ascending order. When the rating of a food is changed, it is removed from the list and reinserted in the correct position. The highestRated method returns the first food in the list for the cuisine, which has the highest rating.", "extracted_code": "\nfrom typing import List\nfrom collections import defaultdict\nfrom bisect import insort\n\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.foods = {food: (rating, i) for i, (food, rating) in enumerate(zip(foods, ratings))}\n        self.cuisines = defaultdict(list)\n        for food, cuisine in zip(foods, cuisines):\n            insort(self.cuisines[cuisine], (-self.foods[food][0], self.foods[food][1], food))\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        oldRating, index = self.foods[food]\n        self.foods[food] = (newRating, index)\n        for cuisine in self.cuisines:\n            if food in (item[2] for item in self.cuisines[cuisine]):\n                self.cuisines[cuisine].remove((oldRating, index, food))\n                insort(self.cuisines[cuisine], (-newRating, index, food))\n\n    def highestRated(self, cuisine: str) -> str:\n        return self.cuisines[cuisine][0][2]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2349", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass NumberContainers:\n\n    def __init__(self):\n        self.container = {}\n        self.indices = {}\n\n    def change(self, index: int, number: int) -> None:\n        if index in self.indices and self.indices[index] != number:\n            old_number = self.indices[index]\n            self.container[old_number].remove(index)\n\n        self.indices[index] = number\n        if number not in self.container:\n            self.container[number] = set()\n        self.container[number].add(index)\n\n    def find(self, number: int) -> int:\n        if number not in self.container or len(self.container[number]) == 0:\n            return -1\n        return min(self.container[number])\n```", "extracted_code": "\nclass NumberContainers:\n\n    def __init__(self):\n        self.container = {}\n        self.indices = {}\n\n    def change(self, index: int, number: int) -> None:\n        if index in self.indices and self.indices[index] != number:\n            old_number = self.indices[index]\n            self.container[old_number].remove(index)\n\n        self.indices[index] = number\n        if number not in self.container:\n            self.container[number] = set()\n        self.container[number].add(index)\n\n    def find(self, number: int) -> int:\n        if number not in self.container or len(self.container[number]) == 0:\n            return -1\n        return min(self.container[number])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2343", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        answer = []\n        for k, trim in queries:\n            trimmed_nums = [(num[-trim:], i) for i, num in enumerate(nums)]\n            trimmed_nums.sort()\n            answer.append(trimmed_nums[k-1][1])\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        answer = []\n        for k, trim in queries:\n            trimmed_nums = [(num[-trim:], i) for i, num in enumerate(nums)]\n            trimmed_nums.sort()\n            answer.append(trimmed_nums[k-1][1])\n        return answer\n", "difficulty": 2.0}
{"task_id": "LeetCode/2342", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        sums = [-1] * 100\n        for num in nums:\n            digits_sum = sum(int(d) for d in str(num))\n            sums[digits_sum] = max(sums[digits_sum], num if sums[digits_sum] == -1 else sums[digits_sum] + num)\n        return max(sums)\n```", "extracted_code": "\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        sums = [-1] * 100\n        for num in nums:\n            digits_sum = sum(int(d) for d in str(num))\n            sums[digits_sum] = max(sums[digits_sum], num if sums[digits_sum] == -1 else sums[digits_sum] + num)\n        return max(sums)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2333", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\n        differences = [abs(x - y) for x, y in zip(nums1, nums2)]\n        differences.sort(reverse=True)\n        \n        for i in range(k1):\n            if differences[0] == 0:\n                break\n            differences[0] -= 1\n            differences.sort(reverse=True)\n        \n        for i in range(k2):\n            if differences[0] == 0:\n                break\n            differences[0] -= 1\n            differences.sort(reverse=True)\n        \n        return sum(x ** 2 for x in differences)\n```", "extracted_code": "\nclass Solution:\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\n        differences = [abs(x - y) for x, y in zip(nums1, nums2)]\n        differences.sort(reverse=True)\n        \n        for i in range(k1):\n            if differences[0] == 0:\n                break\n            differences[0] -= 1\n            differences.sort(reverse=True)\n        \n        for i in range(k2):\n            if differences[0] == 0:\n                break\n            differences[0] -= 1\n            differences.sort(reverse=True)\n        \n        return sum(x ** 2 for x in differences)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2320", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 4\n        dp[2] = 9\n        for i in range(3, n+1):\n            dp[i] = (2*dp[i-1]%MOD + dp[i-2]%MOD) % MOD\n        return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 4\n        dp[2] = 9\n        for i in range(3, n+1):\n            dp[i] = (2*dp[i-1]%MOD + dp[i-2]%MOD) % MOD\n        return dp[n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2317", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumXOR(self, nums):\n        maxX = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask = mask | (1 << i)\n            prefixSet = set()\n            for num in nums:\n                prefixSet.add(num & mask)\n            newMax = maxX | (1 << i)\n            for prefix in prefixSet:\n                if newMax ^ prefix in prefixSet:\n                    maxX = newMax\n                    break\n        return maxX\n```", "extracted_code": "\nclass Solution:\n    def maximumXOR(self, nums):\n        maxX = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask = mask | (1 << i)\n            prefixSet = set()\n            for num in nums:\n                prefixSet.add(num & mask)\n            newMax = maxX | (1 << i)\n            for prefix in prefixSet:\n                if newMax ^ prefix in prefixSet:\n                    maxX = newMax\n                    break\n        return maxX\n", "difficulty": 2.0}
{"task_id": "LeetCode/2294", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        subsequences = [nums[0]]\n        for num in nums[1:]:\n            for i, sub in enumerate(subsequences):\n                if num - sub <= k:\n                    subsequences[i] = num\n                    break\n            else:\n                subsequences.append(num)\n        return len(subsequences)\n```", "extracted_code": "\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        subsequences = [nums[0]]\n        for num in nums[1:]:\n            for i, sub in enumerate(subsequences):\n                if num - sub <= k:\n                    subsequences[i] = num\n                    break\n            else:\n                subsequences.append(num)\n        return len(subsequences)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2284", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n        sender_word_count = {}\n        for sender, message in zip(senders, messages):\n            word_count = len(message.split())\n            if sender in sender_word_count:\n                sender_word_count[sender] += word_count\n            else:\n                sender_word_count[sender] = word_count\n        max_word_count = max(sender_word_count.values())\n        largest_senders = [sender for sender, word_count in sender_word_count.items() if word_count == max_word_count]\n        return max(largest_senders)\n```", "extracted_code": "\nclass Solution:\n    def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n        sender_word_count = {}\n        for sender, message in zip(senders, messages):\n            word_count = len(message.split())\n            if sender in sender_word_count:\n                sender_word_count[sender] += word_count\n            else:\n                sender_word_count[sender] = word_count\n        max_word_count = max(sender_word_count.values())\n        largest_senders = [sender for sender, word_count in sender_word_count.items() if word_count == max_word_count]\n        return max(largest_senders)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2279", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        import heapq\n        bag_diff = [-1*(capacity[i] - rocks[i]) for i in range(len(capacity))]\n        heapq.heapify(bag_diff)\n        while additionalRocks > 0 and bag_diff:\n            diff = -1*heapq.heappop(bag_diff)\n            if diff <= additionalRocks:\n                additionalRocks -= diff\n            else:\n                break\n        return len(capacity) - len(bag_diff)\n```", "extracted_code": "\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        import heapq\n        bag_diff = [-1*(capacity[i] - rocks[i]) for i in range(len(capacity))]\n        heapq.heapify(bag_diff)\n        while additionalRocks > 0 and bag_diff:\n            diff = -1*heapq.heappop(bag_diff)\n            if diff <= additionalRocks:\n                additionalRocks -= diff\n            else:\n                break\n        return len(capacity) - len(bag_diff)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2275", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestCombination(self, candidates):\n        candidates.sort(reverse=True)\n        max_length = 0\n        for i in range(len(candidates)):\n            j = i\n            while j < len(candidates) and candidates[i] & candidates[j] > 0:\n                j += 1\n            max_length = max(max_length, j - i)\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def largestCombination(self, candidates):\n        candidates.sort(reverse=True)\n        max_length = 0\n        for i in range(len(candidates)):\n            j = i\n            while j < len(candidates) and candidates[i] & candidates[j] > 0:\n                j += 1\n            max_length = max(max_length, j - i)\n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2271", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort()\n        ranges = [[l, r, r - l + 1] for l, r in tiles]\n        for i in range(1, len(ranges)):\n            if ranges[i][0] - ranges[i - 1][1] <= carpetLen:\n                ranges[i][2] = max(ranges[i - 1][2] + min(carpetLen, ranges[i][1] - ranges[i - 1][1] + 1), ranges[i][2])\n        \n        return max(x[2] for x in ranges)\n```", "extracted_code": "\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort()\n        ranges = [[l, r, r - l + 1] for l, r in tiles]\n        for i in range(1, len(ranges)):\n            if ranges[i][0] - ranges[i - 1][1] <= carpetLen:\n                ranges[i][2] = max(ranges[i - 1][2] + min(carpetLen, ranges[i][1] - ranges[i - 1][1] + 1), ranges[i][2])\n        \n        return max(x[2] for x in ranges)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2270", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        prefix_sum = nums[:]\n        for i in range(1, len(nums)):\n            prefix_sum[i] += prefix_sum[i - 1]\n        total_sum = prefix_sum[-1]\n        result = 0\n        j = 0\n        for i in range(len(nums) - 2, -1, -1):\n            while prefix_sum[i] > total_sum - prefix_sum[i]:\n                total_sum -= nums[i + 1]\n            while j < i and prefix_sum[j] * 2 <= prefix_sum[i]:\n                j += 1\n            result += i - j\n        return result\n```", "extracted_code": "\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        prefix_sum = nums[:]\n        for i in range(1, len(nums)):\n            prefix_sum[i] += prefix_sum[i - 1]\n        total_sum = prefix_sum[-1]\n        result = 0\n        j = 0\n        for i in range(len(nums) - 2, -1, -1):\n            while prefix_sum[i] > total_sum - prefix_sum[i]:\n                total_sum -= nums[i + 1]\n            while j < i and prefix_sum[j] * 2 <= prefix_sum[i]:\n                j += 1\n            result += i - j\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2245", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        def count_factors(n, f):\n            count = 0\n            while n % f == 0:\n                n //= f\n                count += 1\n            return count\n\n        m, n = len(grid), len(grid[0])\n        dp = [[[[-1, -1] for _ in range(n)] for _ in range(m)] for _ in range(2)]\n        dp[0][0][0][0] = dp[1][0][0][0] = min(count_factors(grid[0][0], 2), count_factors(grid[0][0], 5))\n\n        for i in range(m):\n            for j in range(n):\n                for k in range(2):\n                    if i + j == 0:\n                        continue\n                    if i > 0:\n                        dp[k][i][j][0] = max(dp[k][i][j][0], dp[k][i-1][j][0] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n                        if k > 0:\n                            dp[k][i][j][0] = max(dp[k][i][j][0], dp[k-1][i-1][j][1] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n                    if j > 0:\n                        dp[k][i][j][1] = max(dp[k][i][j][1], dp[k][i][j-1][1] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n                        if k > 0:\n                            dp[k][i][j][1] = max(dp[k][i][j][1], dp[k-1][i][j-1][0] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n        \n        return max(max(dp[1][m-1][n-1]), max(dp[0][m-1][n-1]))\n```", "extracted_code": "\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        def count_factors(n, f):\n            count = 0\n            while n % f == 0:\n                n //= f\n                count += 1\n            return count\n\n        m, n = len(grid), len(grid[0])\n        dp = [[[[-1, -1] for _ in range(n)] for _ in range(m)] for _ in range(2)]\n        dp[0][0][0][0] = dp[1][0][0][0] = min(count_factors(grid[0][0], 2), count_factors(grid[0][0], 5))\n\n        for i in range(m):\n            for j in range(n):\n                for k in range(2):\n                    if i + j == 0:\n                        continue\n                    if i > 0:\n                        dp[k][i][j][0] = max(dp[k][i][j][0], dp[k][i-1][j][0] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n                        if k > 0:\n                            dp[k][i][j][0] = max(dp[k][i][j][0], dp[k-1][i-1][j][1] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n                    if j > 0:\n                        dp[k][i][j][1] = max(dp[k][i][j][1], dp[k][i][j-1][1] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n                        if k > 0:\n                            dp[k][i][j][1] = max(dp[k][i][j][1], dp[k-1][i][j-1][0] + min(count_factors(grid[i][j], 2), count_factors(grid[i][j], 5)))\n        \n        return max(max(dp[1][m-1][n-1]), max(dp[0][m-1][n-1]))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2241", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass ATM:\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n        self.values = [20, 50, 100, 200, 500]\n\n    def deposit(self, banknotesCount):\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount):\n        used = [0, 0, 0, 0, 0]\n        for i in range(4, -1, -1):\n            count = min(self.banknotes[i], amount // self.values[i])\n            amount -= count * self.values[i]\n            used[i] = count\n            self.banknotes[i] -= count\n\n        if amount > 0:\n            for i in range(5):\n                self.banknotes[i] += used[i]\n            return [-1]\n        else:\n            return used\n```", "extracted_code": "\nclass ATM:\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n        self.values = [20, 50, 100, 200, 500]\n\n    def deposit(self, banknotesCount):\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount):\n        used = [0, 0, 0, 0, 0]\n        for i in range(4, -1, -1):\n            count = min(self.banknotes[i], amount // self.values[i])\n            amount -= count * self.values[i]\n            used[i] = count\n            self.banknotes[i] -= count\n\n        if amount > 0:\n            for i in range(5):\n                self.banknotes[i] += used[i]\n            return [-1]\n        else:\n            return used\n", "difficulty": 2.0}
{"task_id": "LeetCode/965", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isUnivalTree(self, root):\n        if root == None:\n            return True\n        if root.left != None and root.left.val != root.val:\n            return False\n        if root.right != None and root.right.val != root.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n```\nThis function uses a recursive approach to check each node of the tree. First, it checks if the root node is None. If it is, the function returns True, as an empty tree is considered uni-valued. Then it checks the left and right child nodes of the root node. If either child node's value doesn't match the root node's value, the function returns False, indicating that the tree is not uni-valued. If both child nodes' values match the root node's value, the function then recursively checks the left and right subtrees. The function continues to check each node and its children until it has checked all nodes or it has found a non-matching value. The function returns True if all node values are the same, and False otherwise.", "extracted_code": "\nclass Solution:\n    def isUnivalTree(self, root):\n        if root == None:\n            return True\n        if root.left != None and root.left.val != root.val:\n            return False\n        if root.right != None and root.right.val != root.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/953", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isAlienSorted(self, words, order):\n        order_index = {c: i for i, c in enumerate(order)}\n\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i+1]\n\n            for k in range(min(len(word1), len(word2))):\n                if word1[k] != word2[k]:\n                    if order_index[word1[k]] > order_index[word2[k]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isAlienSorted(self, words, order):\n        order_index = {c: i for i, c in enumerate(order)}\n\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i+1]\n\n            for k in range(min(len(word1), len(word2))):\n                if word1[k] != word2[k]:\n                    if order_index[word1[k]] > order_index[word2[k]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/944", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        return sum(list(col) != sorted(col) for col in zip(*strs))\n```", "extracted_code": "\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        return sum(list(col) != sorted(col) for col in zip(*strs))\n", "difficulty": 1.0}
{"task_id": "LeetCode/933", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom collections import deque\n\nclass RecentCounter:\n\n    def __init__(self):\n        self.q = deque()\n\n    def ping(self, t: int) -> int:\n        self.q.append(t)\n        while self.q[0] < t - 3000:\n            self.q.popleft()\n        return len(self.q)\n```\nIn this Python code, a deque is used to store the times of the requests. The `ping` method appends the new time to the deque and then removes all times older than `t - 3000` from the front of the deque. The length of the deque after this process is the number of requests within the last 3000 milliseconds. This solution is efficient because it only stores the times of the relevant requests and because removing elements from the front of a deque is a fast operation.", "extracted_code": "\nfrom collections import deque\n\nclass RecentCounter:\n\n    def __init__(self):\n        self.q = deque()\n\n    def ping(self, t: int) -> int:\n        self.q.append(t)\n        while self.q[0] < t - 3000:\n            self.q.popleft()\n        return len(self.q)\n", "difficulty": 1.0}
{"task_id": "LeetCode/914", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: [int]) -> bool:\n        vals = Counter(deck).values()\n        return reduce(gcd, vals) >= 2\n```", "extracted_code": "\nfrom collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: [int]) -> bool:\n        vals = Counter(deck).values()\n        return reduce(gcd, vals) >= 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/892", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def surfaceArea(self, grid: list[list[int]]) -> int:\n        n = len(grid)\n        res = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    res += grid[i][j] * 4 + 2\n                    if i:\n                        res -= min(grid[i][j], grid[i - 1][j]) * 2\n                    if j:\n                        res -= min(grid[i][j], grid[i][j - 1]) * 2\n        return res\n```", "extracted_code": "\nclass Solution:\n    def surfaceArea(self, grid: list[list[int]]) -> int:\n        n = len(grid)\n        res = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    res += grid[i][j] * 4 + 2\n                    if i:\n                        res -= min(grid[i][j], grid[i - 1][j]) * 2\n                    if j:\n                        res -= min(grid[i][j], grid[i][j - 1]) * 2\n        return res\n", "difficulty": 1.0}
{"task_id": "LeetCode/888", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fairCandySwap(self, aliceSizes, bobSizes):\n        sumAlice, sumBob = sum(aliceSizes), sum(bobSizes)\n        setBob = set(bobSizes)\n        for x in aliceSizes:\n            if x + (sumBob - sumAlice) // 2 in setBob:\n                return [x, x + (sumBob - sumAlice) // 2]\n```", "extracted_code": "\nclass Solution:\n    def fairCandySwap(self, aliceSizes, bobSizes):\n        sumAlice, sumBob = sum(aliceSizes), sum(bobSizes)\n        setBob = set(bobSizes)\n        for x in aliceSizes:\n            if x + (sumBob - sumAlice) // 2 in setBob:\n                return [x, x + (sumBob - sumAlice) // 2]\n", "difficulty": 1.0}
{"task_id": "LeetCode/867", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n```", "extracted_code": "\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/844", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        def build(S):\n            ans = []\n            for c in S:\n                if c != '#':\n                    ans.append(c)\n                elif ans:\n                    ans.pop()\n            return \"\".join(ans)\n        return build(s) == build(t)\n```", "extracted_code": "\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        def build(S):\n            ans = []\n            for c in S:\n                if c != '#':\n                    ans.append(c)\n                elif ans:\n                    ans.pop()\n            return \"\".join(ans)\n        return build(s) == build(t)\n", "difficulty": 1.0}
{"task_id": "LeetCode/830", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        i, j, n = 0, 0, len(s)\n        res = []\n        while j < n:\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                res.append([i, j - 1])\n            i = j\n        return res\n```", "extracted_code": "\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        i, j, n = 0, 0, len(s)\n        res = []\n        while j < n:\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                res.append([i, j - 1])\n            i = j\n        return res\n", "difficulty": 1.0}
{"task_id": "LeetCode/804", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        transformations = {\"\".join(morse[ord(c) - ord('a')] for c in word) for word in words}\n        return len(transformations)\n```", "extracted_code": "\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        transformations = {\"\".join(morse[ord(c) - ord('a')] for c in word) for word in words}\n        return len(transformations)\n", "difficulty": 1.0}
{"task_id": "LeetCode/762", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\n        return sum(bin(x).count('1') in primes for x in range(left, right+1))\n```", "extracted_code": "\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\n        return sum(bin(x).count('1') in primes for x in range(left, right+1))\n", "difficulty": 1.0}
{"task_id": "LeetCode/728", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        def isSelfDividing(num):\n            for d in str(num):\n                if d == '0' or num % int(d) > 0:\n                    return False\n            return True\n\n        return [num for num in range(left, right + 1) if isSelfDividing(num)]\n```", "extracted_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        def isSelfDividing(num):\n            for d in str(num):\n                if d == '0' or num % int(d) > 0:\n                    return False\n            return True\n\n        return [num for num in range(left, right + 1) if isSelfDividing(num)]\n", "difficulty": 1.0}
{"task_id": "LeetCode/706", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass MyHashMap:\n\n    def __init__(self):\n        self.map = [-1] * 1000000\n\n    def put(self, key: int, value: int) -> None:\n        self.map[key] = value\n\n    def get(self, key: int) -> int:\n        return self.map[key]\n\n    def remove(self, key: int) -> None:\n        self.map[key] = -1\n```\nFor the above Python code, I have created a list of size 1000000 (1 million) to account for the constraint that key and value can be any integer between 0 and 10^6. The `put` method updates the value at the index equals to the key in the list. The `get` method fetches the value at the index equals to the key. The `remove` method updates the value at the index equals to the key to -1. Since we are simply manipulating a list of integers, the time complexity for all operations is O(1).", "extracted_code": "\nclass MyHashMap:\n\n    def __init__(self):\n        self.map = [-1] * 1000000\n\n    def put(self, key: int, value: int) -> None:\n        self.map[key] = value\n\n    def get(self, key: int) -> int:\n        return self.map[key]\n\n    def remove(self, key: int) -> None:\n        self.map[key] = -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/704", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/682", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        for operation in operations:\n            if operation == 'C':\n                record.pop()\n            elif operation == 'D':\n                record.append(record[-1] * 2)\n            elif operation == '+':\n                record.append(record[-1] + record[-2])\n            else:\n                record.append(int(operation))\n        return sum(record)\n```", "extracted_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        record = []\n        for operation in operations:\n            if operation == 'C':\n                record.pop()\n            elif operation == 'D':\n                record.append(record[-1] * 2)\n            elif operation == '+':\n                record.append(record[-1] + record[-2])\n            else:\n                record.append(int(operation))\n        return sum(record)\n", "difficulty": 1.0}
{"task_id": "LeetCode/680", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_pali_range(i: int, j: int) -> bool:\n            return all(s[k] == s[j-k+i] for k in range(i, j))\n\n        for i in range(len(s) // 2):\n            if s[i] != s[~i]:\n                j = len(s) - 1 - i\n                return is_pali_range(i+1, j) or is_pali_range(i, j-1)\n        return True\n```", "extracted_code": "\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_pali_range(i: int, j: int) -> bool:\n            return all(s[k] == s[j-k+i] for k in range(i, j))\n\n        for i in range(len(s) // 2):\n            if s[i] != s[~i]:\n                j = len(s) - 1 - i\n                return is_pali_range(i+1, j) or is_pali_range(i, j-1)\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/674", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        longest_length, current_length = 0, 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i-1] < nums[i]:\n                current_length += 1\n                longest_length = max(longest_length, current_length)\n            else:\n                current_length = 1\n        return longest_length\n```", "extracted_code": "\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        longest_length, current_length = 0, 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i-1] < nums[i]:\n                current_length += 1\n                longest_length = max(longest_length, current_length)\n            else:\n                current_length = 1\n        return longest_length\n", "difficulty": 1.0}
{"task_id": "LeetCode/671", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "Here is the Python code that solves the problem:\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        self.ans = float('inf')\n        min1 = root.val\n\n        def dfs(node):\n            if node:\n                if min1 < node.val < self.ans:\n                    self.ans = node.val\n                elif node.val == min1:\n                    dfs(node.left)\n                    dfs(node.right)\n\n        dfs(root)\n        return self.ans if self.ans < float('inf') else -1\n```\n\nThis solution uses a depth-first search (dfs) to traverse the binary tree. It maintains two global variables: `min1` which is the smallest value in the tree, and `ans` which is the second smallest value. \n\nIn the dfs function, if the node's value is larger than `min1` and smaller than `ans`, the node's value is the new second smallest value and is updated to `ans`. If the node's value is equal to `min1`, it continues to search in the left and right subtree. \n\nAfter the dfs, if `ans` is still `inf`, it means there is no second smallest value, so it returns `-1`, otherwise it returns the `ans`.", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        self.ans = float('inf')\n        min1 = root.val\n\n        def dfs(node):\n            if node:\n                if min1 < node.val < self.ans:\n                    self.ans = node.val\n                elif node.val == min1:\n                    dfs(node.left)\n                    dfs(node.right)\n\n        dfs(root)\n        return self.ans if self.ans < float('inf') else -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/645", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findErrorNums(self, nums):\n        n = len(nums)\n        total = n*(n+1)//2\n        actual_total = sum(nums)\n        set_total = sum(set(nums))\n        duplicate = actual_total - set_total\n        missing = total - set_total\n        return [duplicate, missing]\n```", "extracted_code": "\nclass Solution:\n    def findErrorNums(self, nums):\n        n = len(nums)\n        total = n*(n+1)//2\n        actual_total = sum(nums)\n        set_total = sum(set(nums))\n        duplicate = actual_total - set_total\n        missing = total - set_total\n        return [duplicate, missing]\n", "difficulty": 1.0}
{"task_id": "LeetCode/617", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1 and not root2:\n            return None\n        elif not root1:\n            return root2\n        elif not root2:\n            return root1\n        else:\n            root1.val += root2.val\n            root1.left = self.mergeTrees(root1.left, root2.left)\n            root1.right = self.mergeTrees(root1.right, root2.right)\n            return root1\n```", "extracted_code": "\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1 and not root2:\n            return None\n        elif not root1:\n            return root2\n        elif not root2:\n            return root1\n        else:\n            root1.val += root2.val\n            root1.left = self.mergeTrees(root1.left, root2.left)\n            root1.right = self.mergeTrees(root1.right, root2.right)\n            return root1\n", "difficulty": 1.0}
{"task_id": "LeetCode/599", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        common = set(list1) & set(list2)\n        d = {x: list1.index(x) + list2.index(x) for x in common}\n        min_val = min(d.values())\n        return [k for k, v in d.items() if v == min_val]\n```", "extracted_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        common = set(list1) & set(list2)\n        d = {x: list1.index(x) + list2.index(x) for x in common}\n        min_val = min(d.values())\n        return [k for k, v in d.items() if v == min_val]\n", "difficulty": 1.0}
{"task_id": "LeetCode/572", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        if self.isSameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def isSameTree(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        if not root1 and not root2:\n            return True\n        if not root1 or not root2:\n            return False\n        return root1.val == root2.val and self.isSameTree(root1.left, root2.left) and self.isSameTree(root1.right, root2.right)\n```", "extracted_code": "\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        if self.isSameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def isSameTree(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        if not root1 and not root2:\n            return True\n        if not root1 or not root2:\n            return False\n        return root1.val == root2.val and self.isSameTree(root1.left, root2.left) and self.isSameTree(root1.right, root2.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/551", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        return s.count('A') < 2 and 'LLL' not in s\n```", "extracted_code": "\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        return s.count('A') < 2 and 'LLL' not in s\n", "difficulty": 1.0}
{"task_id": "LeetCode/509", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n```", "extracted_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n", "difficulty": 1.0}
{"task_id": "LeetCode/2449", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        diff = [nums[i] - target[i] for i in range(len(nums))]\n        positive_sum = sum(x for x in diff if x > 0)\n        negative_sum = sum(x for x in diff if x < 0)\n        if positive_sum != abs(negative_sum):\n            return -1\n        return abs(positive_sum) // 2\n```", "extracted_code": "\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        diff = [nums[i] - target[i] for i in range(len(nums))]\n        positive_sum = sum(x for x in diff if x > 0)\n        negative_sum = sum(x for x in diff if x < 0)\n        if positive_sum != abs(negative_sum):\n            return -1\n        return abs(positive_sum) // 2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2448", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        vals = sorted(zip(nums, cost))\n        left = right = len(nums) // 2\n        total = sum = 0\n        while right < len(nums) - 1 and vals[right][0] == vals[right + 1][0]:\n            right += 1\n        while left > 0 and vals[left][0] == vals[left - 1][0]:\n            left -= 1\n        for i in range(left, -1, -1):\n            total += (vals[i][0] - vals[left][0]) * vals[i][1]\n            sum += vals[i][1]\n        for i in range(right, len(nums)):\n            total += (vals[i][0] - vals[right][0]) * vals[i][1]\n            sum -= vals[i][1]\n        minCost = total\n        while right != left:\n            right -= 1\n            total += sum * (vals[right + 1][0] - vals[right][0])\n            sum -= vals[right + 1][1]\n            minCost = min(minCost, total)\n        return minCost\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        vals = sorted(zip(nums, cost))\n        left = right = len(nums) // 2\n        total = sum = 0\n        while right < len(nums) - 1 and vals[right][0] == vals[right + 1][0]:\n            right += 1\n        while left > 0 and vals[left][0] == vals[left - 1][0]:\n            left -= 1\n        for i in range(left, -1, -1):\n            total += (vals[i][0] - vals[left][0]) * vals[i][1]\n            sum += vals[i][1]\n        for i in range(right, len(nums)):\n            total += (vals[i][0] - vals[right][0]) * vals[i][1]\n            sum -= vals[i][1]\n        minCost = total\n        while right != left:\n            right -= 1\n            total += sum * (vals[right + 1][0] - vals[right][0])\n            sum -= vals[right + 1][1]\n            minCost = min(minCost, total)\n        return minCost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2444", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        nums = [0] + nums + [0]\n        stack = []\n        left, right = [0]*len(nums), [0]*len(nums)\n        \n        for i in range(len(nums)):\n            while stack and nums[stack[-1]] < nums[i]:\n                right[stack.pop()] = i\n            stack.append(i)\n        \n        stack = []\n        for i in range(len(nums)-1, -1, -1):\n            while stack and nums[stack[-1]] < nums[i]:\n                left[stack.pop()] = i\n            stack.append(i)\n        \n        res = 0\n        for i in range(1, len(nums)-1):\n            if minK <= nums[i] <= maxK:\n                res += (i - left[i]) * (right[i] - i)\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        nums = [0] + nums + [0]\n        stack = []\n        left, right = [0]*len(nums), [0]*len(nums)\n        \n        for i in range(len(nums)):\n            while stack and nums[stack[-1]] < nums[i]:\n                right[stack.pop()] = i\n            stack.append(i)\n        \n        stack = []\n        for i in range(len(nums)-1, -1, -1):\n            while stack and nums[stack[-1]] < nums[i]:\n                left[stack.pop()] = i\n            stack.append(i)\n        \n        res = 0\n        for i in range(1, len(nums)-1):\n            if minK <= nums[i] <= maxK:\n                res += (i - left[i]) * (right[i] - i)\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2440", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        n = len(nums)\n        total = sum(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        seen, sums = [False]*n, [0]*n\n\n        def dfs(node):\n            seen[node] = True\n            for nei in graph[node]:\n                if not seen[nei]:\n                    sums[node] += dfs(nei)\n            sums[node] += nums[node]\n            return sums[node]\n\n        dfs(0)\n        return sum(s == total//2 for s in sums if s <= total//2) if total % 2 == 0 else 0\n```", "extracted_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        n = len(nums)\n        total = sum(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        seen, sums = [False]*n, [0]*n\n\n        def dfs(node):\n            seen[node] = True\n            for nei in graph[node]:\n                if not seen[nei]:\n                    sums[node] += dfs(nei)\n            sums[node] += nums[node]\n            return sums[node]\n\n        dfs(0)\n        return sum(s == total//2 for s in sums if s <= total//2) if total % 2 == 0 else 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2435", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        MOD = 10**9 + 7\n        dp = [[0]*k for _ in range(n)]\n        dp[0][grid[0][0] % k] = 1\n        for i in range(m):\n            new_dp = [[0]*k for _ in range(n)]\n            for j in range(n):\n                for rem in range(k):\n                    if dp[j][rem] > 0:\n                        if j+1 < n:\n                            new_dp[j+1][(rem+grid[i][j+1])%k] += dp[j][rem]\n                            new_dp[j+1][(rem+grid[i][j+1])%k] %= MOD\n                        if i+1 < m:\n                            new_dp[j][(rem+grid[i+1][j])%k] += dp[j][rem]\n                            new_dp[j][(rem+grid[i+1][j])%k] %= MOD\n            dp = new_dp\n        return dp[n-1][0]\n```", "extracted_code": "\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        MOD = 10**9 + 7\n        dp = [[0]*k for _ in range(n)]\n        dp[0][grid[0][0] % k] = 1\n        for i in range(m):\n            new_dp = [[0]*k for _ in range(n)]\n            for j in range(n):\n                for rem in range(k):\n                    if dp[j][rem] > 0:\n                        if j+1 < n:\n                            new_dp[j+1][(rem+grid[i][j+1])%k] += dp[j][rem]\n                            new_dp[j+1][(rem+grid[i][j+1])%k] %= MOD\n                        if i+1 < m:\n                            new_dp[j][(rem+grid[i+1][j])%k] += dp[j][rem]\n                            new_dp[j][(rem+grid[i+1][j])%k] %= MOD\n            dp = new_dp\n        return dp[n-1][0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2430", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        prefix = [0] * (n + 1)\n        next_same = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            if i == n - 1 or s[i] != s[i + 1]:\n                next_same[i] = i + 1\n            else:\n                next_same[i] = next_same[i + 1]\n            dp[i] = max(1 + dp[i + 1], 2 * dp[next_same[i]])\n            prefix[i] = max(prefix[i + 1], dp[i])\n        return prefix[0]\n```", "extracted_code": "\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        prefix = [0] * (n + 1)\n        next_same = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            if i == n - 1 or s[i] != s[i + 1]:\n                next_same[i] = i + 1\n            else:\n                next_same[i] = next_same[i + 1]\n            dp[i] = max(1 + dp[i + 1], 2 * dp[next_same[i]])\n            prefix[i] = max(prefix[i + 1], dp[i])\n        return prefix[0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2426", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        n = len(nums1)\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        n = len(nums1)\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2421", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        graph = [[] for _ in vals]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        max_val, cnt, used = [0]*len(vals), [0]*len(vals), [0]*len(vals)\n        res = [0]*len(vals)\n        \n        def dfs(node, parent):\n            count = cnt[vals[node]]\n            for nei in graph[node]:\n                if nei == parent: continue\n                dfs(nei, node)\n                if max_val[nei] == vals[node]:\n                    res[vals[node]] += res[nei]\n                    count += 1\n                elif max_val[nei] < vals[node]:\n                    count += res[nei]\n            if used[vals[node]] == 0:\n                used[vals[node]] = 1\n                count += 1\n            max_val[node] = vals[node]\n            res[vals[node]] += count\n            cnt[vals[node]] = count\n            \n        dfs(vals.index(max(vals)), None)\n        return sum(res)\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        graph = [[] for _ in vals]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        max_val, cnt, used = [0]*len(vals), [0]*len(vals), [0]*len(vals)\n        res = [0]*len(vals)\n        \n        def dfs(node, parent):\n            count = cnt[vals[node]]\n            for nei in graph[node]:\n                if nei == parent: continue\n                dfs(nei, node)\n                if max_val[nei] == vals[node]:\n                    res[vals[node]] += res[nei]\n                    count += 1\n                elif max_val[nei] < vals[node]:\n                    count += res[nei]\n            if used[vals[node]] == 0:\n                used[vals[node]] = 1\n                count += 1\n            max_val[node] = vals[node]\n            res[vals[node]] += count\n            cnt[vals[node]] = count\n            \n        dfs(vals.index(max(vals)), None)\n        return sum(res)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2416", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumPrefixScores(self, words):\n        prefix_count = {}\n        answer = []\n        for word in words:\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                if prefix not in prefix_count:\n                    prefix_count[prefix] = 0\n                prefix_count[prefix] += 1\n        for word in words:\n            total = 0\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                total += prefix_count[prefix]\n            answer.append(total)\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def sumPrefixScores(self, words):\n        prefix_count = {}\n        answer = []\n        for word in words:\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                if prefix not in prefix_count:\n                    prefix_count[prefix] = 0\n                prefix_count[prefix] += 1\n        for word in words:\n            total = 0\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                total += prefix_count[prefix]\n            answer.append(total)\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2415", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n\n        # list to store nodes at each level\n        levelNodes = []\n\n        def dfs(node, level):\n            if level >= len(levelNodes):\n                levelNodes.append([])\n            levelNodes[level].append(node)\n\n            if node.left:\n                dfs(node.left, level + 1)\n            if node.right:\n                dfs(node.right, level + 1)\n\n        dfs(root, 0)\n\n        # reverse nodes at odd levels\n        for i in range(1, len(levelNodes), 2):\n            levelNodes[i] = levelNodes[i][::-1]\n\n        # assign reversed nodes back to tree\n        for i in range(len(levelNodes)):\n            for j in range(len(levelNodes[i])):\n                if 2 * j + 1 < len(levelNodes[i - 1]):\n                    levelNodes[i][j].left = levelNodes[i - 1][2 * j + 1]\n                if 2 * j + 2 < len(levelNodes[i - 1]):\n                    levelNodes[i][j].right = levelNodes[i - 1][2 * j + 2]\n\n        return root\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n\n        # list to store nodes at each level\n        levelNodes = []\n\n        def dfs(node, level):\n            if level >= len(levelNodes):\n                levelNodes.append([])\n            levelNodes[level].append(node)\n\n            if node.left:\n                dfs(node.left, level + 1)\n            if node.right:\n                dfs(node.right, level + 1)\n\n        dfs(root, 0)\n\n        # reverse nodes at odd levels\n        for i in range(1, len(levelNodes), 2):\n            levelNodes[i] = levelNodes[i][::-1]\n\n        # assign reversed nodes back to tree\n        for i in range(len(levelNodes)):\n            for j in range(len(levelNodes[i])):\n                if 2 * j + 1 < len(levelNodes[i - 1]):\n                    levelNodes[i][j].left = levelNodes[i - 1][2 * j + 1]\n                if 2 * j + 2 < len(levelNodes[i - 1]):\n                    levelNodes[i][j].right = levelNodes[i - 1][2 * j + 2]\n\n        return root\n", "difficulty": 2.0}
{"task_id": "LeetCode/2414", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_len = curr_len = 1\n        for i in range(1, len(s)):\n            if ord(s[i-1])+1 == ord(s[i]):\n                curr_len += 1\n                max_len = max(max_len, curr_len)\n            else:\n                curr_len = 1\n        return max_len\n```", "extracted_code": "\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_len = curr_len = 1\n        for i in range(1, len(s)):\n            if ord(s[i-1])+1 == ord(s[i]):\n                curr_len += 1\n                max_len = max(max_len, curr_len)\n            else:\n                curr_len = 1\n        return max_len\n", "difficulty": 2.0}
{"task_id": "LeetCode/2412", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumMoney(self, transactions):\n        total_cost = sum(x[0] for x in transactions)\n        total_cashback = sum(x[1] for x in transactions)\n        max_cost = max(x[0] - x[1] for x in transactions)\n        return max(total_cost - total_cashback, max_cost)\n```", "extracted_code": "\nclass Solution:\n    def minimumMoney(self, transactions):\n        total_cost = sum(x[0] for x in transactions)\n        total_cashback = sum(x[1] for x in transactions)\n        max_cost = max(x[0] - x[1] for x in transactions)\n        return max(total_cost - total_cashback, max_cost)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2407", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if abs(nums[i] - nums[j]) <= k and nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n```", "extracted_code": "\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if abs(nums[i] - nums[j]) <= k and nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2402", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n        rooms = [0] * n\n        room_meetings = [0] * n\n        heapq.heapify(rooms)\n        for start, end in meetings:\n            while rooms and rooms[0] <= start:\n                heapq.heappop(rooms)\n            if len(rooms) < n:\n                room_meetings[n - len(rooms) - 1] += 1\n            heapq.heappush(rooms, end)\n        return room_meetings.index(max(room_meetings))\n```", "extracted_code": "\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n        rooms = [0] * n\n        room_meetings = [0] * n\n        heapq.heapify(rooms)\n        for start, end in meetings:\n            while rooms and rooms[0] <= start:\n                heapq.heappop(rooms)\n            if len(rooms) < n:\n                room_meetings[n - len(rooms) - 1] += 1\n            heapq.heappush(rooms, end)\n        return room_meetings.index(max(room_meetings))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2401", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestNiceSubarray(self, nums):\n        max_length = 0\n        n = len(nums)\n        for i in range(n):\n            j = i\n            max_val = min_val = nums[i]\n            while j<n:\n                max_val = max(max_val, nums[j])\n                min_val = min(min_val, nums[j])\n                if max_val & ((1 << 20) - 1 - min_val) == 0:\n                    max_length = max(max_length, j - i + 1)\n                j += 1\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestNiceSubarray(self, nums):\n        max_length = 0\n        n = len(nums)\n        for i in range(n):\n            j = i\n            max_val = min_val = nums[i]\n            while j<n:\n                max_val = max(max_val, nums[j])\n                min_val = min(min_val, nums[j])\n                if max_val & ((1 << 20) - 1 - min_val) == 0:\n                    max_length = max(max_length, j - i + 1)\n                j += 1\n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2398", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRobots(self, chargeTimes: list[int], runningCosts: list[int], budget: int) -> int:\n        n = len(chargeTimes)\n        robots = sorted([(chargeTimes[i], runningCosts[i]) for i in range(n)])\n        prefixSum = [0] * (n + 1)\n        for i in range(n):\n            prefixSum[i+1] = prefixSum[i] + robots[i][1]\n\n        l = 0\n        r = n\n        while l < r:\n            mid = (l + r + 1) // 2\n            if robots[mid-1][0] + mid * prefixSum[mid] > budget:\n                r = mid - 1\n            else:\n                l = mid\n\n        return l\n```", "extracted_code": "\nclass Solution:\n    def maximumRobots(self, chargeTimes: list[int], runningCosts: list[int], budget: int) -> int:\n        n = len(chargeTimes)\n        robots = sorted([(chargeTimes[i], runningCosts[i]) for i in range(n)])\n        prefixSum = [0] * (n + 1)\n        for i in range(n):\n            prefixSum[i+1] = prefixSum[i] + robots[i][1]\n\n        l = 0\n        r = n\n        while l < r:\n            mid = (l + r + 1) // 2\n            if robots[mid-1][0] + mid * prefixSum[mid] > budget:\n                r = mid - 1\n            else:\n                l = mid\n\n        return l\n", "difficulty": 3.0}
{"task_id": "LeetCode/2397", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRows(self, matrix, numSelect):\n        from collections import Counter, defaultdict\n        import numpy as np\n\n        m, n = len(matrix), len(matrix[0])\n        freq = Counter()\n        rows = defaultdict(set)\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    freq[j] += 1\n                    rows[j].add(i)\n        \n        dp = np.zeros((1 << n, numSelect+1), dtype=int)\n        for mask in range(1, 1 << n):\n            col = bin(mask).count('1') - 1\n            if col < numSelect:\n                for i in range(n):\n                    if (mask >> i) & 1:\n                        new_mask = mask ^ (1 << i)\n                        dp[mask][col+1] = max(dp[mask][col+1], dp[new_mask][col] + len(rows[i]))\n                        dp[mask][col+1] = max(dp[mask][col+1], dp[mask][col])\n\n        return max(dp[i][j] for i in range(1 << n) for j in range(numSelect+1))\n```", "extracted_code": "\nclass Solution:\n    def maximumRows(self, matrix, numSelect):\n        from collections import Counter, defaultdict\n        import numpy as np\n\n        m, n = len(matrix), len(matrix[0])\n        freq = Counter()\n        rows = defaultdict(set)\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    freq[j] += 1\n                    rows[j].add(i)\n        \n        dp = np.zeros((1 << n, numSelect+1), dtype=int)\n        for mask in range(1, 1 << n):\n            col = bin(mask).count('1') - 1\n            if col < numSelect:\n                for i in range(n):\n                    if (mask >> i) & 1:\n                        new_mask = mask ^ (1 << i)\n                        dp[mask][col+1] = max(dp[mask][col+1], dp[new_mask][col] + len(rows[i]))\n                        dp[mask][col+1] = max(dp[mask][col+1], dp[mask][col])\n\n        return max(dp[i][j] for i in range(1 << n) for j in range(numSelect+1))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2396", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        for base in range(2, n - 1):\n            num_str = ''\n            temp = n\n            while temp:\n                num_str = str(temp % base) + num_str\n                temp //= base\n            if num_str != num_str[::-1]:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        for base in range(2, n - 1):\n            num_str = ''\n            temp = n\n            while temp:\n                num_str = str(temp % base) + num_str\n                temp //= base\n            if num_str != num_str[::-1]:\n                return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2392", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: list[list[int]], colConditions: list[list[int]]) -> list[list[int]]:\n        import numpy as np\n        row = np.zeros((k,k), dtype = int)\n        col = np.zeros((k,k), dtype = int)\n        for i in range(k):\n            row[i][i] = i + 1\n            col[i][i] = i + 1\n        for i, j in rowConditions:\n            if i > j:\n                row[i-1][j-1] = 0\n            if j > i:\n                row[j-1][i-1] = 0\n        for i, j in colConditions:\n            if i > j:\n                col[j-1][i-1] = 0\n            if j > i:\n                col[i-1][j-1] = 0\n        result = row + col\n        if np.max(result) > k or np.min(result) < 0:\n            return []\n        else:\n            result = result.tolist()\n            for i in range(k):\n                for j in range(k):\n                    if result[i][j] > k:\n                        result[i][j] = 0\n            return result\n```", "extracted_code": "\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: list[list[int]], colConditions: list[list[int]]) -> list[list[int]]:\n        import numpy as np\n        row = np.zeros((k,k), dtype = int)\n        col = np.zeros((k,k), dtype = int)\n        for i in range(k):\n            row[i][i] = i + 1\n            col[i][i] = i + 1\n        for i, j in rowConditions:\n            if i > j:\n                row[i-1][j-1] = 0\n            if j > i:\n                row[j-1][i-1] = 0\n        for i, j in colConditions:\n            if i > j:\n                col[j-1][i-1] = 0\n            if j > i:\n                col[i-1][j-1] = 0\n        result = row + col\n        if np.max(result) > k or np.min(result) < 0:\n            return []\n        else:\n            result = result.tolist()\n            for i in range(k):\n                for j in range(k):\n                    if result[i][j] > k:\n                        result[i][j] = 0\n            return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2390", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        stack = []\n        for ch in s:\n            if ch == '*':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(ch)\n        return ''.join(stack)\n```", "extracted_code": "\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        stack = []\n        for ch in s:\n            if ch == '*':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(ch)\n        return ''.join(stack)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2386", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums.sort(reverse=True)\n        sums = [0]\n        for num in nums:\n            if num < 0: break\n            for i in range(len(sums)-1, -1, -1):\n                sums.append(sums[i] + num)\n        sums.sort(reverse=True)\n        return sums[k]\n```", "extracted_code": "\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums.sort(reverse=True)\n        sums = [0]\n        for num in nums:\n            if num < 0: break\n            for i in range(len(sums)-1, -1, -1):\n                sums.append(sums[i] + num)\n        sums.sort(reverse=True)\n        return sums[k]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2382", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_sum = [0] * (n+1)\n        answer = [0] * n\n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + nums[i]\n        max_sum = max(prefix_sum)\n        for i in range(n):\n            idx = removeQueries[i]\n            nums[idx] = -nums[idx]\n            max_sum = max(max_sum, prefix_sum[idx] - prefix_sum[idx+1] + max(0, prefix_sum[-1] - prefix_sum[idx+1]))\n            answer[i] = max_sum\n        return answer[::-1]\n```", "extracted_code": "\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_sum = [0] * (n+1)\n        answer = [0] * n\n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + nums[i]\n        max_sum = max(prefix_sum)\n        for i in range(n):\n            idx = removeQueries[i]\n            nums[idx] = -nums[idx]\n            max_sum = max(max_sum, prefix_sum[idx] - prefix_sum[idx+1] + max(0, prefix_sum[-1] - prefix_sum[idx+1]))\n            answer[i] = max_sum\n        return answer[::-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2376", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        dp=[0]*10\n        dp[1]=10\n        for i in range(2,11):\n            dp[i-1]=dp[i-2]*(11-i)\n        ans=0\n        for i in range(1,11):\n            if n<10**i:\n                for j in range(i):\n                    ans+=dp[j]\n                same=[0]*10\n                for j in range(1,i+1):\n                    for k in range(0 if j==i else 1,10):\n                        if same[k]==0:\n                            if j!=i or k<=int(str(n)[j-1]):\n                                ans+=dp[i-j]*(9 if j==1 else 10-j)\n                            if k==int(str(n)[j-1]:\n                                same[k]=1\n                break\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        dp=[0]*10\n        dp[1]=10\n        for i in range(2,11):\n            dp[i-1]=dp[i-2]*(11-i)\n        ans=0\n        for i in range(1,11):\n            if n<10**i:\n                for j in range(i):\n                    ans+=dp[j]\n                same=[0]*10\n                for j in range(1,i+1):\n                    for k in range(0 if j==i else 1,10):\n                        if same[k]==0:\n                            if j!=i or k<=int(str(n)[j-1]):\n                                ans+=dp[i-j]*(9 if j==1 else 10-j)\n                            if k==int(str(n)[j-1]:\n                                same[k]=1\n                break\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2366", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumReplacement(self, nums):\n        nums.sort()\n        count = 0\n        for i in range(len(nums)-1, 0, -1):\n            if nums[i] > nums[i-1]:\n                diff = nums[i] - nums[i-1]\n                nums[i] = nums[i] - diff\n                count += diff\n        return count\n```", "extracted_code": "\nclass Solution:\n    def minimumReplacement(self, nums):\n        nums.sort()\n        count = 0\n        for i in range(len(nums)-1, 0, -1):\n            if nums[i] > nums[i-1]:\n                diff = nums[i] - nums[i-1]\n                nums[i] = nums[i] - diff\n                count += diff\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2365", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_map = {}\n        time = 0\n        for task in tasks:\n            if task in task_map and time - task_map[task] < space:\n                time = task_map[task] + space\n            time += 1\n            task_map[task] = time\n        return time\n```", "extracted_code": "\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_map = {}\n        time = 0\n        for task in tasks:\n            if task in task_map and time - task_map[task] < space:\n                time = task_map[task] + space\n            time += 1\n            task_map[task] = time\n        return time\n", "difficulty": 2.0}
{"task_id": "LeetCode/2360", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestCycle(self, edges):\n        n = len(edges)\n        visited = [0]*n\n        maxCycle = -1\n        for i in range(n):\n            if visited[i] == 0:\n                cycle = []\n                while visited[i] != 2 and visited[i] != -1:\n                    visited[i] = 1\n                    cycle.append(i)\n                    i = edges[i]\n                    if i == -1:\n                        break\n                if visited[i] == -1:\n                    for node in cycle:\n                        visited[node] = -1\n                else:\n                    idx = cycle.index(i)\n                    maxCycle = max(maxCycle, len(cycle[idx:]))\n                    for node in cycle[:idx]:\n                        visited[node] = -1\n                    for node in cycle[idx:]:\n                        visited[node] = 2\n        return maxCycle\n```", "extracted_code": "\nclass Solution:\n    def longestCycle(self, edges):\n        n = len(edges)\n        visited = [0]*n\n        maxCycle = -1\n        for i in range(n):\n            if visited[i] == 0:\n                cycle = []\n                while visited[i] != 2 and visited[i] != -1:\n                    visited[i] = 1\n                    cycle.append(i)\n                    i = edges[i]\n                    if i == -1:\n                        break\n                if visited[i] == -1:\n                    for node in cycle:\n                        visited[node] = -1\n                else:\n                    idx = cycle.index(i)\n                    maxCycle = max(maxCycle, len(cycle[idx:]))\n                    for node in cycle[:idx]:\n                        visited[node] = -1\n                    for node in cycle[idx:]:\n                        visited[node] = 2\n        return maxCycle\n", "difficulty": 3.0}
{"task_id": "LeetCode/2354", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        def count_bits(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n\n        pair_count = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if count_bits(nums[i] | nums[j]) + count_bits(nums[i] & nums[j]) >= k:\n                    pair_count += 1\n        return pair_count\n```", "extracted_code": "\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        def count_bits(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n\n        pair_count = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if count_bits(nums[i] | nums[j]) + count_bits(nums[i] & nums[j]) >= k:\n                    pair_count += 1\n        return pair_count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2350", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        rolls.sort()\n        for i in range(1, len(rolls) + 2):\n            for combination in itertools.combinations(rolls, i):\n                sequence = [j for j in range(1, k + 1)]\n                for item in combination:\n                    if item in sequence:\n                        sequence.remove(item)\n                    else:\n                        break\n                if len(sequence) > 0:\n                    return i\n        return len(rolls) + 1\n```", "extracted_code": "\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        rolls.sort()\n        for i in range(1, len(rolls) + 2):\n            for combination in itertools.combinations(rolls, i):\n                sequence = [j for j in range(1, k + 1)]\n                for item in combination:\n                    if item in sequence:\n                        sequence.remove(item)\n                    else:\n                        break\n                if len(sequence) > 0:\n                    return i\n        return len(rolls) + 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2344", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums)):\n            if all(j % nums[i] == 0 for j in numsDivide):\n                return i\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums)):\n            if all(j % nums[i] == 0 for j in numsDivide):\n                return i\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2338", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        mod = 10**9+7\n        dp = [0]*(maxValue+1)\n        dp_sum = [0]*(maxValue+1)\n        dp[0] = 1\n        dp_sum[0] = 1\n        for _ in range(1,n):\n            for i in range(1,maxValue+1):\n                dp[i] = dp_sum[i-1]\n            dp_sum[0] = dp[0]\n            for i in range(1,maxValue+1):\n                dp_sum[i] = dp[i] + dp_sum[i-1]\n        res = sum(dp)\n        return res % mod\n```\nThis Python code defines a class Solution with a method idealArrays. The method uses dynamic programming to solve the problem. It initializes an array dp and dp_sum of length maxValue+1 with all elements as 0 and dp[0] as 1. Then it iterates over the range 1 to n and for each iteration, it updates the dp and dp_sum arrays. Finally, it returns the sum of the array dp modulo 10^9+7. \n\nIn the inner loop, for each i in range 1 to maxValue, it calculates the number of arrays ending with i by summing up the number of arrays ending with all numbers smaller than i (dp_sum[i-1]). \n\nIn the second inner loop, dp_sum[i] stores the sum of dp[0] to dp[i] for fast lookup in the next iteration. \n\nThe final result is the sum of all dp[i] because an ideal array can end with any number from 1 to maxValue. It returns the result modulo 10^9+7 to prevent overflow.", "extracted_code": "\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        mod = 10**9+7\n        dp = [0]*(maxValue+1)\n        dp_sum = [0]*(maxValue+1)\n        dp[0] = 1\n        dp_sum[0] = 1\n        for _ in range(1,n):\n            for i in range(1,maxValue+1):\n                dp[i] = dp_sum[i-1]\n            dp_sum[0] = dp[0]\n            for i in range(1,maxValue+1):\n                dp_sum[i] = dp[i] + dp_sum[i-1]\n        res = sum(dp)\n        return res % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2334", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n        left, right, total, length = 0, 0, 0, 0\n        while right < len(nums):\n            total += nums[right]\n            while total > threshold:\n                total -= nums[left]\n                left += 1\n            length = max(length, right - left + 1)\n            right += 1\n        return length if total >= threshold else -1\n```", "extracted_code": "\nclass Solution:\n    def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n        left, right, total, length = 0, 0, 0, 0\n        while right < len(nums):\n            total += nums[right]\n            while total > threshold:\n                total -= nums[left]\n                left += 1\n            length = max(length, right - left + 1)\n            right += 1\n        return length if total >= threshold else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2328", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPaths(self, grid):\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[0] * n for _ in range(m)]\n        for i, j in sorted((i, j) for i in range(m) for j in range(n), key=lambda x: grid[x[0]][x[1]]):\n            dp[i][j] = 1 + max(\n                dp[i - 1][j] if i - 1 >= 0 and grid[i - 1][j] < grid[i][j] else 0,\n                dp[i + 1][j] if i + 1 < m and grid[i + 1][j] < grid[i][j] else 0,\n                dp[i][j - 1] if j - 1 >= 0 and grid[i][j - 1] < grid[i][j] else 0,\n                dp[i][j + 1] if j + 1 < n and grid[i][j + 1] < grid[i][j] else 0\n            ) % mod\n        return sum(sum(row) for row in dp) % mod\n```", "extracted_code": "\nclass Solution:\n    def countPaths(self, grid):\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[0] * n for _ in range(m)]\n        for i, j in sorted((i, j) for i in range(m) for j in range(n), key=lambda x: grid[x[0]][x[1]]):\n            dp[i][j] = 1 + max(\n                dp[i - 1][j] if i - 1 >= 0 and grid[i - 1][j] < grid[i][j] else 0,\n                dp[i + 1][j] if i + 1 < m and grid[i + 1][j] < grid[i][j] else 0,\n                dp[i][j - 1] if j - 1 >= 0 and grid[i][j - 1] < grid[i][j] else 0,\n                dp[i][j + 1] if j + 1 < n and grid[i][j + 1] < grid[i][j] else 0\n            ) % mod\n        return sum(sum(row) for row in dp) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2322", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, nums, edges):\n        from collections import defaultdict\n        import heapq\n        n = len(nums)\n        xor = [0] * (n + 1)\n        xor[0] = nums[0]\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        for i in range(1, n):\n            xor[i] = xor[i - 1] ^ nums[i]\n        def dfs(node, parent):\n            res = nums[node]\n            for child in graph[node]:\n                if child != parent:\n                    res = max(res, dfs(child, node))\n            return res\n        scores = []\n        for i in range(n):\n            if i not in graph:\n                continue\n            for j in graph[i]:\n                if i < j:\n                    heapq.heappush(scores, dfs(i, j) ^ dfs(j, i))\n        return heapq.heappop(scores)\n```", "extracted_code": "\nclass Solution:\n    def minimumScore(self, nums, edges):\n        from collections import defaultdict\n        import heapq\n        n = len(nums)\n        xor = [0] * (n + 1)\n        xor[0] = nums[0]\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        for i in range(1, n):\n            xor[i] = xor[i - 1] ^ nums[i]\n        def dfs(node, parent):\n            res = nums[node]\n            for child in graph[node]:\n                if child != parent:\n                    res = max(res, dfs(child, node))\n            return res\n        scores = []\n        for i in range(n):\n            if i not in graph:\n                continue\n            for j in graph[i]:\n                if i < j:\n                    heapq.heappush(scores, dfs(i, j) ^ dfs(j, i))\n        return heapq.heappop(scores)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2318", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*6 for _ in range(n+1)]\n        for i in range(6):\n            dp[1][i] = 1\n        for i in range(2, n+1):\n            for j in range(6):\n                for k in range(6):\n                    if j != k and j % 2 != k % 2:\n                        dp[i][j] += dp[i-1][k]\n                if i > 2:\n                    for k in range(6):\n                        if j != k:\n                            dp[i][j] += dp[i-2][k]\n        return sum(dp[n]) % mod\n```", "extracted_code": "\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*6 for _ in range(n+1)]\n        for i in range(6):\n            dp[1][i] = 1\n        for i in range(2, n+1):\n            for j in range(6):\n                for k in range(6):\n                    if j != k and j % 2 != k % 2:\n                        dp[i][j] += dp[i-1][k]\n                if i > 2:\n                    for k in range(6):\n                        if j != k:\n                            dp[i][j] += dp[i-2][k]\n        return sum(dp[n]) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2306", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctNames(self, ideas):\n        idea_set = set(ideas)\n        result = set()\n        for i in range(len(ideas)):\n            for j in range(i + 1, len(ideas)):\n                ideaA, ideaB = list(ideas[i]), list(ideas[j])\n                ideaA[0], ideaB[0] = ideaB[0], ideaA[0]\n                if ''.join(ideaA) not in idea_set and ''.join(ideaB) not in idea_set:\n                    result.add(''.join(ideaA) + ' ' + ''.join(ideaB))\n                    result.add(''.join(ideaB) + ' ' + ''.join(ideaA))\n        return len(result)\n```", "extracted_code": "\nclass Solution:\n    def distinctNames(self, ideas):\n        idea_set = set(ideas)\n        result = set()\n        for i in range(len(ideas)):\n            for j in range(i + 1, len(ideas)):\n                ideaA, ideaB = list(ideas[i]), list(ideas[j])\n                ideaA[0], ideaB[0] = ideaB[0], ideaA[0]\n                if ''.join(ideaA) not in idea_set and ''.join(ideaB) not in idea_set:\n                    result.add(''.join(ideaA) + ' ' + ''.join(ideaB))\n                    result.add(''.join(ideaB) + ' ' + ''.join(ideaA))\n        return len(result)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2302", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            temp_sum = 0\n            for j in range(i, len(nums)):\n                temp_sum += nums[j]\n                if temp_sum * (j - i + 1) < k:\n                    count += 1\n                else:\n                    break\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            temp_sum = 0\n            for j in range(i, len(nums)):\n                temp_sum += nums[j]\n                if temp_sum * (j - i + 1) < k:\n                    count += 1\n                else:\n                    break\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2301", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: [[str]]) -> bool:\n        map_dict = dict(mappings)\n        for i in range(len(sub)):\n            if sub[i] in map_dict:\n                sub = sub[:i] + map_dict[sub[i]] + sub[i+1:]\n        if sub in s:\n            return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: [[str]]) -> bool:\n        map_dict = dict(mappings)\n        for i in range(len(sub)):\n            if sub[i] in map_dict:\n                sub = sub[:i] + map_dict[sub[i]] + sub[i+1:]\n        if sub in s:\n            return True\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2296", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass TextEditor:\n\n    def __init__(self):\n        self.text = \"\"\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        deleted = min(k, self.cursor)\n        self.text = self.text[:self.cursor-deleted] + self.text[self.cursor:]\n        self.cursor -= deleted\n        return deleted\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor = max(self.cursor - k, 0)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor = min(self.cursor + k, len(self.text))\n        return self.text[max(0, self.cursor - 10):self.cursor]\n```", "extracted_code": "\nclass TextEditor:\n\n    def __init__(self):\n        self.text = \"\"\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        deleted = min(k, self.cursor)\n        self.text = self.text[:self.cursor-deleted] + self.text[self.cursor:]\n        self.cursor -= deleted\n        return deleted\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor = max(self.cursor - k, 0)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor = min(self.cursor + k, len(self.text))\n        return self.text[max(0, self.cursor - 10):self.cursor]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2290", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0 if grid[0][0] == 0 else 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n        return dp[-1][-1]\n```", "extracted_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0 if grid[0][0] == 0 else 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n        return dp[-1][-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2286", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass BookMyShow:\n    def __init__(self, n: int, m: int):\n        self.seats = [[0]*m for _ in range(n)]\n        self.n = n\n        self.m = m\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for i in range(min(self.n, maxRow+1)):\n            for j in range(self.m-k+1):\n                if not any(self.seats[i][j:j+k]):\n                    for l in range(j, j+k):\n                        self.seats[i][l] = 1\n                    return [i, j]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        seats_needed = k\n        for i in range(min(self.n, maxRow+1)):\n            for j in range(self.m):\n                if seats_needed == 0:\n                    return True\n                if self.seats[i][j] == 0:\n                    self.seats[i][j] = 1\n                    seats_needed -= 1\n        return seats_needed == 0\n```", "extracted_code": "\nfrom typing import List\n\nclass BookMyShow:\n    def __init__(self, n: int, m: int):\n        self.seats = [[0]*m for _ in range(n)]\n        self.n = n\n        self.m = m\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for i in range(min(self.n, maxRow+1)):\n            for j in range(self.m-k+1):\n                if not any(self.seats[i][j:j+k]):\n                    for l in range(j, j+k):\n                        self.seats[i][l] = 1\n                    return [i, j]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        seats_needed = k\n        for i in range(min(self.n, maxRow+1)):\n            for j in range(self.m):\n                if seats_needed == 0:\n                    return True\n                if self.seats[i][j] == 0:\n                    self.seats[i][j] = 1\n                    seats_needed -= 1\n        return seats_needed == 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2281", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalStrength(self, strength):\n        n = len(strength)\n        left, right = [0]*n, [0]*n\n        stack = []\n        mod = 10**9+7\n        for i in range(n):\n            while stack and strength[stack[-1]] > strength[i]:\n                right[stack.pop()] = i\n            stack.append(i)\n        while stack:\n            right[stack.pop()] = n\n        for i in range(n-1, -1, -1):\n            while stack and strength[stack[-1]] > strength[i]:\n                left[stack.pop()] = i\n            stack.append(i)\n        while stack:\n            left[stack.pop()] = -1\n        return sum((i-left[i])*(right[i]-i)*strength[i] for i in range(n))%mod\n```", "extracted_code": "\nclass Solution:\n    def totalStrength(self, strength):\n        n = len(strength)\n        left, right = [0]*n, [0]*n\n        stack = []\n        mod = 10**9+7\n        for i in range(n):\n            while stack and strength[stack[-1]] > strength[i]:\n                right[stack.pop()] = i\n            stack.append(i)\n        while stack:\n            right[stack.pop()] = n\n        for i in range(n-1, -1, -1):\n            while stack and strength[stack[-1]] > strength[i]:\n                left[stack.pop()] = i\n            stack.append(i)\n        while stack:\n            left[stack.pop()] = -1\n        return sum((i-left[i])*(right[i]-i)*strength[i] for i in range(n))%mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2276", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = set()\n\n    def add(self, left: int, right: int) -> None:\n        for i in range(left, right+1):\n            self.intervals.add(i)\n\n    def count(self) -> int:\n        return len(self.intervals)\n```", "extracted_code": "\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = set()\n\n    def add(self, left: int, right: int) -> None:\n        for i in range(left, right+1):\n            self.intervals.add(i)\n\n    def count(self) -> int:\n        return len(self.intervals)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2272", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        max_var = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                counts = [substring.count(ch) for ch in set(substring)]\n                max_var = max(max_var, max(counts) - min(counts))\n        return max_var\n```", "extracted_code": "\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        max_var = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                counts = [substring.count(ch) for ch in set(substring)]\n                max_var = max(max_var, max(counts) - min(counts))\n        return max_var\n", "difficulty": 3.0}
{"task_id": "LeetCode/2267", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hasValidPath(self, grid: list[list[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n        dp[0][0][0] = dp[0][0][1] = 1 if grid[0][0] == '(' else 0\n        for i in range(m):\n            for j in range(n):\n                if i:\n                    dp[i][j][0] = max(dp[i][j][0], dp[i - 1][j][1] if grid[i][j] == ')' else dp[i - 1][j][0])\n                if j:\n                    dp[i][j][0] = max(dp[i][j][0], dp[i][j - 1][1] if grid[i][j] == ')' else dp[i][j - 1][0])\n                if i < m - 1:\n                    dp[i + 1][j][1] = max(dp[i + 1][j][1], dp[i][j][0] if grid[i + 1][j] == '(' else dp[i][j][1])\n                if j < n - 1:\n                    dp[i][j + 1][1] = max(dp[i][j + 1][1], dp[i][j][0] if grid[i][j + 1] == '(' else dp[i][j][1])\n        return dp[m - 1][n - 1][1] > 0\n```", "extracted_code": "\nclass Solution:\n    def hasValidPath(self, grid: list[list[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n        dp[0][0][0] = dp[0][0][1] = 1 if grid[0][0] == '(' else 0\n        for i in range(m):\n            for j in range(n):\n                if i:\n                    dp[i][j][0] = max(dp[i][j][0], dp[i - 1][j][1] if grid[i][j] == ')' else dp[i - 1][j][0])\n                if j:\n                    dp[i][j][0] = max(dp[i][j][0], dp[i][j - 1][1] if grid[i][j] == ')' else dp[i][j - 1][0])\n                if i < m - 1:\n                    dp[i + 1][j][1] = max(dp[i + 1][j][1], dp[i][j][0] if grid[i + 1][j] == '(' else dp[i][j][1])\n                if j < n - 1:\n                    dp[i][j + 1][1] = max(dp[i][j + 1][1], dp[i][j][0] if grid[i][j + 1] == '(' else dp[i][j][1])\n        return dp[m - 1][n - 1][1] > 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2262", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        total_appeal = 0\n        last = [-1] * 26\n        prev = [0] * len(s)\n        for i in range(len(s)):\n            if i > 0:\n                prev[i] = prev[i-1]\n            last_index = ord(s[i]) - ord('a')\n            if last[last_index] != -1:\n                prev[i] = max(prev[i], last[last_index] + 1)\n            total_appeal += i - prev[i] + 1\n            last[last_index] = i\n        return total_appeal\n```", "extracted_code": "\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        total_appeal = 0\n        last = [-1] * 26\n        prev = [0] * len(s)\n        for i in range(len(s)):\n            if i > 0:\n                prev[i] = prev[i-1]\n            last_index = ord(s[i]) - ord('a')\n            if last[last_index] != -1:\n                prev[i] = max(prev[i], last[last_index] + 1)\n            total_appeal += i - prev[i] + 1\n            last[last_index] = i\n        return total_appeal\n", "difficulty": 3.0}
{"task_id": "LeetCode/2258", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nfrom collections import deque\nimport numpy as np\n\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        fire = np.full((m, n), np.inf)\n        queue = deque()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    fire[i][j] = 0\n                    queue.append((i, j, 0))\n        while queue:\n            x, y, time = queue.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 2 and time + 1 < fire[nx][ny]:\n                    fire[nx][ny] = time + 1\n                    queue.append((nx, ny, time + 1))\n        dist = np.full((m, n), -1)\n        dist[0][0] = 0\n        queue.append((0, 0, 0))\n        while queue:\n            x, y, time = queue.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 2 and time + 1 > dist[nx][ny] and fire[nx][ny] > time + 1:\n                    dist[nx][ny] = time + 1\n                    queue.append((nx, ny, time + 1))\n        if dist[-1][-1] == -1:\n            return -1\n        elif dist[-1][-1] == np.inf:\n            return int(1e9)\n        else:\n            return int(fire[0][0])\n```", "extracted_code": "\nfrom typing import List\nfrom collections import deque\nimport numpy as np\n\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        fire = np.full((m, n), np.inf)\n        queue = deque()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    fire[i][j] = 0\n                    queue.append((i, j, 0))\n        while queue:\n            x, y, time = queue.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 2 and time + 1 < fire[nx][ny]:\n                    fire[nx][ny] = time + 1\n                    queue.append((nx, ny, time + 1))\n        dist = np.full((m, n), -1)\n        dist[0][0] = 0\n        queue.append((0, 0, 0))\n        while queue:\n            x, y, time = queue.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 2 and time + 1 > dist[nx][ny] and fire[nx][ny] > time + 1:\n                    dist[nx][ny] = time + 1\n                    queue.append((nx, ny, time + 1))\n        if dist[-1][-1] == -1:\n            return -1\n        elif dist[-1][-1] == np.inf:\n            return int(1e9)\n        else:\n            return int(fire[0][0])\n", "difficulty": 3.0}
{"task_id": "LeetCode/2251", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def fullBloomFlowers(self, flowers, people):\n        flowers.sort()\n        people = [[time, i] for i, time in enumerate(people)]\n        people.sort()\n        answer = [0]*len(people)\n        j = 0\n        for time, i in people:\n            while j < len(flowers) and flowers[j][0] <= time:\n                if flowers[j][1] >= time:\n                    answer[i] += 1\n                j += 1\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def fullBloomFlowers(self, flowers, people):\n        flowers.sort()\n        people = [[time, i] for i, time in enumerate(people)]\n        people.sort()\n        answer = [0]*len(people)\n        j = 0\n        for time, i in people:\n            while j < len(flowers) and flowers[j][0] <= time:\n                if flowers[j][1] >= time:\n                    answer[i] += 1\n                j += 1\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2246", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestPath(self, parent, s):\n        n = len(parent)\n        adj = [[] for _ in range(n)]\n        for i in range(1, n):\n            adj[parent[i]].append(i)\n            adj[i].append(parent[i])\n        dp = [[0]*26 for _ in range(n)]\n        max_ans = 0\n        def dfs(node, parent):\n            nonlocal max_ans\n            for child in adj[node]:\n                if child == parent:\n                    continue\n                dfs(child, node)\n                for i in range(26):\n                    if chr(i+97) != s[node]:\n                        dp[node][ord(s[child])-97] = max(dp[node][ord(s[child])-97], dp[child][i]+1)\n            max_ans = max(max_ans, max(dp[node]))\n        dfs(0, -1)\n        return max_ans+1\n```", "extracted_code": "\nclass Solution:\n    def longestPath(self, parent, s):\n        n = len(parent)\n        adj = [[] for _ in range(n)]\n        for i in range(1, n):\n            adj[parent[i]].append(i)\n            adj[i].append(parent[i])\n        dp = [[0]*26 for _ in range(n)]\n        max_ans = 0\n        def dfs(node, parent):\n            nonlocal max_ans\n            for child in adj[node]:\n                if child == parent:\n                    continue\n                dfs(child, node)\n                for i in range(26):\n                    if chr(i+97) != s[node]:\n                        dp[node][ord(s[child])-97] = max(dp[node][ord(s[child])-97], dp[child][i]+1)\n            max_ans = max(max_ans, max(dp[node]))\n        dfs(0, -1)\n        return max_ans+1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2242", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        n = len(scores)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        maxScore = -1\n        for i in range(n):\n            for j in graph[i]:\n                for k in graph[j]:\n                    if k == i: continue\n                    for l in graph[k]:\n                        if l == i or l == j: continue\n                        maxScore = max(maxScore, scores[i] + scores[j] + scores[k] + scores[l])\n        return maxScore\n```", "extracted_code": "\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        n = len(scores)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        maxScore = -1\n        for i in range(n):\n            for j in graph[i]:\n                for k in graph[j]:\n                    if k == i: continue\n                    for l in graph[k]:\n                        if l == i or l == j: continue\n                        maxScore = max(maxScore, scores[i] + scores[j] + scores[k] + scores[l])\n        return maxScore\n", "difficulty": 3.0}
{"task_id": "LeetCode/2234", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\n        flowers.sort()\n        complete = 0\n        for i in range(len(flowers)):\n            if flowers[i] < target:\n                required = target - flowers[i]\n                if newFlowers >= required:\n                    newFlowers -= required\n                    flowers[i] += required\n                else:\n                    flowers[i] += newFlowers\n                    newFlowers = 0\n            if flowers[i] >= target:\n                complete += 1\n        total_beauty = complete * full\n        if complete < len(flowers):\n            total_beauty += min(flowers) * partial\n        return total_beauty\n```", "extracted_code": "\nclass Solution:\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\n        flowers.sort()\n        complete = 0\n        for i in range(len(flowers)):\n            if flowers[i] < target:\n                required = target - flowers[i]\n                if newFlowers >= required:\n                    newFlowers -= required\n                    flowers[i] += required\n                else:\n                    flowers[i] += newFlowers\n                    newFlowers = 0\n            if flowers[i] >= target:\n                complete += 1\n        total_beauty = complete * full\n        if complete < len(flowers):\n            total_beauty += min(flowers) * partial\n        return total_beauty\n", "difficulty": 3.0}
{"task_id": "LeetCode/2223", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        prefix_suffix = [0] * n\n        total = 0\n        length = 0 \n        for i in range(1, n):\n            if prefix_suffix[i-length-1] < length + 1:\n                length = prefix_suffix[i-length-1]\n            while i + length < n and s[length] == s[i + length]:\n                length += 1\n            prefix_suffix[i] = length\n            total += length\n            if length > 0:\n                length -= 1\n        return total + n\n```", "extracted_code": "\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        prefix_suffix = [0] * n\n        total = 0\n        length = 0 \n        for i in range(1, n):\n            if prefix_suffix[i-length-1] < length + 1:\n                length = prefix_suffix[i-length-1]\n            while i + length < n and s[length] == s[i + length]:\n                length += 1\n            prefix_suffix[i] = length\n            total += length\n            if length > 0:\n                length -= 1\n        return total + n\n", "difficulty": 3.0}
