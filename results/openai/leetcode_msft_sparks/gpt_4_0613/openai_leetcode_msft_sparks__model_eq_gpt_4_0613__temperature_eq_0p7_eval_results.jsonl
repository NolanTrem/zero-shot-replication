{"task_id": "LeetCode/2532", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: [[int]]) -> int:\n        import heapq\n        workers = sorted([(t[0] + t[2], i, t) for i, t in enumerate(time)])\n        heap = [(t[0] + t[1] + t[3], i, t) for _, i, t in workers[:n]]\n        heapq.heapify(heap)\n        for _, i, t in workers[n:]:\n            if heap[0][0] > t[0]:\n                _, _, old_t = heapq.heappushpop(heap, (heap[0][0] + t[0] + t[1] + t[3] - old_t[0], i, t))\n        return max(heap[0][0] - heap[0][2][3], max(t[0] for _, i, t in workers))\n```", "extracted_code": "\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: [[int]]) -> int:\n        import heapq\n        workers = sorted([(t[0] + t[2], i, t) for i, t in enumerate(time)])\n        heap = [(t[0] + t[1] + t[3], i, t) for _, i, t in workers[:n]]\n        heapq.heapify(heap)\n        for _, i, t in workers[n:]:\n            if heap[0][0] > t[0]:\n                _, _, old_t = heapq.heappushpop(heap, (heap[0][0] + t[0] + t[1] + t[3] - old_t[0], i, t))\n        return max(heap[0][0] - heap[0][2][3], max(t[0] for _, i, t in workers))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2531", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        distinct_char_word1 = set(word1)\n        distinct_char_word2 = set(word2)\n\n        if abs(len(distinct_char_word1) - len(distinct_char_word2)) > 1:\n            return False\n        elif len(distinct_char_word1) == len(distinct_char_word2):\n            return True\n        else:\n            if len(distinct_char_word1) > len(distinct_char_word2):\n                bigger_set, smaller_set = distinct_char_word1, distinct_char_word2\n            else:\n                bigger_set, smaller_set = distinct_char_word2, distinct_char_word1\n\n            for char in bigger_set:\n                if char not in smaller_set:\n                    return True\n\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        distinct_char_word1 = set(word1)\n        distinct_char_word2 = set(word2)\n\n        if abs(len(distinct_char_word1) - len(distinct_char_word2)) > 1:\n            return False\n        elif len(distinct_char_word1) == len(distinct_char_word2):\n            return True\n        else:\n            if len(distinct_char_word1) > len(distinct_char_word2):\n                bigger_set, smaller_set = distinct_char_word1, distinct_char_word2\n            else:\n                bigger_set, smaller_set = distinct_char_word2, distinct_char_word1\n\n            for char in bigger_set:\n                if char not in smaller_set:\n                    return True\n\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2530", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\n\nclass Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        score = 0\n        nums = [-num for num in nums]\n        heapq.heapify(nums)\n        for _ in range(k):\n            max_num = -heapq.heappop(nums)\n            score += max_num\n            heapq.heappush(nums, -(-max_num // 3))\n        return score\n```", "extracted_code": "\nimport heapq\n\nclass Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        score = 0\n        nums = [-num for num in nums]\n        heapq.heapify(nums)\n        for _ in range(k):\n            max_num = -heapq.heappop(nums)\n            score += max_num\n            heapq.heappush(nums, -(-max_num // 3))\n        return score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2529", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "Here is the Python code that solves the problem:\n\n```python\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        neg = len([i for i in nums if i < 0])\n        pos = len([i for i in nums if i > 0])\n        return max(neg, pos)\n```\n\nThis function counts the number of negative and positive integers in the given list 'nums' and returns the maximum count between them. This code runs in linear time complexity, O(n), where n is the length of 'nums'.", "extracted_code": "\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        neg = len([i for i in nums if i < 0])\n        pos = len([i for i in nums if i > 0])\n        return max(neg, pos)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2528", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPower(self, stations, r, k):\n        n = len(stations)\n        prefix = [0] * (n + r + 1)\n        for i in range(n):\n            prefix[i + r + 1] = prefix[i + r] + stations[i]\n        powers = prefix[r:n + r + 1]\n        left = [0] * n\n        for i in range(r, n):\n            left[i] = max(left[i - 1], powers[i - r])\n        right = [0] * n\n        for i in range(n - r - 1, -1, -1):\n            right[i] = max(right[i + 1], powers[i + r + 1])\n        low = 0\n        high = 10 ** 5 + k + 1\n        while low < high:\n            mid = low + ((high - low) >> 1)\n            check = False\n            j = 0\n            for i in range(n):\n                while j < n and max(left[j], powers[i], right[j + 1]) < mid:\n                    j += 1\n                if j == n:\n                    break\n                used = max(0, (mid - max(left[j], powers[i])) + r)\n                if used <= k:\n                    check = True\n                    break\n                j += r + 1\n            if check:\n                low = mid + 1\n            else:\n                high = mid\n        return high - 1\n```", "extracted_code": "\nclass Solution:\n    def maxPower(self, stations, r, k):\n        n = len(stations)\n        prefix = [0] * (n + r + 1)\n        for i in range(n):\n            prefix[i + r + 1] = prefix[i + r] + stations[i]\n        powers = prefix[r:n + r + 1]\n        left = [0] * n\n        for i in range(r, n):\n            left[i] = max(left[i - 1], powers[i - r])\n        right = [0] * n\n        for i in range(n - r - 1, -1, -1):\n            right[i] = max(right[i + 1], powers[i + r + 1])\n        low = 0\n        high = 10 ** 5 + k + 1\n        while low < high:\n            mid = low + ((high - low) >> 1)\n            check = False\n            j = 0\n            for i in range(n):\n                while j < n and max(left[j], powers[i], right[j + 1]) < mid:\n                    j += 1\n                if j == n:\n                    break\n                used = max(0, (mid - max(left[j], powers[i])) + r)\n                if used <= k:\n                    check = True\n                    break\n                j += r + 1\n            if check:\n                low = mid + 1\n            else:\n                high = mid\n        return high - 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2527", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def xorBeauty(self, nums: List[int]) -> int:\n        xor = 0\n        for i in range(30):\n            count = sum(((num >> i) & 1) for num in nums)\n            xor += (count * (len(nums) - count) * (1 << i))\n        return xor % (10**9 + 7)\n```", "extracted_code": "\nclass Solution:\n    def xorBeauty(self, nums: List[int]) -> int:\n        xor = 0\n        for i in range(30):\n            count = sum(((num >> i) & 1) for num in nums)\n            xor += (count * (len(nums) - count) * (1 << i))\n        return xor % (10**9 + 7)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2526", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import deque\n\nclass DataStream:\n\n    def __init__(self, value: int, k: int):\n        self.value = value\n        self.k = k\n        self.stream = deque()\n\n    def consec(self, num: int) -> bool:\n        self.stream.append(num)\n        if len(self.stream) > self.k:\n            self.stream.popleft()\n        return len(self.stream) == self.k and all(x == self.value for x in self.stream)\n```", "extracted_code": "\nfrom collections import deque\n\nclass DataStream:\n\n    def __init__(self, value: int, k: int):\n        self.value = value\n        self.k = k\n        self.stream = deque()\n\n    def consec(self, num: int) -> bool:\n        self.stream.append(num)\n        if len(self.stream) > self.k:\n            self.stream.popleft()\n        return len(self.stream) == self.k and all(x == self.value for x in self.stream)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2525", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        volume = length * width * height\n        bulky = (length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9)\n        heavy = (mass >= 100)\n        if bulky and heavy:\n            return \"Both\"\n        elif bulky:\n            return \"Bulky\"\n        elif heavy:\n            return \"Heavy\"\n        else:\n            return \"Neither\"\n```", "extracted_code": "\nclass Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        volume = length * width * height\n        bulky = (length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9)\n        heavy = (mass >= 100)\n        if bulky and heavy:\n            return \"Both\"\n        elif bulky:\n            return \"Bulky\"\n        elif heavy:\n            return \"Heavy\"\n        else:\n            return \"Neither\"\n", "difficulty": 1.0}
{"task_id": "LeetCode/2523", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> list[int]:\n        def is_prime(num):\n            if num < 2: return False\n            for i in range(2, int(num**0.5)+1):\n                if num % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right+1) if is_prime(i)]\n        if len(primes) < 2: return [-1, -1]\n\n        min_diff = float('inf')\n        res = [-1, -1]\n        for i in range(1, len(primes)):\n            if primes[i] - primes[i-1] < min_diff:\n                min_diff = primes[i] - primes[i-1]\n                res = [primes[i-1], primes[i]]\n        return res\n```", "extracted_code": "\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> list[int]:\n        def is_prime(num):\n            if num < 2: return False\n            for i in range(2, int(num**0.5)+1):\n                if num % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right+1) if is_prime(i)]\n        if len(primes) < 2: return [-1, -1]\n\n        min_diff = float('inf')\n        res = [-1, -1]\n        for i in range(1, len(primes)):\n            if primes[i] - primes[i-1] < min_diff:\n                min_diff = primes[i] - primes[i-1]\n                res = [primes[i-1], primes[i]]\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2521", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        prime_factors = set()\n        for num in nums:\n            i = 2\n            while i * i <= num:\n                if num % i:\n                    i += 1\n                else:\n                    num //= i\n                    prime_factors.add(i)\n            if num > 1:\n                prime_factors.add(num)\n        return len(prime_factors)\n```", "extracted_code": "\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        prime_factors = set()\n        for num in nums:\n            i = 2\n            while i * i <= num:\n                if num % i:\n                    i += 1\n                else:\n                    num //= i\n                    prime_factors.add(i)\n            if num > 1:\n                prime_factors.add(num)\n        return len(prime_factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2520", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDigits(self, num: int) -> int:\n        return sum(1 for i in str(num) if num % int(i) == 0)\n```", "extracted_code": "\nclass Solution:\n    def countDigits(self, num: int) -> int:\n        return sum(1 for i in str(num) if num % int(i) == 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2518", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        prefix_sum = [0]*(n+1)\n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + nums[i]\n        power = [1]*(n+1)\n        for i in range(1,n+1):\n            power[i] = power[i-1] * 2 % MOD\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1,n+1):\n            dp[i] = dp[i-1]*2 % MOD\n            j = 0\n            while i-j-1 >= 0 and prefix_sum[i] - prefix_sum[i-j-1] < k:\n                dp[i] = (dp[i] - dp[i-j-1] + MOD) % MOD\n                j += 1\n        return dp[-1]\n```", "extracted_code": "\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        prefix_sum = [0]*(n+1)\n        for i in range(n):\n            prefix_sum[i+1] = prefix_sum[i] + nums[i]\n        power = [1]*(n+1)\n        for i in range(1,n+1):\n            power[i] = power[i-1] * 2 % MOD\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1,n+1):\n            dp[i] = dp[i-1]*2 % MOD\n            j = 0\n            while i-j-1 >= 0 and prefix_sum[i] - prefix_sum[i-j-1] < k:\n                dp[i] = (dp[i] - dp[i-j-1] + MOD) % MOD\n                j += 1\n        return dp[-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2517", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        l = 0\n        r = len(price) - 1\n        maxTastiness = float(\"-inf\")\n        while r - l + 1 > k:\n            maxTastiness = max(maxTastiness, price[r] - price[l])\n            if price[r] - price[l + 1] > price[r - 1] - price[l]:\n                l += 1\n            else:\n                r -= 1\n        for i in range(l + 1, r + 1):\n            maxTastiness = max(maxTastiness, price[i] - price[i - 1])\n        return maxTastiness\n```", "extracted_code": "\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        l = 0\n        r = len(price) - 1\n        maxTastiness = float(\"-inf\")\n        while r - l + 1 > k:\n            maxTastiness = max(maxTastiness, price[r] - price[l])\n            if price[r] - price[l + 1] > price[r - 1] - price[l]:\n                l += 1\n            else:\n                r -= 1\n        for i in range(l + 1, r + 1):\n            maxTastiness = max(maxTastiness, price[i] - price[i - 1])\n        return maxTastiness\n", "difficulty": 2.0}
{"task_id": "LeetCode/2516", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        if s.count('a') < k or s.count('b') < k or s.count('c') < k:\n            return -1\n        left, right = 0, len(s) - 1\n        count = {'a': 0, 'b': 0, 'c': 0}\n        while count['a'] < k or count['b'] < k or count['c'] < k:\n            if s[left] in count and count[s[left]] < k:\n                count[s[left]] += 1\n                left += 1\n            elif s[right] in count and count[s[right]] < k:\n                count[s[right]] += 1\n                right -= 1\n        return max(left, len(s) - 1 - right)\n```", "extracted_code": "\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        if s.count('a') < k or s.count('b') < k or s.count('c') < k:\n            return -1\n        left, right = 0, len(s) - 1\n        count = {'a': 0, 'b': 0, 'c': 0}\n        while count['a'] < k or count['b'] < k or count['c'] < k:\n            if s[left] in count and count[s[left]] < k:\n                count[s[left]] += 1\n                left += 1\n            elif s[right] in count and count[s[right]] < k:\n                count[s[right]] += 1\n                right -= 1\n        return max(left, len(s) - 1 - right)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2515", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closetTarget(self, words, target, startIndex):\n        n = len(words)\n        if target not in words:\n            return -1\n        else:\n            forward = (i for i in range(startIndex, startIndex + n) if words[i % n] == target)\n            backward = (n - i for i in range(startIndex, startIndex - n, -1) if words[i % n] == target)\n            return min(next(forward), next(backward))\n```", "extracted_code": "\nclass Solution:\n    def closetTarget(self, words, target, startIndex):\n        n = len(words)\n        if target not in words:\n            return -1\n        else:\n            forward = (i for i in range(startIndex, startIndex + n) if words[i % n] == target)\n            backward = (n - i for i in range(startIndex, startIndex - n, -1) if words[i % n] == target)\n            return min(next(forward), next(backward))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2514", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from math import factorial\n        from collections import Counter\n        mod = 10**9 + 7\n\n        words = s.split()\n        res = 1\n        for word in words:\n            count = Counter(word)\n            total = factorial(len(word))\n            for c in count:\n                total //= factorial(count[c])\n            res = (res * total) % mod\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from math import factorial\n        from collections import Counter\n        mod = 10**9 + 7\n\n        words = s.split()\n        res = 1\n        for word in words:\n            count = Counter(word)\n            total = factorial(len(word))\n            for c in count:\n                total //= factorial(count[c])\n            res = (res * total) % mod\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2513", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        if divisor1 > divisor2:\n            divisor1, divisor2, uniqueCnt1, uniqueCnt2 = divisor2, divisor1, uniqueCnt2, uniqueCnt1\n        low, high = 1, 10**18\n        while low < high:\n            mid = (low + high) // 2\n            if mid // divisor1 < uniqueCnt1 or mid - mid // divisor1 - mid // divisor2 + mid // (divisor1*divisor2) < uniqueCnt2:\n                low = mid + 1\n            else:\n                high = mid\n        return high\n```", "extracted_code": "\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        if divisor1 > divisor2:\n            divisor1, divisor2, uniqueCnt1, uniqueCnt2 = divisor2, divisor1, uniqueCnt2, uniqueCnt1\n        low, high = 1, 10**18\n        while low < high:\n            mid = (low + high) // 2\n            if mid // divisor1 < uniqueCnt1 or mid - mid // divisor1 - mid // divisor2 + mid // (divisor1*divisor2) < uniqueCnt2:\n                low = mid + 1\n            else:\n                high = mid\n        return high\n", "difficulty": 2.0}
{"task_id": "LeetCode/2512", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        student_points = {id: 0 for id in student_id}\n        for i in range(len(report)):\n            words = report[i].split()\n            for word in words:\n                if word in positive_feedback:\n                    student_points[student_id[i]] += 3\n                elif word in negative_feedback:\n                    student_points[student_id[i]] -= 1\n\n        sorted_students = sorted(student_points.items(), key=lambda item: (-item[1], item[0]))\n        return [student[0] for student in sorted_students[:k]]\n```", "extracted_code": "\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        student_points = {id: 0 for id in student_id}\n        for i in range(len(report)):\n            words = report[i].split()\n            for word in words:\n                if word in positive_feedback:\n                    student_points[student_id[i]] += 3\n                elif word in negative_feedback:\n                    student_points[student_id[i]] -= 1\n\n        sorted_students = sorted(student_points.items(), key=lambda item: (-item[1], item[0]))\n        return [student[0] for student in sorted_students[:k]]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2511", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def captureForts(self, forts: list[int]) -> int:\n        own_forts = [i for i, fort in enumerate(forts) if fort == 1]\n        max_captures = 0\n        for i in own_forts:\n            for j in range(i+1, len(forts)):\n                if forts[j] == 1:\n                    if all(fort == 0 for fort in forts[i+1:j]):\n                        max_captures = max(max_captures, j-i-1)\n        return max_captures\n```", "extracted_code": "\nclass Solution:\n    def captureForts(self, forts: list[int]) -> int:\n        own_forts = [i for i, fort in enumerate(forts) if fort == 1]\n        max_captures = 0\n        for i in own_forts:\n            for j in range(i+1, len(forts)):\n                if forts[j] == 1:\n                    if all(fort == 0 for fort in forts[i+1:j]):\n                        max_captures = max(max_captures, j-i-1)\n        return max_captures\n", "difficulty": 1.0}
{"task_id": "LeetCode/2509", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_depth(val):\n            depth = 0\n            while val != 1:\n                depth += 1\n                val //= 2\n            return depth\n\n        results = []\n        for query in queries:\n            d1 = find_depth(query[0])\n            d2 = find_depth(query[1])\n            lca_depth = find_depth(query[0] if d1 < d2 else query[1])\n            results.append(d1 + d2 - 2 * lca_depth + 1)\n        return results\n```", "extracted_code": "\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_depth(val):\n            depth = 0\n            while val != 1:\n                depth += 1\n                val //= 2\n            return depth\n\n        results = []\n        for query in queries:\n            d1 = find_depth(query[0])\n            d2 = find_depth(query[1])\n            lca_depth = find_depth(query[0] if d1 < d2 else query[1])\n            results.append(d1 + d2 - 2 * lca_depth + 1)\n        return results\n", "difficulty": 3.0}
{"task_id": "LeetCode/2508", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for a, b in edges:\n            degree[a] += 1\n            degree[b] += 1\n        odd_degree_nodes = [node for node in range(1, n + 1) if degree[node] % 2 == 1]\n        if len(odd_degree_nodes) > 4:\n            return False\n        elif len(odd_degree_nodes) == 4:\n            return degree[odd_degree_nodes[0]] > 1 and degree[odd_degree_nodes[1]] > 1\n        else:\n            return True\n```", "extracted_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for a, b in edges:\n            degree[a] += 1\n            degree[b] += 1\n        odd_degree_nodes = [node for node in range(1, n + 1) if degree[node] % 2 == 1]\n        if len(odd_degree_nodes) > 4:\n            return False\n        elif len(odd_degree_nodes) == 4:\n            return degree[odd_degree_nodes[0]] > 1 and degree[odd_degree_nodes[1]] > 1\n        else:\n            return True\n", "difficulty": 3.0}
{"task_id": "LeetCode/2507", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def primeFactors(n):\n            factors = []\n            i = 2\n            while n > 1:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            return factors\n\n        while True:\n            factors = primeFactors(n)\n            if len(factors) == 1:\n                return factors[0]\n            n = sum(factors)\n```", "extracted_code": "\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def primeFactors(n):\n            factors = []\n            i = 2\n            while n > 1:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            return factors\n\n        while True:\n            factors = primeFactors(n)\n            if len(factors) == 1:\n                return factors[0]\n            n = sum(factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2506", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def similarPairs(self, words: list[str]) -> int:\n        def similar(w1, w2):\n            return set(w1) == set(w2)\n\n        return sum(similar(words[i], words[j]) for i in range(len(words)) for j in range(i+1, len(words)))\n```", "extracted_code": "\nclass Solution:\n    def similarPairs(self, words: list[str]) -> int:\n        def similar(w1, w2):\n            return set(w1) == set(w2)\n\n        return sum(similar(words[i], words[j]) for i in range(len(words)) for j in range(i+1, len(words)))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2503", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        m, n = len(grid), len(grid[0])\n        sortedGrid = sorted([(i, j) for i in range(m) for j in range(n)], key=lambda x: -grid[x[0]][x[1]])\n        prefix_max = [0] * len(sortedGrid)\n        prefix_max[0] = grid[sortedGrid[0][0]][sortedGrid[0][1]]\n        for i in range(1, len(sortedGrid)):\n            prefix_max[i] = max(prefix_max[i-1], grid[sortedGrid[i][0]][sortedGrid[i][1]])\n\n        def bfs(query):\n            visited = [[0] * n for _ in range(m)]\n            visited[0][0] = 1\n            q = [(0, 0)]\n            ans = 0\n            while q:\n                x, y = q.pop(0)\n                if grid[x][y] > query:\n                    ans += 1\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                            visited[nx][ny] = 1\n                            q.append((nx, ny))\n            return ans\n\n        res = []\n        for query in queries:\n            l, r = 0, len(sortedGrid)\n            while l < r:\n                mid = l + (r - l) // 2\n                if grid[sortedGrid[mid][0]][sortedGrid[mid][1]] > query:\n                    l = mid + 1\n                else:\n                    r = mid\n            if l == 0:\n                res.append(bfs(query))\n            else:\n                res.append(max(bfs(query), prefix_max[l - 1]))\n        return res\n```", "extracted_code": "\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        m, n = len(grid), len(grid[0])\n        sortedGrid = sorted([(i, j) for i in range(m) for j in range(n)], key=lambda x: -grid[x[0]][x[1]])\n        prefix_max = [0] * len(sortedGrid)\n        prefix_max[0] = grid[sortedGrid[0][0]][sortedGrid[0][1]]\n        for i in range(1, len(sortedGrid)):\n            prefix_max[i] = max(prefix_max[i-1], grid[sortedGrid[i][0]][sortedGrid[i][1]])\n\n        def bfs(query):\n            visited = [[0] * n for _ in range(m)]\n            visited[0][0] = 1\n            q = [(0, 0)]\n            ans = 0\n            while q:\n                x, y = q.pop(0)\n                if grid[x][y] > query:\n                    ans += 1\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                            visited[nx][ny] = 1\n                            q.append((nx, ny))\n            return ans\n\n        res = []\n        for query in queries:\n            l, r = 0, len(sortedGrid)\n            while l < r:\n                mid = l + (r - l) // 2\n                if grid[sortedGrid[mid][0]][sortedGrid[mid][1]] > query:\n                    l = mid + 1\n                else:\n                    r = mid\n            if l == 0:\n                res.append(bfs(query))\n            else:\n                res.append(max(bfs(query), prefix_max[l - 1]))\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2502", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Allocator:\n\n    def __init__(self, n: int):\n        self.mem = [0] * n\n        self.blocks = {}\n\n    def allocate(self, size: int, mID: int) -> int:\n        start = -1\n        for i in range(len(self.mem)):\n            if self.mem[i] == 0:\n                if start == -1:\n                    start = i\n                if i - start + 1 == size:\n                    self.mem[start:i+1] = [mID] * size\n                    if mID in self.blocks:\n                        self.blocks[mID].append((start, i))\n                    else:\n                        self.blocks[mID] = [(start, i)]\n                    return start\n            else:\n                start = -1\n        return -1\n\n    def free(self, mID: int) -> int:\n        if mID not in self.blocks:\n            return 0\n        freed = 0\n        for start, end in self.blocks[mID]:\n            self.mem[start:end+1] = [0] * (end - start + 1)\n            freed += end - start + 1\n        del self.blocks[mID]\n        return freed\n```", "extracted_code": "\nclass Allocator:\n\n    def __init__(self, n: int):\n        self.mem = [0] * n\n        self.blocks = {}\n\n    def allocate(self, size: int, mID: int) -> int:\n        start = -1\n        for i in range(len(self.mem)):\n            if self.mem[i] == 0:\n                if start == -1:\n                    start = i\n                if i - start + 1 == size:\n                    self.mem[start:i+1] = [mID] * size\n                    if mID in self.blocks:\n                        self.blocks[mID].append((start, i))\n                    else:\n                        self.blocks[mID] = [(start, i)]\n                    return start\n            else:\n                start = -1\n        return -1\n\n    def free(self, mID: int) -> int:\n        if mID not in self.blocks:\n            return 0\n        freed = 0\n        for start, end in self.blocks[mID]:\n            self.mem[start:end+1] = [0] * (end - start + 1)\n            freed += end - start + 1\n        del self.blocks[mID]\n        return freed\n", "difficulty": 2.0}
{"task_id": "LeetCode/2501", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSquareStreak(self, nums):\n        nums.sort()\n        dp = [0] * len(nums)\n        max_streak = -1\n        for i in range(len(nums)):\n            j = i - 1\n            while j >= 0:\n                if nums[j]**2 == nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n                elif nums[j]**2 > nums[i]:\n                    break\n                j -= 1\n            max_streak = max(max_streak, dp[i])\n        return max_streak if max_streak > 0 else -1\n```\nThis solution sorts the input list first. Then it uses a dynamic programming approach where `dp[i]` represents the longest square streak ending at index `i`. For each index `i`, it iterates over all previous elements `j` in the list. If `nums[j]**2 == nums[i]`, it means that `nums[i]` can be an extension of the square streak ending at `j`, so it updates `dp[i]` with `dp[j] + 1` if it's greater than the current `dp[i]`. If `nums[j]**2 > nums[i]`, it breaks the loop because there can't be a square streak ending at `i` with a previous element `j` (since the list is sorted). Finally, it updates the `max_streak` with `dp[i]` if it's greater than the current `max_streak`. The function returns `max_streak` if it's greater than `0`, otherwise it returns `-1` to indicate that there is no square streak.", "extracted_code": "\nclass Solution:\n    def longestSquareStreak(self, nums):\n        nums.sort()\n        dp = [0] * len(nums)\n        max_streak = -1\n        for i in range(len(nums)):\n            j = i - 1\n            while j >= 0:\n                if nums[j]**2 == nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n                elif nums[j]**2 > nums[i]:\n                    break\n                j -= 1\n            max_streak = max(max_streak, dp[i])\n        return max_streak if max_streak > 0 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2500", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        answer = 0\n        while grid:\n            max_elements = [max(row) for row in grid]\n            max_value = max(max_elements)\n            answer += max_value\n            for row in grid:\n                if max_value in row:\n                    row.remove(max_value)\n            grid = [row for row in grid if row]\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        answer = 0\n        while grid:\n            max_elements = [max(row) for row in grid]\n            max_value = max(max_elements)\n            answer += max_value\n            for row in grid:\n                if max_value in row:\n                    row.remove(max_value)\n            grid = [row for row in grid if row]\n        return answer\n", "difficulty": 1.0}
{"task_id": "LeetCode/2499", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        indices = [set() for _ in range(n + 1)]\n        costs = [0] * (n + 1)\n        swaps = [0] * (n + 1)\n        min_val = [n + 1] * (n + 1)\n\n        for i in range(n):\n            if nums1[i] == nums2[i]:\n                continue\n            indices[nums1[i]].add(nums2[i])\n            costs[nums1[i]] += i\n            swaps[nums1[i]] += 1\n            min_val[nums1[i]] = min(min_val[nums1[i]], i)\n\n        total_cost = 0\n        for i in range(1, n + 1):\n            if swaps[i] == 0:\n                continue\n            if len(indices[i]) > 1 or next(iter(indices[i])) != i:\n                total_cost += costs[i]\n            else:\n                total_cost += min(costs[i] - min_val[i] + min(min_val[:i] + min_val[i + 1:], default=0), costs[i])\n\n        return total_cost if total_cost > 0 else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        indices = [set() for _ in range(n + 1)]\n        costs = [0] * (n + 1)\n        swaps = [0] * (n + 1)\n        min_val = [n + 1] * (n + 1)\n\n        for i in range(n):\n            if nums1[i] == nums2[i]:\n                continue\n            indices[nums1[i]].add(nums2[i])\n            costs[nums1[i]] += i\n            swaps[nums1[i]] += 1\n            min_val[nums1[i]] = min(min_val[nums1[i]], i)\n\n        total_cost = 0\n        for i in range(1, n + 1):\n            if swaps[i] == 0:\n                continue\n            if len(indices[i]) > 1 or next(iter(indices[i])) != i:\n                total_cost += costs[i]\n            else:\n                total_cost += min(costs[i] - min_val[i] + min(min_val[:i] + min_val[i + 1:], default=0), costs[i])\n\n        return total_cost if total_cost > 0 else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2498", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        left, right = 0, stones[-1]\n        while left < right:\n            mid = (left + right) // 2\n            if self.check(mid, stones):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    def check(self, mid, stones):\n        dp = [0] * len(stones)\n        dp[0] = 1\n        for i in range(1, len(stones)):\n            dp[i] = max(dp[j] for j in range(i) if abs(stones[j] - stones[i]) <= mid) or 0\n        return dp[-1] == 1\n```", "extracted_code": "\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        left, right = 0, stones[-1]\n        while left < right:\n            mid = (left + right) // 2\n            if self.check(mid, stones):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    def check(self, mid, stones):\n        dp = [0] * len(stones)\n        dp[0] = 1\n        for i in range(1, len(stones)):\n            dp[i] = max(dp[j] for j in range(i) if abs(stones[j] - stones[i]) <= mid) or 0\n        return dp[-1] == 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2497", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nfrom collections import defaultdict\nimport heapq\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append((vals[v], v))\n            graph[v].append((vals[u], u))\n        max_star_sum = max(vals)\n        for u in range(len(vals)):\n            graph[u].sort(reverse=True)\n            star_sum = vals[u]\n            for i in range(min(k, len(graph[u]))):\n                star_sum += graph[u][i][0]\n            max_star_sum = max(max_star_sum, star_sum)\n        return max_star_sum\n```", "extracted_code": "\nfrom typing import List\nfrom collections import defaultdict\nimport heapq\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append((vals[v], v))\n            graph[v].append((vals[u], u))\n        max_star_sum = max(vals)\n        for u in range(len(vals)):\n            graph[u].sort(reverse=True)\n            star_sum = vals[u]\n            for i in range(min(k, len(graph[u]))):\n                star_sum += graph[u][i][0]\n            max_star_sum = max(max_star_sum, star_sum)\n        return max_star_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2496", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumValue(self, strs: List[str]) -> int:\n        return max(int(s) if s.isdigit() else len(s) for s in strs)\n```", "extracted_code": "\nclass Solution:\n    def maximumValue(self, strs: List[str]) -> int:\n        return max(int(s) if s.isdigit() else len(s) for s in strs)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2482", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def onesMinusZeros(self, grid):\n        m, n = len(grid), len(grid[0])\n        onesRow, onesCol = [0]*m, [0]*n\n        zerosRow, zerosCol = [0]*m, [0]*n\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    onesRow[i] += 1\n                    onesCol[j] += 1\n                else:\n                    zerosRow[i] += 1\n                    zerosCol[j] += 1\n        \n        diff = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]\n        \n        return diff\n```", "extracted_code": "\nclass Solution:\n    def onesMinusZeros(self, grid):\n        m, n = len(grid), len(grid[0])\n        onesRow, onesCol = [0]*m, [0]*n\n        zerosRow, zerosCol = [0]*m, [0]*n\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    onesRow[i] += 1\n                    onesCol[j] += 1\n                else:\n                    zerosRow[i] += 1\n                    zerosCol[j] += 1\n        \n        diff = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]\n        \n        return diff\n", "difficulty": 2.0}
{"task_id": "LeetCode/2522", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        max_digit = max(int(d) for d in s)\n        if max_digit > k:\n            return -1\n        res, curr = 0, 0\n        for d in s:\n            if curr * 10 + int(d) > k:\n                res += 1\n                curr = int(d)\n            else:\n                curr = curr * 10 + int(d)\n        return res + 1\n```", "extracted_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        max_digit = max(int(d) for d in s)\n        if max_digit > k:\n            return -1\n        res, curr = 0, 0\n        for d in s:\n            if curr * 10 + int(d) > k:\n                res += 1\n                curr = int(d)\n            else:\n                curr = curr * 10 + int(d)\n        return res + 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2493", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        color = [0] * (n + 1)\n        queue = collections.deque()\n        for i in range(1, n + 1):\n            if color[i] == 0:\n                color[i] = 1\n                queue.append(i)\n                while queue:\n                    u = queue.popleft()\n                    for v in graph[u]:\n                        if color[v] == 0:\n                            color[v] = 3 - color[u]\n                            queue.append(v)\n                        elif color[v] == color[u]:\n                            return -1\n        return max(color)\n```", "extracted_code": "\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n        color = [0] * (n + 1)\n        queue = collections.deque()\n        for i in range(1, n + 1):\n            if color[i] == 0:\n                color[i] = 1\n                queue.append(i)\n                while queue:\n                    u = queue.popleft()\n                    for v in graph[u]:\n                        if color[v] == 0:\n                            color[v] = 3 - color[u]\n                            queue.append(v)\n                        elif color[v] == color[u]:\n                            return -1\n        return max(color)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2492", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\n        graph = [[] for _ in range(n+1)]\n        for u, v, w in roads:\n            graph[u].append((w, v))\n            graph[v].append((w, u))\n        \n        dist = [0] + [float('-inf')]*n\n        heap = [(-dist[1], 1)]\n        while heap:\n            d, u = heapq.heappop(heap)\n            if -d != dist[u]: continue\n            for w, v in graph[u]:\n                if min(dist[u], w) > dist[v]:\n                    dist[v] = min(dist[u], w)\n                    heapq.heappush(heap, (-dist[v], v))\n        return dist[n]\n```", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\n        graph = [[] for _ in range(n+1)]\n        for u, v, w in roads:\n            graph[u].append((w, v))\n            graph[v].append((w, u))\n        \n        dist = [0] + [float('-inf')]*n\n        heap = [(-dist[1], 1)]\n        while heap:\n            d, u = heapq.heappop(heap)\n            if -d != dist[u]: continue\n            for w, v in graph[u]:\n                if min(dist[u], w) > dist[v]:\n                    dist[v] = min(dist[u], w)\n                    heapq.heappush(heap, (-dist[v], v))\n        return dist[n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2491", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def dividePlayers(self, skill):\n        skill.sort()\n        total = sum(skill)\n        if total % (len(skill) // 2) != 0:\n            return -1\n        target = total // (len(skill) // 2)\n        i, j = 0, len(skill) - 1\n        chemistry = 0\n        while i < j:\n            if skill[i] + skill[j] != target:\n                return -1\n            chemistry += skill[i] * skill[j]\n            i += 1\n            j -= 1\n        return chemistry\n```", "extracted_code": "\nclass Solution:\n    def dividePlayers(self, skill):\n        skill.sort()\n        total = sum(skill)\n        if total % (len(skill) // 2) != 0:\n            return -1\n        target = total // (len(skill) // 2)\n        i, j = 0, len(skill) - 1\n        chemistry = 0\n        while i < j:\n            if skill[i] + skill[j] != target:\n                return -1\n            chemistry += skill[i] * skill[j]\n            i += 1\n            j -= 1\n        return chemistry\n", "difficulty": 2.0}
{"task_id": "LeetCode/2490", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isCircularSentence(self, sentence: str) -> bool:\n        words = sentence.split()\n        for i in range(len(words) - 1):\n            if words[i][-1] != words[i + 1][0]:\n                return False\n        return words[-1][-1] == words[0][0]\n```", "extracted_code": "\nclass Solution:\n    def isCircularSentence(self, sentence: str) -> bool:\n        words = sentence.split()\n        for i in range(len(words) - 1):\n            if words[i][-1] != words[i + 1][0]:\n                return False\n        return words[-1][-1] == words[0][0]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2488", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums, k):\n        idx, res, n = nums.index(k), 0, len(nums)\n        left, right, l, r = idx, idx, 0, 0\n        while left > 0 or right < n - 1:\n            if right < n - 1:\n                r += 1\n                if nums[right + 1] > k:\n                    right += 1\n            if left > 0 and (right == n - 1 or nums[left - 1] > nums[right + 1]):\n                l += 1\n                if nums[left - 1] > k:\n                    left -= 1\n            res += (r - l + 1)\n        return res\n```\nIn this solution, we first locate the index of 'k' in the array. Then we use two pointers, 'left' and 'right', to traverse the array from the center outwards. In each iteration, we expand the window to the right if the next number is smaller than 'k' or if we have reached the left end of the array. Otherwise, we expand the window to the left. We keep track of the number of subarrays with 'k' as the median and return this count as the result.", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums, k):\n        idx, res, n = nums.index(k), 0, len(nums)\n        left, right, l, r = idx, idx, 0, 0\n        while left > 0 or right < n - 1:\n            if right < n - 1:\n                r += 1\n                if nums[right + 1] > k:\n                    right += 1\n            if left > 0 and (right == n - 1 or nums[left - 1] > nums[right + 1]):\n                l += 1\n                if nums[left - 1] > k:\n                    left -= 1\n            res += (r - l + 1)\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2487", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        right_max = head.val\n        node = head\n        while node.next:\n            if node.next.val >= right_max:\n                right_max = node.next.val\n                node = node.next\n            else:\n                node.next = node.next.next\n        return head\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        right_max = head.val\n        node = head\n        while node.next:\n            if node.next.val >= right_max:\n                right_max = node.next.val\n                node = node.next\n            else:\n                node.next = node.next.next\n        return head\n", "difficulty": 2.0}
{"task_id": "LeetCode/2486", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def appendCharacters(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        j = 0\n        for i in range(n):\n            if j < m and s[i] == t[j]:\n                j += 1\n        return m - j\n```", "extracted_code": "\nclass Solution:\n    def appendCharacters(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        j = 0\n        for i in range(n):\n            if j < m and s[i] == t[j]:\n                j += 1\n        return m - j\n", "difficulty": 2.0}
{"task_id": "LeetCode/2485", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def pivotInteger(self, n: int) -> int:\n        total = n * (n + 1) // 2\n        left_sum = 0\n        for i in range(1, n + 1):\n            left_sum += i\n            if left_sum == total - left_sum:\n                return i\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def pivotInteger(self, n: int) -> int:\n        total = n * (n + 1) // 2\n        left_sum = 0\n        for i in range(1, n + 1):\n            left_sum += i\n            if left_sum == total - left_sum:\n                return i\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2484", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        mod = 10**9+7\n        count = [0]*10\n        prefix = [count.copy()]\n        for c in s:\n            count[int(c)] += 1\n            prefix.append(count.copy())\n        count = [0]*10\n        suffix = [count.copy()]\n        for c in s[::-1]:\n            count[int(c)] += 1\n            suffix.append(count.copy())\n        suffix = suffix[::-1]\n        res = 0\n        for i in range(1, len(s) - 1):\n            left, right = int(s[i-1]), int(s[i+1])\n            if left != right: continue\n            res += ((prefix[i][left] * (suffix[i+2][right] - 1)) % mod)\n        return res % mod\n```", "extracted_code": "\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        mod = 10**9+7\n        count = [0]*10\n        prefix = [count.copy()]\n        for c in s:\n            count[int(c)] += 1\n            prefix.append(count.copy())\n        count = [0]*10\n        suffix = [count.copy()]\n        for c in s[::-1]:\n            count[int(c)] += 1\n            suffix.append(count.copy())\n        suffix = suffix[::-1]\n        res = 0\n        for i in range(1, len(s) - 1):\n            left, right = int(s[i-1]), int(s[i+1])\n            if left != right: continue\n            res += ((prefix[i][left] * (suffix[i+2][right] - 1)) % mod)\n        return res % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2483", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        penalty = [0]*(n+1)\n        penalty[0] = customers.count('Y')\n        for i in range(1, n+1):\n            penalty[i] = penalty[i-1]\n            if customers[i-1] == 'Y':\n                penalty[i] -= 1\n            else:\n                penalty[i] += 1\n        return penalty.index(min(penalty))\n```", "extracted_code": "\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        penalty = [0]*(n+1)\n        penalty[0] = customers.count('Y')\n        for i in range(1, n+1):\n            penalty[i] = penalty[i-1]\n            if customers[i-1] == 'Y':\n                penalty[i] -= 1\n            else:\n                penalty[i] += 1\n        return penalty.index(min(penalty))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2481", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            return n\n```", "extracted_code": "\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            return n\n", "difficulty": 1.0}
{"task_id": "LeetCode/2478", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        primes = set(\"2357\")\n        n = len(s)\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n        cumsum = [0 for _ in range(n + 1)]\n        dp[0][0] = 1\n        mod = 10 ** 9 + 7\n        for i in range(1, n + 1):\n            dp[i][0] = 0\n            cumsum[i] = (cumsum[i - 1] + dp[i][0]) % mod\n            for j in range(1, min(i, k) + 1):\n                if i >= minLength:\n                    dp[i][j] = (cumsum[i - minLength] - (cumsum[i - minLength - 1] if i - minLength - 1 >= 0 else 0)) % mod\n                if s[i - 1] in primes or s[i - j] not in primes:\n                    dp[i][j] = 0\n                dp[i][j] += dp[i - 1][j] if s[i - 1] not in primes else 0\n                cumsum[i] = (cumsum[i] + dp[i][j]) % mod\n        return dp[-1][k]\n```", "extracted_code": "\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        primes = set(\"2357\")\n        n = len(s)\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n        cumsum = [0 for _ in range(n + 1)]\n        dp[0][0] = 1\n        mod = 10 ** 9 + 7\n        for i in range(1, n + 1):\n            dp[i][0] = 0\n            cumsum[i] = (cumsum[i - 1] + dp[i][0]) % mod\n            for j in range(1, min(i, k) + 1):\n                if i >= minLength:\n                    dp[i][j] = (cumsum[i - minLength] - (cumsum[i - minLength - 1] if i - minLength - 1 >= 0 else 0)) % mod\n                if s[i - 1] in primes or s[i - j] not in primes:\n                    dp[i][j] = 0\n                dp[i][j] += dp[i - 1][j] if s[i - 1] not in primes else 0\n                cumsum[i] = (cumsum[i] + dp[i][j]) % mod\n        return dp[-1][k]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2477", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumFuelCost(self, roads, seats):\n        graph = [[] for _ in range(len(roads)+1)]\n        for a, b in roads:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        def dfs(node, parent):\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n            graph[node].sort(reverse=True)\n\n        dfs(0, -1)\n\n        fuel, car = 0, 1\n        for child in graph[0]:\n            if car < len(graph[child])+1:\n                fuel += 1\n                car = seats\n            car -= len(graph[child])+1\n\n        return fuel\n```", "extracted_code": "\nclass Solution:\n    def minimumFuelCost(self, roads, seats):\n        graph = [[] for _ in range(len(roads)+1)]\n        for a, b in roads:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        def dfs(node, parent):\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n            graph[node].sort(reverse=True)\n\n        dfs(0, -1)\n\n        fuel, car = 0, 1\n        for child in graph[0]:\n            if car < len(graph[child])+1:\n                fuel += 1\n                car = seats\n            car -= len(graph[child])+1\n\n        return fuel\n", "difficulty": 2.0}
{"task_id": "LeetCode/2476", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestNodes(self, root, queries):\n        def dfs(node):\n            if node:\n                vals.append(node.val)\n                dfs(node.left)\n                dfs(node.right)\n\n        vals = []\n        dfs(root)\n        vals.sort()\n        answer = []\n        for q in queries:\n            l = bisect.bisect_left(vals, q)\n            if l == 0:\n                answer.append([-1, vals[0]])\n            elif l == len(vals):\n                answer.append([vals[-1], -1])\n            else:\n                answer.append([vals[l - 1], vals[l] if vals[l] != q else vals[l]])\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def closestNodes(self, root, queries):\n        def dfs(node):\n            if node:\n                vals.append(node.val)\n                dfs(node.left)\n                dfs(node.right)\n\n        vals = []\n        dfs(root)\n        vals.sort()\n        answer = []\n        for q in queries:\n            l = bisect.bisect_left(vals, q)\n            if l == 0:\n                answer.append([-1, vals[0]])\n            elif l == len(vals):\n                answer.append([vals[-1], -1])\n            else:\n                answer.append([vals[l - 1], vals[l] if vals[l] != q else vals[l]])\n        return answer\n", "difficulty": 2.0}
{"task_id": "LeetCode/2475", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def unequalTriplets(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                        count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def unequalTriplets(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                        count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2472", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    if j - i == 1 or dp[i + 1][j - 1]:\n                        dp[i][j] = 1\n\n        dp2 = [0] * (n + 1)\n        for j in range(1, n + 1):\n            dp2[j] = max(dp2[j], dp2[j - 1])\n            for i in range(j):\n                if dp[i][j - 1] and j - i >= k:\n                    dp2[j] = max(dp2[j], dp2[i] + 1)\n        return dp2[-1]\n```", "extracted_code": "\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    if j - i == 1 or dp[i + 1][j - 1]:\n                        dp[i][j] = 1\n\n        dp2 = [0] * (n + 1)\n        for j in range(1, n + 1):\n            dp2[j] = max(dp2[j], dp2[j - 1])\n            for i in range(j):\n                if dp[i][j - 1] and j - i >= k:\n                    dp2[j] = max(dp2[j], dp2[i] + 1)\n        return dp2[-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2471", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumOperations(self, root):\n        from collections import defaultdict\n        levels = defaultdict(list)\n        \n        def dfs(node, depth = 0):\n            if node:\n                levels[depth].append(node.val)\n                dfs(node.left, depth + 1)\n                dfs(node.right, depth + 1)\n\n        dfs(root)\n        return sum(list(arr[i + 1] < arr[i] for i in range(len(arr) - 1)) for arr in map(sorted, levels.values()))\n```", "extracted_code": "\nclass Solution:\n    def minimumOperations(self, root):\n        from collections import defaultdict\n        levels = defaultdict(list)\n        \n        def dfs(node, depth = 0):\n            if node:\n                levels[depth].append(node.val)\n                dfs(node.left, depth + 1)\n                dfs(node.right, depth + 1)\n\n        dfs(root)\n        return sum(list(arr[i + 1] < arr[i] for i in range(len(arr) - 1)) for arr in map(sorted, levels.values()))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2470", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n\n        count = 0\n        for i in range(len(nums)):\n            lcm_val = nums[i]\n            if lcm_val == k:\n                count += 1\n            for j in range(i + 1, len(nums)):\n                lcm_val = lcm(lcm_val, nums[j])\n                if lcm_val > k:\n                    break\n                if lcm_val == k:\n                    count += 1\n        return count\n```\n\nThis function `subarrayLCM` takes an integer array `nums` and an integer `k` and returns the number of subarrays of `nums` where the least common multiple of the subarray's elements is `k`. The function makes use of two helper functions `gcd` and `lcm` to calculate the greatest common divisor and the least common multiple respectively. The function iterates over all possible subarrays and checks if the least common multiple of the elements of the subarray is equal to `k`. If it is, it increments the count. If the least common multiple exceeds `k`, it breaks the loop to avoid unnecessary computations. The function finally returns the count.", "extracted_code": "\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n\n        count = 0\n        for i in range(len(nums)):\n            lcm_val = nums[i]\n            if lcm_val == k:\n                count += 1\n            for j in range(i + 1, len(nums)):\n                lcm_val = lcm(lcm_val, nums[j])\n                if lcm_val > k:\n                    break\n                if lcm_val == k:\n                    count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2469", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def convertTemperature(self, celsius: float) -> list[float]:\n        kelvin = celsius + 273.15\n        fahrenheit = celsius * 1.8 + 32\n        return [kelvin, fahrenheit]\n```", "extracted_code": "\nclass Solution:\n    def convertTemperature(self, celsius: float) -> list[float]:\n        kelvin = celsius + 273.15\n        fahrenheit = celsius * 1.8 + 32\n        return [kelvin, fahrenheit]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2468", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> list[str]:\n        suffix_len = 5\n        if limit <= suffix_len:\n            return []\n        parts = []\n        part_len = limit - suffix_len\n        for i in range(0, len(message), part_len):\n            parts.append(message[i:i+part_len])\n        parts_count = len(parts)\n        if len(parts[-1]) + len(f\"<{parts_count}/{parts_count}>\") > limit:\n            if len(parts[-1]) <= suffix_len or parts_count >= 10:\n                return []\n            new_parts = parts[:-1]\n            remaining = parts[-1]\n            new_part_len = limit - len(f\"<{parts_count}/{parts_count+1}>\")\n            for i in range(0, len(remaining), new_part_len):\n                new_parts.append(remaining[i:i+new_part_len])\n            parts_count += 1\n            parts = new_parts\n        return [f\"{part}<{i+1}/{parts_count}>\" for i, part in enumerate(parts)]\n```", "extracted_code": "\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> list[str]:\n        suffix_len = 5\n        if limit <= suffix_len:\n            return []\n        parts = []\n        part_len = limit - suffix_len\n        for i in range(0, len(message), part_len):\n            parts.append(message[i:i+part_len])\n        parts_count = len(parts)\n        if len(parts[-1]) + len(f\"<{parts_count}/{parts_count}>\") > limit:\n            if len(parts[-1]) <= suffix_len or parts_count >= 10:\n                return []\n            new_parts = parts[:-1]\n            remaining = parts[-1]\n            new_part_len = limit - len(f\"<{parts_count}/{parts_count+1}>\")\n            for i in range(0, len(remaining), new_part_len):\n                new_parts.append(remaining[i:i+new_part_len])\n            parts_count += 1\n            parts = new_parts\n        return [f\"{part}<{i+1}/{parts_count}>\" for i, part in enumerate(parts)]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2467", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "Here is the Python code that solves the problem using depth-first search to find the leaf node that gives Alice the maximum net income:\n\n```python\nclass Solution:\n    def mostProfitablePath(self, edges, bob, amount):\n        n = len(amount)\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        time_bob = [0] * n\n        q = [(bob, 0)]\n        for u, t in q:\n            for v in g[u]:\n                if v == bob or time_bob[v]:\n                    continue\n                time_bob[v] = t + 1\n                q.append((v, t + 1))\n        dp = [0] * n\n        q = [(0, amount[0])]\n        for u, cur in q:\n            for v in g[u]:\n                if v == 0 or dp[v]:\n                    continue\n                if time_bob[u] < time_bob[v]:\n                    dp[v] = max(dp[v], cur + amount[v])\n                else:\n                    dp[v] = max(dp[v], cur + amount[v] // 2)\n                q.append((v, dp[v]))\n        return max(dp)\n```", "extracted_code": "\nclass Solution:\n    def mostProfitablePath(self, edges, bob, amount):\n        n = len(amount)\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        time_bob = [0] * n\n        q = [(bob, 0)]\n        for u, t in q:\n            for v in g[u]:\n                if v == bob or time_bob[v]:\n                    continue\n                time_bob[v] = t + 1\n                q.append((v, t + 1))\n        dp = [0] * n\n        q = [(0, amount[0])]\n        for u, cur in q:\n            for v in g[u]:\n                if v == 0 or dp[v]:\n                    continue\n                if time_bob[u] < time_bob[v]:\n                    dp[v] = max(dp[v], cur + amount[v])\n                else:\n                    dp[v] = max(dp[v], cur + amount[v] // 2)\n                q.append((v, dp[v]))\n        return max(dp)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2466", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[[[0, 0] for _ in range(2)] for _ in range(101)] for _ in range(101)]\n        dp[0][0][0][1] = 1\n        for i in range(100):\n            for j in range(100):\n                for k in range(2):\n                    for l in [0, 1]:\n                        if k == 0:\n                            if j + 1 <= one:\n                                dp[i + 1][j + 1][1][l | (j + 1 >= low and j + 1 <= high)] += dp[i][j][k][l]\n                                dp[i + 1][j + 1][1][l | (j + 1 >= low and j + 1 <= high)] %= MOD\n                        else:\n                            if i + 1 <= zero:\n                                dp[i + 1][j][0][l | (i + 1 >= low and i + 1 <= high)] += dp[i][j][k][l]\n                                dp[i + 1][j][0][l | (i + 1 >= low and i + 1 <= high)] %= MOD\n                        dp[i + 1][j][k][l] += dp[i][j][k][l]\n                        dp[i + 1][j][k][l] %= MOD\n        return sum(dp[zero][one][k][1] for k in range(2)) % MOD\n```", "extracted_code": "\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[[[0, 0] for _ in range(2)] for _ in range(101)] for _ in range(101)]\n        dp[0][0][0][1] = 1\n        for i in range(100):\n            for j in range(100):\n                for k in range(2):\n                    for l in [0, 1]:\n                        if k == 0:\n                            if j + 1 <= one:\n                                dp[i + 1][j + 1][1][l | (j + 1 >= low and j + 1 <= high)] += dp[i][j][k][l]\n                                dp[i + 1][j + 1][1][l | (j + 1 >= low and j + 1 <= high)] %= MOD\n                        else:\n                            if i + 1 <= zero:\n                                dp[i + 1][j][0][l | (i + 1 >= low and i + 1 <= high)] += dp[i][j][k][l]\n                                dp[i + 1][j][0][l | (i + 1 >= low and i + 1 <= high)] %= MOD\n                        dp[i + 1][j][k][l] += dp[i][j][k][l]\n                        dp[i + 1][j][k][l] %= MOD\n        return sum(dp[zero][one][k][1] for k in range(2)) % MOD\n", "difficulty": 2.0}
{"task_id": "LeetCode/2465", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distinctAverages(self, nums: List[int]) -> int:\n        nums.sort()\n        averages = set()\n        while nums:\n            min_num = nums.pop(0)\n            max_num = nums.pop(-1)\n            averages.add((min_num + max_num) / 2)\n        return len(averages)\n```", "extracted_code": "\nclass Solution:\n    def distinctAverages(self, nums: List[int]) -> int:\n        nums.sort()\n        averages = set()\n        while nums:\n            min_num = nums.pop(0)\n            max_num = nums.pop(-1)\n            averages.add((min_num + max_num) / 2)\n        return len(averages)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2463", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalDistance(self, robot, factory):\n        robot.sort()\n        factory.sort()\n        total_distance = 0\n        j = 0\n        for i in range(len(robot)):\n            while j < len(factory) and factory[j][1] <= 0:\n                j += 1\n            total_distance += abs(robot[i] - factory[j][0])\n            factory[j][1] -= 1\n        return total_distance\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalDistance(self, robot, factory):\n        robot.sort()\n        factory.sort()\n        total_distance = 0\n        j = 0\n        for i in range(len(robot)):\n            while j < len(factory) and factory[j][1] <= 0:\n                j += 1\n            total_distance += abs(robot[i] - factory[j][0])\n            factory[j][1] -= 1\n        return total_distance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2462", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n        total_cost = 0\n        costs = [(cost, i) for i, cost in enumerate(costs)]\n        costs.sort()\n        for _ in range(k):\n            for j in range(min(candidates, len(costs))):\n                if j == 0 or costs[j][0] < costs[cheapest][0]:\n                    cheapest = j\n            total_cost += costs.pop(cheapest)[0]\n            cheapest = 0\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n        total_cost = 0\n        costs = [(cost, i) for i, cost in enumerate(costs)]\n        costs.sort()\n        for _ in range(k):\n            for j in range(min(candidates, len(costs))):\n                if j == 0 or costs[j][0] < costs[cheapest][0]:\n                    cheapest = j\n            total_cost += costs.pop(cheapest)[0]\n            cheapest = 0\n        return total_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2461", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            sub_arr = nums[i:i+k]\n            if len(set(sub_arr)) == k:\n                max_sum = max(max_sum, sum(sub_arr))\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            sub_arr = nums[i:i+k]\n            if len(set(sub_arr)) == k:\n                max_sum = max(max_sum, sum(sub_arr))\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2460", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def applyOperations(self, nums: List[int]) -> List[int]:\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                nums[i] *= 2\n                nums[i + 1] = 0\n        return sorted(nums, key=lambda x: 1 if x == 0 else 0)\n```", "extracted_code": "\nclass Solution:\n    def applyOperations(self, nums: List[int]) -> List[int]:\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                nums[i] *= 2\n                nums[i + 1] = 0\n        return sorted(nums, key=lambda x: 1 if x == 0 else 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2458", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node):\n            if not node:\n                return\n            height[node.val] = 1 + max(height[node.left.val] if node.left else 0, height[node.right.val] if node.right else 0)\n            parent[node.left.val] = parent[node.right.val] = node.val\n            dfs(node.left)\n            dfs(node.right)\n\n        n = len(root)\n        height = [0]*(n+1)\n        parent = [0]*(n+1)\n        dfs(root)\n        res = []\n        for q in queries:\n            height[parent[q]] = max(height[parent[q]], height[q])\n            res.append(height[1])\n            height[parent[q]] = 0\n        return res\n```", "extracted_code": "\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node):\n            if not node:\n                return\n            height[node.val] = 1 + max(height[node.left.val] if node.left else 0, height[node.right.val] if node.right else 0)\n            parent[node.left.val] = parent[node.right.val] = node.val\n            dfs(node.left)\n            dfs(node.right)\n\n        n = len(root)\n        height = [0]*(n+1)\n        parent = [0]*(n+1)\n        dfs(root)\n        res = []\n        for q in queries:\n            height[parent[q]] = max(height[parent[q]], height[q])\n            res.append(height[1])\n            height[parent[q]] = 0\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2457", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        while sum(int(digit) for digit in str(n)) > target:\n            n += 1\n        return n - 1\n```", "extracted_code": "\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        while sum(int(digit) for digit in str(n)) > target:\n            n += 1\n        return n - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2456", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n        popularity = {}\n        max_views = {}\n        max_popularity = 0\n        answer = []\n\n        for i in range(len(creators)):\n            if creators[i] in popularity:\n                popularity[creators[i]] += views[i]\n                if views[i] > max_views[creators[i]][0] or (views[i] == max_views[creators[i]][0] and ids[i] < max_views[creators[i]][1]):\n                    max_views[creators[i]] = [views[i], ids[i]]\n            else:\n                popularity[creators[i]] = views[i]\n                max_views[creators[i]] = [views[i], ids[i]]\n\n            max_popularity = max(max_popularity, popularity[creators[i]])\n\n        for creator, popularity in popularity.items():\n            if popularity == max_popularity:\n                answer.append([creator, max_views[creator][1]])\n\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n        popularity = {}\n        max_views = {}\n        max_popularity = 0\n        answer = []\n\n        for i in range(len(creators)):\n            if creators[i] in popularity:\n                popularity[creators[i]] += views[i]\n                if views[i] > max_views[creators[i]][0] or (views[i] == max_views[creators[i]][0] and ids[i] < max_views[creators[i]][1]):\n                    max_views[creators[i]] = [views[i], ids[i]]\n            else:\n                popularity[creators[i]] = views[i]\n                max_views[creators[i]] = [views[i], ids[i]]\n\n            max_popularity = max(max_popularity, popularity[creators[i]])\n\n        for creator, popularity in popularity.items():\n            if popularity == max_popularity:\n                answer.append([creator, max_views[creator][1]])\n\n        return answer\n", "difficulty": 2.0}
{"task_id": "LeetCode/2455", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        nums_selected = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        return sum(nums_selected) // len(nums_selected) if nums_selected else 0\n```", "extracted_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        nums_selected = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        return sum(nums_selected) // len(nums_selected) if nums_selected else 0\n", "difficulty": 1.0}
{"task_id": "LeetCode/2454", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def secondGreaterElement(self, nums):\n        n = len(nums)\n        stack, answer = [], [-1] * n\n        \n        for i in range(2*n - 1, -1, -1):\n            while stack and nums[stack[-1]] <= nums[i%n]:\n                if answer[stack[-1]] == -1:\n                    answer[stack[-1]] = nums[i%n]\n                stack.pop()\n            stack.append(i%n)\n        \n        return answer\n```", "extracted_code": "\nclass Solution:\n    def secondGreaterElement(self, nums):\n        n = len(nums)\n        stack, answer = [], [-1] * n\n        \n        for i in range(2*n - 1, -1, -1):\n            while stack and nums[stack[-1]] <= nums[i%n]:\n                if answer[stack[-1]] == -1:\n                    answer[stack[-1]] = nums[i%n]\n                stack.pop()\n            stack.append(i%n)\n        \n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2453", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def destroyTargets(self, nums: List[int], space: int) -> int:\n        nums.sort()\n        target_count = {i: 0 for i in nums}\n        for num in nums:\n            prev_div = (num - space) // space\n            if prev_div * space in target_count:\n                target_count[num] = max(target_count[num], target_count[prev_div * space] + 1)\n            else:\n                target_count[num] = max(target_count[num], 1)\n        max_targets = max(target_count.values())\n        for num in nums:\n            if target_count[num] == max_targets:\n                return num\n```", "extracted_code": "\nclass Solution:\n    def destroyTargets(self, nums: List[int], space: int) -> int:\n        nums.sort()\n        target_count = {i: 0 for i in nums}\n        for num in nums:\n            prev_div = (num - space) // space\n            if prev_div * space in target_count:\n                target_count[num] = max(target_count[num], target_count[prev_div * space] + 1)\n            else:\n                target_count[num] = max(target_count[num], 1)\n        max_targets = max(target_count.values())\n        for num in nums:\n            if target_count[num] == max_targets:\n                return num\n", "difficulty": 2.0}
{"task_id": "LeetCode/2452", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def twoEditWords(self, queries, dictionary):\n        result = []\n        for query in queries:\n            for word in dictionary:\n                if self.countEdits(query, word) <= 2:\n                    result.append(query)\n                    break\n        return result\n\n    def countEdits(self, s1, s2):\n        edits = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                edits += 1\n        return edits\n```", "extracted_code": "\nclass Solution:\n    def twoEditWords(self, queries, dictionary):\n        result = []\n        for query in queries:\n            for word in dictionary:\n                if self.countEdits(query, word) <= 2:\n                    result.append(query)\n                    break\n        return result\n\n    def countEdits(self, s1, s2):\n        edits = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                edits += 1\n        return edits\n", "difficulty": 2.0}
{"task_id": "LeetCode/2451", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def oddString(self, words: List[str]) -> str:\n        diff = []\n        for word in words:\n            diff.append([ord(word[i + 1]) - ord(word[i]) for i in range(len(word) - 1)])\n        for i in range(len(diff)):\n            if diff.count(diff[i]) == 1:\n                return words[i]\n```", "extracted_code": "\nclass Solution:\n    def oddString(self, words: List[str]) -> str:\n        diff = []\n        for word in words:\n            diff.append([ord(word[i + 1]) - ord(word[i]) for i in range(len(word) - 1)])\n        for i in range(len(diff)):\n            if diff.count(diff[i]) == 1:\n                return words[i]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2449", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSimilar(self, nums, target):\n        diff = [0]*len(nums)\n        for i in range(len(nums)):\n            diff[i] = nums[i] - target[i]\n        \n        diff.sort()\n        i = 0\n        j = len(nums) - 1\n        operations = 0\n        while i < j:\n            if diff[i] < 0 and diff[j] > 0:\n                if diff[i] + diff[j] < 0:\n                    operations += diff[j] // 2\n                    diff[i] += diff[j]\n                    diff[j] = 0\n                else:\n                    operations += diff[i] // -2\n                    diff[j] += diff[i]\n                    diff[i] = 0\n            if diff[i] == 0:\n                i += 1\n            if diff[j] == 0:\n                j -= 1\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def makeSimilar(self, nums, target):\n        diff = [0]*len(nums)\n        for i in range(len(nums)):\n            diff[i] = nums[i] - target[i]\n        \n        diff.sort()\n        i = 0\n        j = len(nums) - 1\n        operations = 0\n        while i < j:\n            if diff[i] < 0 and diff[j] > 0:\n                if diff[i] + diff[j] < 0:\n                    operations += diff[j] // 2\n                    diff[i] += diff[j]\n                    diff[j] = 0\n                else:\n                    operations += diff[i] // -2\n                    diff[j] += diff[i]\n                    diff[i] = 0\n            if diff[i] == 0:\n                i += 1\n            if diff[j] == 0:\n                j -= 1\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2448", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        nums, cost = zip(*sorted(zip(nums, cost)))\n        median = nums[len(nums) // 2]\n        return sum(abs(num - median) * c for num, c in zip(nums, cost))\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        nums, cost = zip(*sorted(zip(nums, cost)))\n        median = nums[len(nums) // 2]\n        return sum(abs(num - median) * c for num, c in zip(nums, cost))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2447", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\n        from math import gcd\n        count = 0\n        for i in range(len(nums)):\n            gcd_val = 0\n            for j in range(i, len(nums)):\n                gcd_val = gcd(gcd_val, nums[j])\n                if gcd_val == k:\n                    count += 1\n                elif gcd_val > k:\n                    break\n        return count\n```", "extracted_code": "\nclass Solution:\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\n        from math import gcd\n        count = 0\n        for i in range(len(nums)):\n            gcd_val = 0\n            for j in range(i, len(nums)):\n                gcd_val = gcd(gcd_val, nums[j])\n                if gcd_val == k:\n                    count += 1\n                elif gcd_val > k:\n                    break\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2446", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\n        event1_start = int(event1[0].replace(\":\", \"\"))\n        event1_end = int(event1[1].replace(\":\", \"\"))\n        event2_start = int(event2[0].replace(\":\", \"\"))\n        event2_end = int(event2[1].replace(\":\", \"\"))\n        \n        if event1_start <= event2_start < event1_end or event2_start <= event1_start < event2_end:\n            return True\n        else:\n            return False\n```", "extracted_code": "\nclass Solution:\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\n        event1_start = int(event1[0].replace(\":\", \"\"))\n        event1_end = int(event1[1].replace(\":\", \"\"))\n        event2_start = int(event2[0].replace(\":\", \"\"))\n        event2_end = int(event2[1].replace(\":\", \"\"))\n        \n        if event1_start <= event2_start < event1_end or event2_start <= event1_start < event2_end:\n            return True\n        else:\n            return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/2444", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        left, right = [0]*n, [0]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] < nums[i]:\n                stack.pop()\n            left[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack = []\n        for i in range(n-1, -1, -1):\n            while stack and nums[stack[-1]] <= nums[i]:\n                stack.pop()\n            right[i] = stack[-1] if stack else n\n            stack.append(i)\n        return sum((right[i] - i) * (i - left[i]) for i in range(n) if minK <= nums[i] <= maxK)\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        left, right = [0]*n, [0]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] < nums[i]:\n                stack.pop()\n            left[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack = []\n        for i in range(n-1, -1, -1):\n            while stack and nums[stack[-1]] <= nums[i]:\n                stack.pop()\n            right[i] = stack[-1] if stack else n\n            stack.append(i)\n        return sum((right[i] - i) * (i - left[i]) for i in range(n) if minK <= nums[i] <= maxK)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2443", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        for i in range(num + 1):\n            if i + int(str(i)[::-1]) == num:\n                return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        for i in range(num + 1):\n            if i + int(str(i)[::-1]) == num:\n                return True\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2442", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        return len(set(nums + [int(str(num)[::-1]) for num in nums]))\n```", "extracted_code": "\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        return len(set(nums + [int(str(num)[::-1]) for num in nums]))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2441", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        max_k = -1\n        for num in nums_set:\n            if num > max_k and -num in nums_set:\n                max_k = num\n        return max_k\n```", "extracted_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        max_k = -1\n        for num in nums_set:\n            if num > max_k and -num in nums_set:\n                max_k = num\n        return max_k\n", "difficulty": 1.0}
{"task_id": "LeetCode/2440", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "Here is a Python solution that uses depth-first search to traverse the tree and count the number of edges that can be deleted. The total sum of all nodes is calculated first. Then, for each node, it computes the subtotal of all nodes in its subtree (including itself). If this subtotal equals the total sum divided by 2, it can delete the edge to its parent and recurse to its children.\n\n```python\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = collections.defaultdict(list)\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        total = sum(nums)\n        count = 0\n\n        def dfs(node, parent):\n            nonlocal count\n            subtotal = nums[node]\n            for child in tree[node]:\n                if child != parent:\n                    subtotal += dfs(child, node)\n            if subtotal == total / 2:\n                count += 1\n                return 0\n            return subtotal\n\n        dfs(0, -1)\n        if total % 2:\n            return 0\n        return count - 1 if count > 1 else 0\n```\n\nThis solution assumes that the input tree is a connected component and is rooted at node 0. It starts a depth-first search from node 0 and uses a dictionary to store the children of each node. The function `dfs` calculates the total value of each subtree by recursively calling itself on each child node, and adds the value of the current node. If the total value of a subtree is exactly half of the total value of the tree, it increments the count and returns 0 to indicate that the subtree can be separated from the rest of the tree. The function returns the total number of deletions, which is `count - 1`, or 0 if no deletions are possible.", "extracted_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = collections.defaultdict(list)\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        total = sum(nums)\n        count = 0\n\n        def dfs(node, parent):\n            nonlocal count\n            subtotal = nums[node]\n            for child in tree[node]:\n                if child != parent:\n                    subtotal += dfs(child, node)\n            if subtotal == total / 2:\n                count += 1\n                return 0\n            return subtotal\n\n        dfs(0, -1)\n        if total % 2:\n            return 0\n        return count - 1 if count > 1 else 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2439", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeArrayValue(self, nums: List[int]) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        while left < right:\n            total = sum(nums[left:right])\n            if total < nums[right]:\n                return nums[right]\n            right -= 1\n        return max(nums)\n```", "extracted_code": "\nclass Solution:\n    def minimizeArrayValue(self, nums: List[int]) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        while left < right:\n            total = sum(nums[left:right])\n            if total < nums[right]:\n                return nums[right]\n            right -= 1\n        return max(nums)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2438", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        powers = []\n        while n > 0:\n            power = 1\n            while (power << 1) <= n:\n                power <<= 1\n            powers.append(power)\n            n -= power\n        prefix = [1] * (len(powers) + 1)\n        MOD = 10**9 + 7\n        for i in range(len(powers)):\n            prefix[i+1] = prefix[i] * powers[i] % MOD\n        return [prefix[right+1] * pow(prefix[left], -1, MOD) % MOD for left, right in queries]\n```", "extracted_code": "\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        powers = []\n        while n > 0:\n            power = 1\n            while (power << 1) <= n:\n                power <<= 1\n            powers.append(power)\n            n -= power\n        prefix = [1] * (len(powers) + 1)\n        MOD = 10**9 + 7\n        for i in range(len(powers)):\n            prefix[i+1] = prefix[i] * powers[i] % MOD\n        return [prefix[right+1] * pow(prefix[left], -1, MOD) % MOD for left, right in queries]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2437", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countTime(self, time: str) -> int:\n        hours, minutes = time.split(\":\")\n        possible_hours = 24 if hours == \"??\" else (10 if hours[0] == \"?\" else (4 if hours[1] == \"?\" and hours[0] == \"2\" else (10 if hours[1] == \"?\" else (2 if hours[0] == \"?\" else 1))))\n        possible_minutes = 60 if minutes == \"??\" else (10 if minutes[0] == \"?\" else (10 if minutes[1] == \"?\" else 1))\n        return possible_hours * possible_minutes\n```", "extracted_code": "\nclass Solution:\n    def countTime(self, time: str) -> int:\n        hours, minutes = time.split(\":\")\n        possible_hours = 24 if hours == \"??\" else (10 if hours[0] == \"?\" else (4 if hours[1] == \"?\" and hours[0] == \"2\" else (10 if hours[1] == \"?\" else (2 if hours[0] == \"?\" else 1))))\n        possible_minutes = 60 if minutes == \"??\" else (10 if minutes[0] == \"?\" else (10 if minutes[1] == \"?\" else 1))\n        return possible_hours * possible_minutes\n", "difficulty": 1.0}
{"task_id": "LeetCode/2435", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[[0]*k for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0] % k] = 1\n        mod = 10**9 + 7\n        \n        for i in range(m):\n            for j in range(n):\n                for kk in range(k):\n                    if i:\n                        dp[i][j][(kk+grid[i][j])%k] += dp[i-1][j][kk]\n                    if j:\n                        dp[i][j][(kk+grid[i][j])%k] += dp[i][j-1][kk]\n                    dp[i][j][(kk+grid[i][j])%k] %= mod\n                        \n        return dp[-1][-1][0]\n```", "extracted_code": "\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[[0]*k for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0] % k] = 1\n        mod = 10**9 + 7\n        \n        for i in range(m):\n            for j in range(n):\n                for kk in range(k):\n                    if i:\n                        dp[i][j][(kk+grid[i][j])%k] += dp[i-1][j][kk]\n                    if j:\n                        dp[i][j][(kk+grid[i][j])%k] += dp[i][j-1][kk]\n                    dp[i][j][(kk+grid[i][j])%k] %= mod\n                        \n        return dp[-1][-1][0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2434", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = []\n        res = []\n        for c in sorted(s):\n            while t and t[-1] <= c:\n                res.append(t.pop())\n            t.append(c)\n        res.extend(reversed(t))\n        return ''.join(res)\n```", "extracted_code": "\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = []\n        res = []\n        for c in sorted(s):\n            while t and t[-1] <= c:\n                res.append(t.pop())\n            t.append(c)\n        res.extend(reversed(t))\n        return ''.join(res)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2433", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findArray(self, pref):\n        n = len(pref)\n        arr = [0] * n\n        arr[0] = pref[0]\n        for i in range(1, n):\n            arr[i] = pref[i-1] ^ pref[i]\n        return arr\n```", "extracted_code": "\nclass Solution:\n    def findArray(self, pref):\n        n = len(pref)\n        arr = [0] * n\n        arr[0] = pref[0]\n        for i in range(1, n):\n            arr[i] = pref[i-1] ^ pref[i]\n        return arr\n", "difficulty": 2.0}
{"task_id": "LeetCode/2432", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hardestWorker(self, n: int, logs: [[int]]) -> int:\n        duration = [0]*n\n        prev_time = 0\n        for log in logs:\n            duration[log[0]] += log[1] - prev_time\n            prev_time = log[1]\n        max_duration = max(duration)\n        for i in range(n):\n            if duration[i] == max_duration:\n                return i\n```", "extracted_code": "\nclass Solution:\n    def hardestWorker(self, n: int, logs: [[int]]) -> int:\n        duration = [0]*n\n        prev_time = 0\n        for log in logs:\n            duration[log[0]] += log[1] - prev_time\n            prev_time = log[1]\n        max_duration = max(duration)\n        for i in range(n):\n            if duration[i] == max_duration:\n                return i\n", "difficulty": 1.0}
