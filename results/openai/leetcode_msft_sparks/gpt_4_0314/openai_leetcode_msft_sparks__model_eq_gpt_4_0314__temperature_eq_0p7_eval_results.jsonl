{"task_id": "LeetCode/2532", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = sorted(range(k), key=lambda i: (time[i][0] + time[i][2], i))\n        left_bank, right_bank, new_boxes = set(workers), set(), 0\n        curr_time, events = 0, []\n\n        while new_boxes < n:\n            while events and events[0][0] <= curr_time:\n                t, i, action = heapq.heappop(events)\n                if action == \"cross_right\":\n                    right_bank.add(i)\n                elif action == \"cross_left\":\n                    left_bank.add(i)\n                    new_boxes += 1\n\n            if right_bank:\n                i = min(right_bank, key=lambda i: (time[i][0] + time[i][2], i))\n                curr_time += time[i][0]\n                heapq.heappush(events, (curr_time, i, \"cross_left\"))\n                right_bank.remove(i)\n            elif left_bank and new_boxes < n:\n                i = min(left_bank, key=lambda i: (time[i][0] + time[i][2], i))\n                curr_time += time[i][0]\n                heapq.heappush(events, (curr_time + time[i][1], i, \"cross_right\"))\n                left_bank.remove(i)\n            else:\n                curr_time = events[0][0]\n\n        return curr_time\n```", "extracted_code": "\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = sorted(range(k), key=lambda i: (time[i][0] + time[i][2], i))\n        left_bank, right_bank, new_boxes = set(workers), set(), 0\n        curr_time, events = 0, []\n\n        while new_boxes < n:\n            while events and events[0][0] <= curr_time:\n                t, i, action = heapq.heappop(events)\n                if action == \"cross_right\":\n                    right_bank.add(i)\n                elif action == \"cross_left\":\n                    left_bank.add(i)\n                    new_boxes += 1\n\n            if right_bank:\n                i = min(right_bank, key=lambda i: (time[i][0] + time[i][2], i))\n                curr_time += time[i][0]\n                heapq.heappush(events, (curr_time, i, \"cross_left\"))\n                right_bank.remove(i)\n            elif left_bank and new_boxes < n:\n                i = min(left_bank, key=lambda i: (time[i][0] + time[i][2], i))\n                curr_time += time[i][0]\n                heapq.heappush(events, (curr_time + time[i][1], i, \"cross_right\"))\n                left_bank.remove(i)\n            else:\n                curr_time = events[0][0]\n\n        return curr_time\n", "difficulty": 3.0}
{"task_id": "LeetCode/2531", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        word1_set = set(word1)\n        word2_set = set(word2)\n        common = word1_set.intersection(word2_set)\n        \n        if len(word1_set) == len(word2_set):\n            return True if common else False\n        elif abs(len(word1_set) - len(word2_set)) == 1:\n            return True if common else False\n        else:\n            return False\n```", "extracted_code": "\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        word1_set = set(word1)\n        word2_set = set(word2)\n        common = word1_set.intersection(word2_set)\n        \n        if len(word1_set) == len(word2_set):\n            return True if common else False\n        elif abs(len(word1_set) - len(word2_set)) == 1:\n            return True if common else False\n        else:\n            return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2530", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        neg_nums = [-num for num in nums]\n        heapq.heapify(neg_nums)\n        score = 0\n        for _ in range(k):\n            max_num = -heapq.heappop(neg_nums)\n            score += max_num\n            heapq.heappush(neg_nums, -(-max_num // 3))\n        return score\n```", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        neg_nums = [-num for num in nums]\n        heapq.heapify(neg_nums)\n        score = 0\n        for _ in range(k):\n            max_num = -heapq.heappop(neg_nums)\n            score += max_num\n            heapq.heappush(neg_nums, -(-max_num // 3))\n        return score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2529", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        pos = sum(1 for i in nums if i > 0)\n        neg = sum(1 for i in nums if i < 0)\n        return max(pos, neg)\n```", "extracted_code": "\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        pos = sum(1 for i in nums if i > 0)\n        neg = sum(1 for i in nums if i < 0)\n        return max(pos, neg)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2528", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        power = [0] * n\n        for i in range(n):\n            for j in range(max(0, i - r), min(n, i + r + 1)):\n                power[j] += stations[i]\n\n        def can_reach(target_power: int) -> bool:\n            remaining_k = k\n            for i in range(n):\n                if power[i] < target_power:\n                    remaining_k -= (target_power - power[i])\n                    if remaining_k < 0:\n                        return False\n            return True\n\n        left, right = 0, sum(stations) + k + 1\n        while left < right:\n            mid = (left + right) // 2\n            if can_reach(mid):\n                left = mid + 1\n            else:\n                right = mid\n        return left - 1\n```", "extracted_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        power = [0] * n\n        for i in range(n):\n            for j in range(max(0, i - r), min(n, i + r + 1)):\n                power[j] += stations[i]\n\n        def can_reach(target_power: int) -> bool:\n            remaining_k = k\n            for i in range(n):\n                if power[i] < target_power:\n                    remaining_k -= (target_power - power[i])\n                    if remaining_k < 0:\n                        return False\n            return True\n\n        left, right = 0, sum(stations) + k + 1\n        while left < right:\n            mid = (left + right) // 2\n            if can_reach(mid):\n                left = mid + 1\n            else:\n                right = mid\n        return left - 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2527", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def xorBeauty(self, nums: List[int]) -> int:\n        xor_beauty = 0\n        for i in range(30):\n            count = 0\n            bitmask = 1 << i\n            for num in nums:\n                if num & bitmask:\n                    count += 1\n            xor_beauty ^= (count * (len(nums) - count) * bitmask) % (10**9+7)\n        return xor_beauty\n```", "extracted_code": "\nclass Solution:\n    def xorBeauty(self, nums: List[int]) -> int:\n        xor_beauty = 0\n        for i in range(30):\n            count = 0\n            bitmask = 1 << i\n            for num in nums:\n                if num & bitmask:\n                    count += 1\n            xor_beauty ^= (count * (len(nums) - count) * bitmask) % (10**9+7)\n        return xor_beauty\n", "difficulty": 2.0}
{"task_id": "LeetCode/2526", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class DataStream:\n\n    def __init__(self, value: int, k: int):\n        self.value = value\n        self.k = k\n        self.stream = []\n\n    def consec(self, num: int) -> bool:\n        self.stream.append(num)\n        if len(self.stream) < self.k:\n            return False\n        elif len(self.stream) > self.k:\n            self.stream.pop(0)\n        return all(x == self.value for x in self.stream)\n\n# Your DataStream object will be instantiated and called as such:\n# obj = DataStream(value, k)\n# param_1 = obj.consec(num)", "extracted_code": "class DataStream:\n\n    def __init__(self, value: int, k: int):\n        self.value = value\n        self.k = k\n        self.stream = []\n\n    def consec(self, num: int) -> bool:\n        self.stream.append(num)\n        if len(self.stream) < self.k:\n            return False\n        elif len(self.stream) > self.k:\n            self.stream.pop(0)\n        return all(x == self.value for x in self.stream)\n\n# Your DataStream object will be instantiated and called as such:\n# obj = DataStream(value, k)\n# param_1 = obj.consec(num)", "difficulty": 2.0}
{"task_id": "LeetCode/2525", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        volume = length * width * height\n        bulky = length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9\n        heavy = mass >= 100\n        \n        if bulky and heavy:\n            return \"Both\"\n        elif bulky:\n            return \"Bulky\"\n        elif heavy:\n            return \"Heavy\"\n        else:\n            return \"Neither\"\n```", "extracted_code": "\nclass Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        volume = length * width * height\n        bulky = length >= 10**4 or width >= 10**4 or height >= 10**4 or volume >= 10**9\n        heavy = mass >= 100\n        \n        if bulky and heavy:\n            return \"Both\"\n        elif bulky:\n            return \"Bulky\"\n        elif heavy:\n            return \"Heavy\"\n        else:\n            return \"Neither\"\n", "difficulty": 1.0}
{"task_id": "LeetCode/2523", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n <= 1:\n                return False\n            if n <= 3:\n                return True\n            if n % 2 == 0 or n % 3 == 0:\n                return False\n            i = 5\n            while i**2 <= n:\n                if n % i == 0 or n % (i + 2) == 0:\n                    return False\n                i += 6\n            return True\n        \n        min_gap = float('inf')\n        nums1, nums2 = -1, -1\n        prev_prime = None\n        \n        for num in range(left, right + 1):\n            if is_prime(num):\n                if prev_prime is not None:\n                    gap = num - prev_prime\n                    if gap < min_gap:\n                        min_gap = gap\n                        nums1, nums2 = prev_prime, num\n                prev_prime = num\n        \n        return [nums1, nums2]\n```", "extracted_code": "\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n <= 1:\n                return False\n            if n <= 3:\n                return True\n            if n % 2 == 0 or n % 3 == 0:\n                return False\n            i = 5\n            while i**2 <= n:\n                if n % i == 0 or n % (i + 2) == 0:\n                    return False\n                i += 6\n            return True\n        \n        min_gap = float('inf')\n        nums1, nums2 = -1, -1\n        prev_prime = None\n        \n        for num in range(left, right + 1):\n            if is_prime(num):\n                if prev_prime is not None:\n                    gap = num - prev_prime\n                    if gap < min_gap:\n                        min_gap = gap\n                        nums1, nums2 = prev_prime, num\n                prev_prime = num\n        \n        return [nums1, nums2]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2522", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            j = i\n            num = 0\n            while j > 0 and i - j + 1 <= 9:\n                num = num * 10 + int(s[j - 1])\n                if num > k:\n                    break\n                dp[i] = min(dp[i], dp[j - 1] + 1)\n                j -= 1\n\n        return dp[n] if dp[n] != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            j = i\n            num = 0\n            while j > 0 and i - j + 1 <= 9:\n                num = num * 10 + int(s[j - 1])\n                if num > k:\n                    break\n                dp[i] = min(dp[i], dp[j - 1] + 1)\n                j -= 1\n\n        return dp[n] if dp[n] != float('inf') else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2521", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        def prime_factors(num):\n            factors = set()\n            for i in range(2, num + 1):\n                if is_prime(i):\n                    while num % i == 0:\n                        factors.add(i)\n                        num //= i\n            return factors\n\n        all_factors = set()\n        for num in nums:\n            factors = prime_factors(num)\n            all_factors.update(factors)\n        return len(all_factors)\n```", "extracted_code": "\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        def prime_factors(num):\n            factors = set()\n            for i in range(2, num + 1):\n                if is_prime(i):\n                    while num % i == 0:\n                        factors.add(i)\n                        num //= i\n            return factors\n\n        all_factors = set()\n        for num in nums:\n            factors = prime_factors(num)\n            all_factors.update(factors)\n        return len(all_factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2520", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def countDigits(self, num: int) -> int:\n        count = 0\n        for digit in str(num):\n            if int(digit) != 0 and num % int(digit) == 0:\n                count += 1\n        return count", "extracted_code": "class Solution:\n    def countDigits(self, num: int) -> int:\n        count = 0\n        for digit in str(num):\n            if int(digit) != 0 and num % int(digit) == 0:\n                count += 1\n        return count", "difficulty": 1.0}
{"task_id": "LeetCode/2518", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        total_sum = sum(nums)\n        if total_sum < 2 * k:\n            return 0\n        dp = [0] * (total_sum + 1)\n        dp[0] = 1\n        mod = 10**9 + 7\n\n        for num in nums:\n            for i in range(total_sum - num, -1, -1):\n                dp[i + num] += dp[i]\n                dp[i + num] %= mod\n\n        return (sum(dp[k:total_sum // 2 + 1]) - 1) % mod\n```", "extracted_code": "\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        total_sum = sum(nums)\n        if total_sum < 2 * k:\n            return 0\n        dp = [0] * (total_sum + 1)\n        dp[0] = 1\n        mod = 10**9 + 7\n\n        for num in nums:\n            for i in range(total_sum - num, -1, -1):\n                dp[i + num] += dp[i]\n                dp[i + num] %= mod\n\n        return (sum(dp[k:total_sum // 2 + 1]) - 1) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2517", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        max_tastiness = 0\n        \n        for i in range(len(price) - k + 1):\n            min_diff = float('inf')\n            for j in range(i + 1, i + k):\n                min_diff = min(min_diff, price[j] - price[j - 1])\n            max_tastiness = max(max_tastiness, min_diff)\n            \n        return max_tastiness\n```", "extracted_code": "\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        max_tastiness = 0\n        \n        for i in range(len(price) - k + 1):\n            min_diff = float('inf')\n            for j in range(i + 1, i + k):\n                min_diff = min(min_diff, price[j] - price[j - 1])\n            max_tastiness = max(max_tastiness, min_diff)\n            \n        return max_tastiness\n", "difficulty": 2.0}
{"task_id": "LeetCode/2516", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        if k == 0:\n            return 0\n        count = [0, 0, 0]\n        for char in s:\n            count[ord(char) - ord('a')] += 1\n        if min(count) < k:\n            return -1\n\n        n = len(s)\n        ans = n\n        left, right = 0, 0\n        temp_count = [0, 0, 0]\n        while right < n:\n            temp_count[ord(s[right]) - ord('a')] += 1\n            while all(temp_count[i] >= k for i in range(3)):\n                ans = min(ans, right - left + 1)\n                temp_count[ord(s[left]) - ord('a')] -= 1\n                left += 1\n            right += 1\n\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        if k == 0:\n            return 0\n        count = [0, 0, 0]\n        for char in s:\n            count[ord(char) - ord('a')] += 1\n        if min(count) < k:\n            return -1\n\n        n = len(s)\n        ans = n\n        left, right = 0, 0\n        temp_count = [0, 0, 0]\n        while right < n:\n            temp_count[ord(s[right]) - ord('a')] += 1\n            while all(temp_count[i] >= k for i in range(3)):\n                ans = min(ans, right - left + 1)\n                temp_count[ord(s[left]) - ord('a')] -= 1\n                left += 1\n            right += 1\n\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2515", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\n        n = len(words)\n        if target not in words:\n            return -1\n        left_steps, right_steps = 0, 0\n        left_index, right_index = startIndex, startIndex\n        \n        while words[left_index] != target:\n            left_index = (left_index - 1 + n) % n\n            left_steps += 1\n            \n        while words[right_index] != target:\n            right_index = (right_index + 1) % n\n            right_steps += 1\n            \n        return min(left_steps, right_steps)\n```", "extracted_code": "\nclass Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\n        n = len(words)\n        if target not in words:\n            return -1\n        left_steps, right_steps = 0, 0\n        left_index, right_index = startIndex, startIndex\n        \n        while words[left_index] != target:\n            left_index = (left_index - 1 + n) % n\n            left_steps += 1\n            \n        while words[right_index] != target:\n            right_index = (right_index + 1) % n\n            right_steps += 1\n            \n        return min(left_steps, right_steps)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2514", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from math import factorial\n\n        def count_permutations(word):\n            counts = {}\n            for letter in word:\n                if letter in counts:\n                    counts[letter] += 1\n                else:\n                    counts[letter] = 1\n            return factorial(len(word)) // (sum(factorial(count) for count in counts.values()))\n\n        words = s.split()\n        mod = 10**9 + 7\n        res = 1\n        for word in words:\n            res *= count_permutations(word)\n            res %= mod\n\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from math import factorial\n\n        def count_permutations(word):\n            counts = {}\n            for letter in word:\n                if letter in counts:\n                    counts[letter] += 1\n                else:\n                    counts[letter] = 1\n            return factorial(len(word)) // (sum(factorial(count) for count in counts.values()))\n\n        words = s.split()\n        mod = 10**9 + 7\n        res = 1\n        for word in words:\n            res *= count_permutations(word)\n            res %= mod\n\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2513", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        i = 1\n        cnt1, cnt2 = 0, 0\n        while cnt1 < uniqueCnt1 or cnt2 < uniqueCnt2:\n            if cnt1 < uniqueCnt1 and i % divisor1 != 0:\n                cnt1 += 1\n            elif cnt2 < uniqueCnt2 and i % divisor2 != 0:\n                cnt2 += 1\n            i += 1\n        return i - 1\n```", "extracted_code": "\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        i = 1\n        cnt1, cnt2 = 0, 0\n        while cnt1 < uniqueCnt1 or cnt2 < uniqueCnt2:\n            if cnt1 < uniqueCnt1 and i % divisor1 != 0:\n                cnt1 += 1\n            elif cnt2 < uniqueCnt2 and i % divisor2 != 0:\n                cnt2 += 1\n            i += 1\n        return i - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2512", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        points_dict = {}\n        \n        for i in range(len(report)):\n            words = report[i].split()\n            student_points = 0\n            \n            for word in words:\n                if word in positive_feedback:\n                    student_points += 3\n                elif word in negative_feedback:\n                    student_points -= 1\n                    \n            points_dict[student_id[i]] = student_points\n            \n        sorted_students = sorted(points_dict.items(), key=lambda x: (-x[1], x[0]))\n        \n        return [student[0] for student in sorted_students[:k]]\n```", "extracted_code": "\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        points_dict = {}\n        \n        for i in range(len(report)):\n            words = report[i].split()\n            student_points = 0\n            \n            for word in words:\n                if word in positive_feedback:\n                    student_points += 3\n                elif word in negative_feedback:\n                    student_points -= 1\n                    \n            points_dict[student_id[i]] = student_points\n            \n        sorted_students = sorted(points_dict.items(), key=lambda x: (-x[1], x[0]))\n        \n        return [student[0] for student in sorted_students[:k]]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2511", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def captureForts(self, forts: List[int]) -> int:\n        max_captured = 0\n        for i in range(len(forts)):\n            if forts[i] == 1:\n                count = 0\n                j = i + 1\n                while j < len(forts) and forts[j] != 1:\n                    if forts[j] == 0:\n                        count += 1\n                    elif forts[j] == -1 and count > 0:\n                        max_captured = max(max_captured, count)\n                        count = 0\n                    j += 1\n        return max_captured\n```\n", "extracted_code": "\nclass Solution:\n    def captureForts(self, forts: List[int]) -> int:\n        max_captured = 0\n        for i in range(len(forts)):\n            if forts[i] == 1:\n                count = 0\n                j = i + 1\n                while j < len(forts) and forts[j] != 1:\n                    if forts[j] == 0:\n                        count += 1\n                    elif forts[j] == -1 and count > 0:\n                        max_captured = max(max_captured, count)\n                        count = 0\n                    j += 1\n        return max_captured\n", "difficulty": 1.0}
{"task_id": "LeetCode/2509", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_depth(val):\n            depth = 0\n            while val > 1:\n                val //= 2\n                depth += 1\n            return depth\n\n        answer = []\n        for a, b in queries:\n            depth_a = find_depth(a)\n            depth_b = find_depth(b)\n            while depth_a > depth_b:\n                a //= 2\n                depth_a -= 1\n            while depth_b > depth_a:\n                b //= 2\n                depth_b -= 1\n            while a != b:\n                a //= 2\n                b //= 2\n                depth_a -= 1\n                depth_b -= 1\n            answer.append(depth_a + depth_b + 1)\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def find_depth(val):\n            depth = 0\n            while val > 1:\n                val //= 2\n                depth += 1\n            return depth\n\n        answer = []\n        for a, b in queries:\n            depth_a = find_depth(a)\n            depth_b = find_depth(b)\n            while depth_a > depth_b:\n                a //= 2\n                depth_a -= 1\n            while depth_b > depth_a:\n                b //= 2\n                depth_b -= 1\n            while a != b:\n                a //= 2\n                b //= 2\n                depth_a -= 1\n                depth_b -= 1\n            answer.append(depth_a + depth_b + 1)\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2508", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for edge in edges:\n            degree[edge[0]] += 1\n            degree[edge[1]] += 1\n        \n        odd_degree_count = sum(1 for d in degree if d % 2 == 1)\n        \n        if odd_degree_count == 0:\n            return True\n        elif odd_degree_count == 2:\n            return True\n        elif odd_degree_count == 4:\n            odd_degree_nodes = [i for i, d in enumerate(degree) if d % 2 == 1]\n            for i in range(4):\n                for j in range(i + 1, 4):\n                    if (odd_degree_nodes[i], odd_degree_nodes[j]) not in edges and (odd_degree_nodes[j], odd_degree_nodes[i]) not in edges:\n                        return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for edge in edges:\n            degree[edge[0]] += 1\n            degree[edge[1]] += 1\n        \n        odd_degree_count = sum(1 for d in degree if d % 2 == 1)\n        \n        if odd_degree_count == 0:\n            return True\n        elif odd_degree_count == 2:\n            return True\n        elif odd_degree_count == 4:\n            odd_degree_nodes = [i for i, d in enumerate(degree) if d % 2 == 1]\n            for i in range(4):\n                for j in range(i + 1, 4):\n                    if (odd_degree_nodes[i], odd_degree_nodes[j]) not in edges and (odd_degree_nodes[j], odd_degree_nodes[i]) not in edges:\n                        return True\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2507", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(num):\n            i = 2\n            factors = []\n            while i * i <= num:\n                if num % i:\n                    i += 1\n                else:\n                    num //= i\n                    factors.append(i)\n            if num > 1:\n                factors.append(num)\n            return factors\n\n        while True:\n            factors = prime_factors(n)\n            if len(factors) == 1:\n                return n\n            n = sum(factors)\n```", "extracted_code": "\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(num):\n            i = 2\n            factors = []\n            while i * i <= num:\n                if num % i:\n                    i += 1\n                else:\n                    num //= i\n                    factors.append(i)\n            if num > 1:\n                factors.append(num)\n            return factors\n\n        while True:\n            factors = prime_factors(n)\n            if len(factors) == 1:\n                return n\n            n = sum(factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2506", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def similarPairs(self, words: List[str]) -> int:\n        def signature(word):\n            return ''.join(sorted(set(word)))\n        \n        signatures = [signature(word) for word in words]\n        counter = 0\n        \n        for i in range(len(words) - 1):\n            for j in range(i + 1, len(words)):\n                if signatures[i] == signatures[j]:\n                    counter += 1\n                    \n        return counter\n```", "extracted_code": "\nclass Solution:\n    def similarPairs(self, words: List[str]) -> int:\n        def signature(word):\n            return ''.join(sorted(set(word)))\n        \n        signatures = [signature(word) for word in words]\n        counter = 0\n        \n        for i in range(len(words) - 1):\n            for j in range(i + 1, len(words)):\n                if signatures[i] == signatures[j]:\n                    counter += 1\n                    \n        return counter\n", "difficulty": 1.0}
{"task_id": "LeetCode/2503", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        def dfs(x, y, q):\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] >= q:\n                return 0\n            visited[x][y] = True\n            points = 1\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                points += dfs(x + dx, y + dy, q)\n            visited[x][y] = False\n            return points\n\n        m, n = len(grid), len(grid[0])\n        answer = []\n        for q in queries:\n            visited = [[False] * n for _ in range(m)]\n            answer.append(dfs(0, 0, q))\n        return answer", "extracted_code": "class Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        def dfs(x, y, q):\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] >= q:\n                return 0\n            visited[x][y] = True\n            points = 1\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                points += dfs(x + dx, y + dy, q)\n            visited[x][y] = False\n            return points\n\n        m, n = len(grid), len(grid[0])\n        answer = []\n        for q in queries:\n            visited = [[False] * n for _ in range(m)]\n            answer.append(dfs(0, 0, q))\n        return answer", "difficulty": 3.0}
{"task_id": "LeetCode/2502", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "class Allocator:\n\n    def __init__(self, n: int):\n        self.memory = [0] * n\n\n    def allocate(self, size: int, mID: int) -> int:\n        for i in range(len(self.memory) - size + 1):\n            if all(x == 0 for x in self.memory[i:i + size]):\n                for j in range(i, i + size):\n                    self.memory[j] = mID\n                return i\n        return -1\n\n    def free(self, mID: int) -> int:\n        freed_units = 0\n        for i in range(len(self.memory)):\n            if self.memory[i] == mID:\n                self.memory[i] = 0\n                freed_units += 1\n        return freed_units\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator(n)\n# param_1 = obj.allocate(size,mID)\n# param_2 = obj.free(mID)", "extracted_code": "class Allocator:\n\n    def __init__(self, n: int):\n        self.memory = [0] * n\n\n    def allocate(self, size: int, mID: int) -> int:\n        for i in range(len(self.memory) - size + 1):\n            if all(x == 0 for x in self.memory[i:i + size]):\n                for j in range(i, i + size):\n                    self.memory[j] = mID\n                return i\n        return -1\n\n    def free(self, mID: int) -> int:\n        freed_units = 0\n        for i in range(len(self.memory)):\n            if self.memory[i] == mID:\n                self.memory[i] = 0\n                freed_units += 1\n        return freed_units\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator(n)\n# param_1 = obj.allocate(size,mID)\n# param_2 = obj.free(mID)", "difficulty": 2.0}
{"task_id": "LeetCode/2501", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        longest_streak = -1\n\n        for num in nums_set:\n            streak = 1\n            while num * num in nums_set:\n                streak += 1\n                num = num * num\n            longest_streak = max(longest_streak, streak)\n\n        return longest_streak if longest_streak > 1 else -1", "extracted_code": "class Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        longest_streak = -1\n\n        for num in nums_set:\n            streak = 1\n            while num * num in nums_set:\n                streak += 1\n                num = num * num\n            longest_streak = max(longest_streak, streak)\n\n        return longest_streak if longest_streak > 1 else -1", "difficulty": 2.0}
{"task_id": "LeetCode/2500", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        answer = 0\n        while grid[0]:\n            max_values = []\n            for row in grid:\n                max_value = max(row)\n                row.remove(max_value)\n                max_values.append(max_value)\n            answer += max(max_values)\n        return answer", "extracted_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        answer = 0\n        while grid[0]:\n            max_values = []\n            for row in grid:\n                max_value = max(row)\n                row.remove(max_value)\n                max_values.append(max_value)\n            answer += max(max_values)\n        return answer", "difficulty": 1.0}
{"task_id": "LeetCode/2499", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        swap_indices = [[] for _ in range(n + 1)]\n        visited = [False] * n\n        cost = 0\n\n        for i in range(n):\n            if nums1[i] != nums2[i]:\n                swap_indices[nums1[i]].append(i)\n\n        for i in range(n):\n            if not visited[i] and nums1[i] != nums2[i]:\n                cycle = []\n                index = i\n\n                while not visited[index]:\n                    visited[index] = True\n                    cycle.append(index)\n                    index = swap_indices[nums2[index]].pop()\n\n                cycle_size = len(cycle)\n                if cycle_size == 1:\n                    return -1\n                cost += (cycle_size - 1) * min(cycle)\n\n        return cost", "extracted_code": "class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        swap_indices = [[] for _ in range(n + 1)]\n        visited = [False] * n\n        cost = 0\n\n        for i in range(n):\n            if nums1[i] != nums2[i]:\n                swap_indices[nums1[i]].append(i)\n\n        for i in range(n):\n            if not visited[i] and nums1[i] != nums2[i]:\n                cycle = []\n                index = i\n\n                while not visited[index]:\n                    visited[index] = True\n                    cycle.append(index)\n                    index = swap_indices[nums2[index]].pop()\n\n                cycle_size = len(cycle)\n                if cycle_size == 1:\n                    return -1\n                cost += (cycle_size - 1) * min(cycle)\n\n        return cost", "difficulty": 3.0}
{"task_id": "LeetCode/2498", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [float('inf')] * n\n        dp[0] = 0\n        \n        for i in range(1, n):\n            for j in range(i):\n                if stones[i] - stones[j] <= stones[j]:\n                    dp[i] = min(dp[i], max(dp[j], stones[i] - stones[j]))\n        \n        return dp[n-1]\n```", "extracted_code": "\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [float('inf')] * n\n        dp[0] = 0\n        \n        for i in range(1, n):\n            for j in range(i):\n                if stones[i] - stones[j] <= stones[j]:\n                    dp[i] = min(dp[i], max(dp[j], stones[i] - stones[j]))\n        \n        return dp[n-1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2497", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        from collections import defaultdict\n        \n        adjList = defaultdict(list)\n        for a, b in edges:\n            adjList[a].append(b)\n            adjList[b].append(a)\n        \n        max_sum = float('-inf')\n        for center in range(len(vals)):\n            neighbors = sorted([vals[neighbor] for neighbor in adjList[center]], reverse=True)\n            max_sum = max(max_sum, vals[center] + sum(neighbors[:k]))\n        \n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        from collections import defaultdict\n        \n        adjList = defaultdict(list)\n        for a, b in edges:\n            adjList[a].append(b)\n            adjList[b].append(a)\n        \n        max_sum = float('-inf')\n        for center in range(len(vals)):\n            neighbors = sorted([vals[neighbor] for neighbor in adjList[center]], reverse=True)\n            max_sum = max(max_sum, vals[center] + sum(neighbors[:k]))\n        \n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2496", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximumValue(self, strs: List[str]) -> int:\n        max_value = 0\n        for string in strs:\n            if string.isdigit():\n                max_value = max(max_value, int(string))\n            else:\n                max_value = max(max_value, len(string))\n        return max_value\n```", "extracted_code": "\nclass Solution:\n    def maximumValue(self, strs: List[str]) -> int:\n        max_value = 0\n        for string in strs:\n            if string.isdigit():\n                max_value = max(max_value, int(string))\n            else:\n                max_value = max(max_value, len(string))\n        return max_value\n", "difficulty": 1.0}
{"task_id": "LeetCode/2493", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n\n        def bfs(node: int) -> int:\n            queue = [(node, 0)]\n            visited = {node}\n            max_depth = 0\n\n            while queue:\n                current_node, depth = queue.pop(0)\n                max_depth = max(max_depth, depth)\n                for neighbor in graph[current_node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, depth + 1))\n\n            return max_depth\n\n        graph = defaultdict(list)\n        for ai, bi in edges:\n            graph[ai].append(bi)\n            graph[bi].append(ai)\n\n        max_groups = 0\n        for node in range(1, n + 1):\n            if node not in graph:\n                max_groups += 1\n            else:\n                max_groups = max(max_groups, bfs(node))\n\n        return max_groups if max_groups > 1 else -1\n```", "extracted_code": "\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        from collections import defaultdict\n\n        def bfs(node: int) -> int:\n            queue = [(node, 0)]\n            visited = {node}\n            max_depth = 0\n\n            while queue:\n                current_node, depth = queue.pop(0)\n                max_depth = max(max_depth, depth)\n                for neighbor in graph[current_node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, depth + 1))\n\n            return max_depth\n\n        graph = defaultdict(list)\n        for ai, bi in edges:\n            graph[ai].append(bi)\n            graph[bi].append(ai)\n\n        max_groups = 0\n        for node in range(1, n + 1):\n            if node not in graph:\n                max_groups += 1\n            else:\n                max_groups = max(max_groups, bfs(node))\n\n        return max_groups if max_groups > 1 else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2492", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\n        adj = [[] for _ in range(n+1)]\n        for a, b, d in roads:\n            adj[a].append((b, d))\n            adj[b].append((a, d))\n\n        visited = [False] * (n+1)\n        min_score = float('inf')\n\n        def dfs(city, score):\n            nonlocal min_score\n            if city == n:\n                min_score = min(min_score, score)\n                return\n\n            visited[city] = True\n            for next_city, dist in adj[city]:\n                if not visited[next_city]:\n                    dfs(next_city, max(score, dist))\n            visited[city] = False\n\n        dfs(1, 0)\n        return min_score\n```\n", "extracted_code": "\nclass Solution:\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\n        adj = [[] for _ in range(n+1)]\n        for a, b, d in roads:\n            adj[a].append((b, d))\n            adj[b].append((a, d))\n\n        visited = [False] * (n+1)\n        min_score = float('inf')\n\n        def dfs(city, score):\n            nonlocal min_score\n            if city == n:\n                min_score = min(min_score, score)\n                return\n\n            visited[city] = True\n            for next_city, dist in adj[city]:\n                if not visited[next_city]:\n                    dfs(next_city, max(score, dist))\n            visited[city] = False\n\n        dfs(1, 0)\n        return min_score\n", "difficulty": 2.0}
{"task_id": "LeetCode/2491", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def dividePlayers(self, skill: List[int]) -> int:\n        total_sum = sum(skill)\n        if total_sum % (len(skill) // 2) != 0:\n            return -1\n\n        target_sum = total_sum // (len(skill) // 2)\n        skill.sort()\n        chemistry = 0\n\n        i = 0\n        while i < len(skill) - 1:\n            if skill[i] + skill[i + 1] == target_sum:\n                chemistry += skill[i] * skill[i + 1]\n                skill.pop(i + 1)\n                skill.pop(i)\n            else:\n                i += 1\n\n        if len(skill) > 0:\n            return -1\n\n        return chemistry\n```", "extracted_code": "\nclass Solution:\n    def dividePlayers(self, skill: List[int]) -> int:\n        total_sum = sum(skill)\n        if total_sum % (len(skill) // 2) != 0:\n            return -1\n\n        target_sum = total_sum // (len(skill) // 2)\n        skill.sort()\n        chemistry = 0\n\n        i = 0\n        while i < len(skill) - 1:\n            if skill[i] + skill[i + 1] == target_sum:\n                chemistry += skill[i] * skill[i + 1]\n                skill.pop(i + 1)\n                skill.pop(i)\n            else:\n                i += 1\n\n        if len(skill) > 0:\n            return -1\n\n        return chemistry\n", "difficulty": 2.0}
{"task_id": "LeetCode/2490", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isCircularSentence(self, sentence: str) -> bool:\n        words = sentence.split()\n        for i in range(len(words)):\n            if i + 1 < len(words):\n                if words[i][-1] != words[i + 1][0]:\n                    return False\n            else:\n                if words[i][-1] != words[0][0]:\n                    return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isCircularSentence(self, sentence: str) -> bool:\n        words = sentence.split()\n        for i in range(len(words)):\n            if i + 1 < len(words):\n                if words[i][-1] != words[i + 1][0]:\n                    return False\n            else:\n                if words[i][-1] != words[0][0]:\n                    return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2488", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)+1):\n                subarray = nums[i:j]\n                subarray.sort()\n                median = subarray[(len(subarray) - 1) // 2]\n                if median == k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)+1):\n                subarray = nums[i:j]\n                subarray.sort()\n                median = subarray[(len(subarray) - 1) // 2]\n                if median == k:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2487", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        max_val = -1\n        node = head\n        prev = None\n\n        while node:\n            if node.val > max_val:\n                max_val = node.val\n                prev = node\n            else:\n                prev.next = node.next\n            node = node.next\n\n        return head\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        max_val = -1\n        node = head\n        prev = None\n\n        while node:\n            if node.val > max_val:\n                max_val = node.val\n                prev = node\n            else:\n                prev.next = node.next\n            node = node.next\n\n        return head\n", "difficulty": 2.0}
{"task_id": "LeetCode/2486", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def appendCharacters(self, s: str, t: str) -> int:\n        s_len, t_len = len(s), len(t)\n        dp = [0] * (t_len + 1)\n        for i in range(s_len):\n            for j in range(t_len, 0, -1):\n                if t[j - 1] == s[i]:\n                    dp[j] = dp[j - 1] + 1\n            dp[0] = 0\n        min_append = float('inf')\n        for i in range(s_len + 1):\n            if dp[i] == t_len:\n                min_append = min(min_append, s_len - i)\n        return min_append if min_append != float('inf') else t_len\n```", "extracted_code": "\nclass Solution:\n    def appendCharacters(self, s: str, t: str) -> int:\n        s_len, t_len = len(s), len(t)\n        dp = [0] * (t_len + 1)\n        for i in range(s_len):\n            for j in range(t_len, 0, -1):\n                if t[j - 1] == s[i]:\n                    dp[j] = dp[j - 1] + 1\n            dp[0] = 0\n        min_append = float('inf')\n        for i in range(s_len + 1):\n            if dp[i] == t_len:\n                min_append = min(min_append, s_len - i)\n        return min_append if min_append != float('inf') else t_len\n", "difficulty": 2.0}
{"task_id": "LeetCode/2485", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def pivotInteger(self, n: int) -> int:\n        total_sum = n * (n + 1) // 2\n        left_sum = 0\n        for i in range(1, n + 1):\n            left_sum += i\n            right_sum = total_sum - left_sum\n            if left_sum == right_sum:\n                return i\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def pivotInteger(self, n: int) -> int:\n        total_sum = n * (n + 1) // 2\n        left_sum = 0\n        for i in range(1, n + 1):\n            left_sum += i\n            right_sum = total_sum - left_sum\n            if left_sum == right_sum:\n                return i\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2484", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        dp = [[0] * 10 for _ in range(n+1)]\n        \n        for i in range(n-1, -1, -1):\n            for j in range(10):\n                dp[i][j] = dp[i+1][j]\n            dp[i][int(s[i])] += 1\n        \n        ans = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                ans += dp[j+1][int(s[i])] * dp[i+1][int(s[j])]\n                ans %= mod\n        \n        return ans\n```", "extracted_code": "\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        dp = [[0] * 10 for _ in range(n+1)]\n        \n        for i in range(n-1, -1, -1):\n            for j in range(10):\n                dp[i][j] = dp[i+1][j]\n            dp[i][int(s[i])] += 1\n        \n        ans = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                ans += dp[j+1][int(s[i])] * dp[i+1][int(s[j])]\n                ans %= mod\n        \n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2483", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        penalty = [0] * (n + 1)\n        open_penalty = 0\n        closed_penalty = customers.count('Y')\n\n        for i in range(n):\n            if customers[i] == 'Y':\n                closed_penalty -= 1\n            else:\n                open_penalty += 1\n            penalty[i + 1] = open_penalty + closed_penalty\n\n        return penalty.index(min(penalty))\n```", "extracted_code": "\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        penalty = [0] * (n + 1)\n        open_penalty = 0\n        closed_penalty = customers.count('Y')\n\n        for i in range(n):\n            if customers[i] == 'Y':\n                closed_penalty -= 1\n            else:\n                open_penalty += 1\n            penalty[i + 1] = open_penalty + closed_penalty\n\n        return penalty.index(min(penalty))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2482", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "class Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow = [sum(row) for row in grid]\n        onesCol = [sum(grid[i][j] for i in range(m)) for j in range(n)]\n        zerosRow = [n - ones for ones in onesRow]\n        zerosCol = [m - ones for ones in onesCol]\n\n        diff = [[onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j] for j in range(n)] for i in range(m)]\n\n        return diff", "extracted_code": "class Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        onesRow = [sum(row) for row in grid]\n        onesCol = [sum(grid[i][j] for i in range(m)) for j in range(n)]\n        zerosRow = [n - ones for ones in onesRow]\n        zerosCol = [m - ones for ones in onesCol]\n\n        diff = [[onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j] for j in range(n)] for i in range(m)]\n\n        return diff", "difficulty": 2.0}
{"task_id": "LeetCode/2481", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n == 1:\n            return 0\n        elif n % 2 == 0:\n            return n // 2\n        else:\n            return n\n```", "extracted_code": "\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        if n == 1:\n            return 0\n        elif n % 2 == 0:\n            return n // 2\n        else:\n            return n\n", "difficulty": 1.0}
{"task_id": "LeetCode/2478", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        prime_digits = {'2', '3', '5', '7'}\n        n = len(s)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(n):\n            sum_dp = [0] * (k + 1)\n            sum_dp[0] = dp[i][0]\n            for j in range(1, k + 1):\n                sum_dp[j] = (sum_dp[j - 1] + dp[i][j]) % MOD\n\n            for j in range(k + 1):\n                if s[i] in prime_digits:\n                    left = max(0, i - minLength + 1)\n                    dp[i + 1][j] = (dp[i + 1][j] + sum_dp[j - 1] - sum_dp[left - 1]) % MOD\n                \n                if s[i + 1 - minLength] not in prime_digits:\n                    dp[i + 1][j] = (dp[i + 1][j] - dp[i + 1 - minLength][j - 1]) % MOD\n\n        return dp[-1][-1]\n```", "extracted_code": "\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        prime_digits = {'2', '3', '5', '7'}\n        n = len(s)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(n):\n            sum_dp = [0] * (k + 1)\n            sum_dp[0] = dp[i][0]\n            for j in range(1, k + 1):\n                sum_dp[j] = (sum_dp[j - 1] + dp[i][j]) % MOD\n\n            for j in range(k + 1):\n                if s[i] in prime_digits:\n                    left = max(0, i - minLength + 1)\n                    dp[i + 1][j] = (dp[i + 1][j] + sum_dp[j - 1] - sum_dp[left - 1]) % MOD\n                \n                if s[i + 1 - minLength] not in prime_digits:\n                    dp[i + 1][j] = (dp[i + 1][j] - dp[i + 1 - minLength][j - 1]) % MOD\n\n        return dp[-1][-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2477", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        from collections import defaultdict, deque\n\n        graph = defaultdict(list)\n        for a, b in roads:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        queue = deque([(0, 0)])\n        visited = set()\n        fuel_cost = 0\n\n        while queue:\n            cur_city, level = queue.popleft()\n            visited.add(cur_city)\n\n            if cur_city != 0:\n                fuel_cost += (level + seats - 1) // seats\n\n            for neighbor in graph[cur_city]:\n                if neighbor not in visited:\n                    queue.append((neighbor, level + 1))\n\n        return fuel_cost", "extracted_code": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        from collections import defaultdict, deque\n\n        graph = defaultdict(list)\n        for a, b in roads:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        queue = deque([(0, 0)])\n        visited = set()\n        fuel_cost = 0\n\n        while queue:\n            cur_city, level = queue.popleft()\n            visited.add(cur_city)\n\n            if cur_city != 0:\n                fuel_cost += (level + seats - 1) // seats\n\n            for neighbor in graph[cur_city]:\n                if neighbor not in visited:\n                    queue.append((neighbor, level + 1))\n\n        return fuel_cost", "difficulty": 2.0}
{"task_id": "LeetCode/2476", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n    def dfs(node, min_val, max_val):\n        if not node:\n            return\n        if node.val > min_val:\n            dfs(node.left, min_val, min(max_val, node.val - 1))\n        if node.val < max_val:\n            dfs(node.right, max(node.val + 1, min_val), max_val)\n\n    def findClosest(node, query):\n        min_val, max_val = -1, -1\n        while node:\n            if node.val <= query:\n                min_val = node.val\n                node = node.right\n            else:\n                max_val = node.val\n                node = node.left\n        return [min_val, max_val]\n\n    answer = []\n    for query in queries:\n        answer.append(findClosest(root, query))\n    return answer", "extracted_code": "def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n    def dfs(node, min_val, max_val):\n        if not node:\n            return\n        if node.val > min_val:\n            dfs(node.left, min_val, min(max_val, node.val - 1))\n        if node.val < max_val:\n            dfs(node.right, max(node.val + 1, min_val), max_val)\n\n    def findClosest(node, query):\n        min_val, max_val = -1, -1\n        while node:\n            if node.val <= query:\n                min_val = node.val\n                node = node.right\n            else:\n                max_val = node.val\n                node = node.left\n        return [min_val, max_val]\n\n    answer = []\n    for query in queries:\n        answer.append(findClosest(root, query))\n    return answer", "difficulty": 2.0}
{"task_id": "LeetCode/2475", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def unequalTriplets(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                        count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def unequalTriplets(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                        count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/2472", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        def is_palindrome(subs: str) -> bool:\n            return subs == subs[::-1]\n\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(n - k + 1):\n            for j in range(i + k - 1, n):\n                if is_palindrome(s[i:j + 1]):\n                    dp[i] = max(dp[i], j - i + 1)\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(dp[i], dp[i + 1])\n\n        result = 0\n        for i in range(n):\n            result = max(result, dp[i] + dp[i + dp[i]])\n        return result\n```", "extracted_code": "\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        def is_palindrome(subs: str) -> bool:\n            return subs == subs[::-1]\n\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(n - k + 1):\n            for j in range(i + k - 1, n):\n                if is_palindrome(s[i:j + 1]):\n                    dp[i] = max(dp[i], j - i + 1)\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(dp[i], dp[i + 1])\n\n        result = 0\n        for i in range(n):\n            result = max(result, dp[i] + dp[i + dp[i]])\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2471", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        level_values = defaultdict(list)\n\n        def dfs(node, level):\n            if not node:\n                return\n            level_values[level].append(node.val)\n            dfs(node.left, level + 1)\n            dfs(node.right, level + 1)\n\n        dfs(root, 0)\n\n        operations = 0\n        for values in level_values.values():\n            sorted_values = sorted(values)\n            for i in range(1, len(values)):\n                if values[i] < values[i - 1]:\n                    operations += 1\n                    values[i], values[i - 1] = values[i - 1], values[i]\n\n        return operations\n```", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        level_values = defaultdict(list)\n\n        def dfs(node, level):\n            if not node:\n                return\n            level_values[level].append(node.val)\n            dfs(node.left, level + 1)\n            dfs(node.right, level + 1)\n\n        dfs(root, 0)\n\n        operations = 0\n        for values in level_values.values():\n            sorted_values = sorted(values)\n            for i in range(1, len(values)):\n                if values[i] < values[i - 1]:\n                    operations += 1\n                    values[i], values[i - 1] = values[i - 1], values[i]\n\n        return operations\n", "difficulty": 2.0}
{"task_id": "LeetCode/2470", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n\n        count = 0\n        for i in range(len(nums)):\n            current_lcm = nums[i]\n            for j in range(i, len(nums)):\n                current_lcm = lcm(current_lcm, nums[j])\n                if current_lcm == k:\n                    count += 1\n                elif current_lcm > k:\n                    break\n        return count\n```", "extracted_code": "\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n\n        count = 0\n        for i in range(len(nums)):\n            current_lcm = nums[i]\n            for j in range(i, len(nums)):\n                current_lcm = lcm(current_lcm, nums[j])\n                if current_lcm == k:\n                    count += 1\n                elif current_lcm > k:\n                    break\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2469", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def convertTemperature(self, celsius: float) -> List[float]:\n        kelvin = celsius + 273.15\n        fahrenheit = celsius * 1.80 + 32.00\n        return [kelvin, fahrenheit]\n```", "extracted_code": "\nclass Solution:\n    def convertTemperature(self, celsius: float) -> List[float]:\n        kelvin = celsius + 273.15\n        fahrenheit = celsius * 1.80 + 32.00\n        return [kelvin, fahrenheit]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2468", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "def splitMessage(message: str, limit: int) -> list[str]:\n    min_suffix_length = len(str(len(message))) + 2\n    if limit < min_suffix_length + 1:\n        return []\n\n    parts = []\n    message_length = len(message)\n    total_parts = (message_length - 1) // (limit - min_suffix_length) + 1\n    current_index = 0\n\n    for i in range(1, total_parts + 1):\n        available_length = limit - len(f\"<{i}/{total_parts}>\")\n        part = message[current_index:current_index + available_length]\n        parts.append(f\"{part}<{i}/{total_parts}>\")\n        current_index += available_length\n\n    return parts", "extracted_code": "def splitMessage(message: str, limit: int) -> list[str]:\n    min_suffix_length = len(str(len(message))) + 2\n    if limit < min_suffix_length + 1:\n        return []\n\n    parts = []\n    message_length = len(message)\n    total_parts = (message_length - 1) // (limit - min_suffix_length) + 1\n    current_index = 0\n\n    for i in range(1, total_parts + 1):\n        available_length = limit - len(f\"<{i}/{total_parts}>\")\n        part = message[current_index:current_index + available_length]\n        parts.append(f\"{part}<{i}/{total_parts}>\")\n        current_index += available_length\n\n    return parts", "difficulty": 3.0}
{"task_id": "LeetCode/2467", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node: int, parent: int) -> Tuple[int, int]:\n            if len(tree[node]) == 1 and node != 0:\n                return amount[node], node\n                \n            max_profit, leaf_node = float('-inf'), -1\n            for child in tree[node]:\n                if child == parent: continue\n                \n                profit, leaf = dfs(child, node)\n                profit += amount[node] // 2 if child == bob or leaf == bob else amount[node]\n                \n                if profit > max_profit:\n                    max_profit, leaf_node = profit, leaf\n                    \n            return max_profit, leaf_node\n        \n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        profit, _ = dfs(0, -1)\n        return profit", "extracted_code": "class Solution:\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node: int, parent: int) -> Tuple[int, int]:\n            if len(tree[node]) == 1 and node != 0:\n                return amount[node], node\n                \n            max_profit, leaf_node = float('-inf'), -1\n            for child in tree[node]:\n                if child == parent: continue\n                \n                profit, leaf = dfs(child, node)\n                profit += amount[node] // 2 if child == bob or leaf == bob else amount[node]\n                \n                if profit > max_profit:\n                    max_profit, leaf_node = profit, leaf\n                    \n            return max_profit, leaf_node\n        \n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        profit, _ = dfs(0, -1)\n        return profit", "difficulty": 2.0}
{"task_id": "LeetCode/2466", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        ans = 0\n        for length in range(low, high + 1):\n            num_zeros = (length + zero - 1) // zero\n            num_ones = (length + one - 1) // one\n            ans += (num_zeros * num_ones) % MOD\n            ans %= MOD\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        ans = 0\n        for length in range(low, high + 1):\n            num_zeros = (length + zero - 1) // zero\n            num_ones = (length + one - 1) // one\n            ans += (num_zeros * num_ones) % MOD\n            ans %= MOD\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2465", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distinctAverages(self, nums: List[int]) -> int:\n        nums.sort()\n        averages = set()\n        while nums:\n            min_val, max_val = nums.pop(0), nums.pop(-1)\n            averages.add((min_val + max_val) / 2)\n        return len(averages)\n```", "extracted_code": "\nclass Solution:\n    def distinctAverages(self, nums: List[int]) -> int:\n        nums.sort()\n        averages = set()\n        while nums:\n            min_val, max_val = nums.pop(0), nums.pop(-1)\n            averages.add((min_val + max_val) / 2)\n        return len(averages)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2463", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort()\n        limit_sum = sum([limit for _, limit in factory])\n        left_limits = [0] * len(factory)\n        right_limits = [0] * len(factory)\n\n        for i in range(len(factory)):\n            left_limits[i] = factory[i][1] if i == 0 else left_limits[i - 1] + factory[i][1]\n            right_limits[-i - 1] = factory[-i - 1][1] if i == 0 else right_limits[-i] + factory[-i - 1][1]\n\n        min_dist = float('inf')\n\n        for i, pos in enumerate(robot):\n            left = max(0, i + 1 - (limit_sum - right_limits[-1]))\n            right = min(i + 1, left_limits[-1])\n            left_dist = sum([pos - factory[j][0] for j in range(left, right)]) if left < right else float('inf')\n            right_dist = sum([factory[j][0] - pos for j in range(left, right)]) if left < right else float('inf')\n            min_dist = min(min_dist, left_dist + right_dist)\n\n        return min_dist\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort()\n        limit_sum = sum([limit for _, limit in factory])\n        left_limits = [0] * len(factory)\n        right_limits = [0] * len(factory)\n\n        for i in range(len(factory)):\n            left_limits[i] = factory[i][1] if i == 0 else left_limits[i - 1] + factory[i][1]\n            right_limits[-i - 1] = factory[-i - 1][1] if i == 0 else right_limits[-i] + factory[-i - 1][1]\n\n        min_dist = float('inf')\n\n        for i, pos in enumerate(robot):\n            left = max(0, i + 1 - (limit_sum - right_limits[-1]))\n            right = min(i + 1, left_limits[-1])\n            left_dist = sum([pos - factory[j][0] for j in range(left, right)]) if left < right else float('inf')\n            right_dist = sum([factory[j][0] - pos for j in range(left, right)]) if left < right else float('inf')\n            min_dist = min(min_dist, left_dist + right_dist)\n\n        return min_dist\n", "difficulty": 3.0}
{"task_id": "LeetCode/2462", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        total_cost = 0\n        for _ in range(k):\n            first_candidates = costs[:candidates]\n            last_candidates = costs[-candidates:]\n            min_cost = min(first_candidates + last_candidates)\n            min_index = first_candidates.index(min_cost) if min_cost in first_candidates else len(costs) - 1 - last_candidates[::-1].index(min_cost)\n            total_cost += min_cost\n            costs.pop(min_index)\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        total_cost = 0\n        for _ in range(k):\n            first_candidates = costs[:candidates]\n            last_candidates = costs[-candidates:]\n            min_cost = min(first_candidates + last_candidates)\n            min_index = first_candidates.index(min_cost) if min_cost in first_candidates else len(costs) - 1 - last_candidates[::-1].index(min_cost)\n            total_cost += min_cost\n            costs.pop(min_index)\n        return total_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2461", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        max_sum = 0\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2460", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def applyOperations(self, nums: List[int]) -> List[int]:\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                nums[i] *= 2\n                nums[i + 1] = 0\n        nums_non_zero = [num for num in nums if num != 0]\n        nums_zero = [0] * (len(nums) - len(nums_non_zero))\n        return nums_non_zero + nums_zero\n```", "extracted_code": "\nclass Solution:\n    def applyOperations(self, nums: List[int]) -> List[int]:\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                nums[i] *= 2\n                nums[i + 1] = 0\n        nums_non_zero = [num for num in nums if num != 0]\n        nums_zero = [0] * (len(nums) - len(nums_non_zero))\n        return nums_non_zero + nums_zero\n", "difficulty": 1.0}
{"task_id": "LeetCode/2458", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node):\n            if not node:\n                return 0\n            left_height = dfs(node.left)\n            right_height = dfs(node.right)\n            return 1 + max(left_height, right_height)\n\n        def remove_subtree(node, value):\n            if not node:\n                return None\n            if node.val == value:\n                return None\n            else:\n                node.left = remove_subtree(node.left, value)\n                node.right = remove_subtree(node.right, value)\n                return node\n\n        answer = []\n        for query in queries:\n            temp_root = remove_subtree(root, query)\n            answer.append(dfs(temp_root) - 1)\n\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node):\n            if not node:\n                return 0\n            left_height = dfs(node.left)\n            right_height = dfs(node.right)\n            return 1 + max(left_height, right_height)\n\n        def remove_subtree(node, value):\n            if not node:\n                return None\n            if node.val == value:\n                return None\n            else:\n                node.left = remove_subtree(node.left, value)\n                node.right = remove_subtree(node.right, value)\n                return node\n\n        answer = []\n        for query in queries:\n            temp_root = remove_subtree(root, query)\n            answer.append(dfs(temp_root) - 1)\n\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2457", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        def digit_sum(number: int) -> int:\n            return sum(int(digit) for digit in str(number))\n        \n        x = 0\n        while digit_sum(n + x) > target:\n            x += 1\n        return x\n```", "extracted_code": "\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        def digit_sum(number: int) -> int:\n            return sum(int(digit) for digit in str(number))\n        \n        x = 0\n        while digit_sum(n + x) > target:\n            x += 1\n        return x\n", "difficulty": 2.0}
{"task_id": "LeetCode/2456", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n        popularity = {}\n        max_views = {}\n        \n        for i in range(len(creators)):\n            creator = creators[i]\n            video_id = ids[i]\n            view = views[i]\n            \n            if creator not in popularity:\n                popularity[creator] = view\n                max_views[creator] = (view, video_id)\n            else:\n                popularity[creator] += view\n                if view > max_views[creator][0] or (view == max_views[creator][0] and video_id < max_views[creator][1]):\n                    max_views[creator] = (view, video_id)\n\n        highest_popularity = max(popularity.values())\n        result = []\n        \n        for creator, value in max_views.items():\n            if popularity[creator] == highest_popularity:\n                result.append([creator, value[1]])\n                \n        return result\n```", "extracted_code": "\nclass Solution:\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n        popularity = {}\n        max_views = {}\n        \n        for i in range(len(creators)):\n            creator = creators[i]\n            video_id = ids[i]\n            view = views[i]\n            \n            if creator not in popularity:\n                popularity[creator] = view\n                max_views[creator] = (view, video_id)\n            else:\n                popularity[creator] += view\n                if view > max_views[creator][0] or (view == max_views[creator][0] and video_id < max_views[creator][1]):\n                    max_views[creator] = (view, video_id)\n\n        highest_popularity = max(popularity.values())\n        result = []\n        \n        for creator, value in max_views.items():\n            if popularity[creator] == highest_popularity:\n                result.append([creator, value[1]])\n                \n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2455", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if even_divisible_by_3:\n            return sum(even_divisible_by_3) // len(even_divisible_by_3)\n        else:\n            return 0\n```", "extracted_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if even_divisible_by_3:\n            return sum(even_divisible_by_3) // len(even_divisible_by_3)\n        else:\n            return 0\n", "difficulty": 1.0}
{"task_id": "LeetCode/2454", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        answer = [-1] * len(nums)\n\n        for i in range(len(nums)):\n            while stack and nums[stack[-1]] < nums[i]:\n                if answer[stack[-1]] == -1:\n                    answer[stack[-1]] = nums[i]\n                stack.pop()\n            stack.append(i)\n\n        return answer\n```", "extracted_code": "\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        answer = [-1] * len(nums)\n\n        for i in range(len(nums)):\n            while stack and nums[stack[-1]] < nums[i]:\n                if answer[stack[-1]] == -1:\n                    answer[stack[-1]] = nums[i]\n                stack.pop()\n            stack.append(i)\n\n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2453", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def destroyTargets(self, nums: List[int], space: int) -> int:\n        nums = sorted(list(set(nums)))\n        max_targets_destroyed = 0\n        min_seed = nums[0]\n\n        for i in range(len(nums)):\n            seed = nums[i]\n            targets_destroyed = 0\n\n            for target in nums:\n                if (target - seed) % space == 0:\n                    targets_destroyed += 1\n\n            if targets_destroyed > max_targets_destroyed:\n                max_targets_destroyed = targets_destroyed\n                min_seed = seed\n\n        return min_seed\n```", "extracted_code": "\nclass Solution:\n    def destroyTargets(self, nums: List[int], space: int) -> int:\n        nums = sorted(list(set(nums)))\n        max_targets_destroyed = 0\n        min_seed = nums[0]\n\n        for i in range(len(nums)):\n            seed = nums[i]\n            targets_destroyed = 0\n\n            for target in nums:\n                if (target - seed) % space == 0:\n                    targets_destroyed += 1\n\n            if targets_destroyed > max_targets_destroyed:\n                max_targets_destroyed = targets_destroyed\n                min_seed = seed\n\n        return min_seed\n", "difficulty": 2.0}
{"task_id": "LeetCode/2452", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\n        def count_diffs(word1, word2):\n            return sum(1 for c1, c2 in zip(word1, word2) if c1 != c2)\n\n        def is_match(query, word):\n            diff_count = count_diffs(query, word)\n            return diff_count == 0 or diff_count == 1 or (diff_count == 2 and len(query) > 2)\n\n        return [query for query in queries if any(is_match(query, word) for word in dictionary)]\n```", "extracted_code": "\nclass Solution:\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\n        def count_diffs(word1, word2):\n            return sum(1 for c1, c2 in zip(word1, word2) if c1 != c2)\n\n        def is_match(query, word):\n            diff_count = count_diffs(query, word)\n            return diff_count == 0 or diff_count == 1 or (diff_count == 2 and len(query) > 2)\n\n        return [query for query in queries if any(is_match(query, word) for word in dictionary)]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2451", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def oddString(self, words: List[str]) -> str:\n        def difference(word: str) -> List[int]:\n            return [ord(word[i+1]) - ord(word[i]) for i in range(len(word) - 1)]\n\n        diff_count = {}\n        for word in words:\n            diff = tuple(difference(word))\n            if diff in diff_count:\n                diff_count[diff] += 1\n            else:\n                diff_count[diff] = 1\n\n        odd_diff = min(diff_count, key=diff_count.get)\n\n        for word in words:\n            if tuple(difference(word)) == odd_diff:\n                return word\n```", "extracted_code": "\nclass Solution:\n    def oddString(self, words: List[str]) -> str:\n        def difference(word: str) -> List[int]:\n            return [ord(word[i+1]) - ord(word[i]) for i in range(len(word) - 1)]\n\n        diff_count = {}\n        for word in words:\n            diff = tuple(difference(word))\n            if diff in diff_count:\n                diff_count[diff] += 1\n            else:\n                diff_count[diff] = 1\n\n        odd_diff = min(diff_count, key=diff_count.get)\n\n        for word in words:\n            if tuple(difference(word)) == odd_diff:\n                return word\n", "difficulty": 1.0}
{"task_id": "LeetCode/2449", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        diff = [nums[i] - target[i] for i in range(len(nums))]\n        operations = 0\n        for d in diff:\n            if d % 2 != 0:\n                return -1\n            if d > 0:\n                operations += d // 2\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        diff = [nums[i] - target[i] for i in range(len(nums))]\n        operations = 0\n        for d in diff:\n            if d % 2 != 0:\n                return -1\n            if d > 0:\n                operations += d // 2\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2448", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        nums_cost = sorted(zip(nums, cost), key=lambda x: x[0])\n        total_cost = [0] * n\n        cost_so_far = 0\n\n        for i in range(n):\n            total_cost[i] = cost_so_far + nums_cost[i][1] * (nums_cost[i][0] - (nums_cost[i - 1][0] if i > 0 else 0))\n            cost_so_far += nums_cost[i][1]\n\n        return min(total_cost)\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        nums_cost = sorted(zip(nums, cost), key=lambda x: x[0])\n        total_cost = [0] * n\n        cost_so_far = 0\n\n        for i in range(n):\n            total_cost[i] = cost_so_far + nums_cost[i][1] * (nums_cost[i][0] - (nums_cost[i - 1][0] if i > 0 else 0))\n            cost_so_far += nums_cost[i][1]\n\n        return min(total_cost)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2447", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            g = 0\n            for j in range(i, len(nums)):\n                g = gcd(g, nums[j])\n                if g == k:\n                    count += 1\n                elif g > k:\n                    break\n        return count\n```", "extracted_code": "\nfrom math import gcd\nfrom typing import List\n\nclass Solution:\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            g = 0\n            for j in range(i, len(nums)):\n                g = gcd(g, nums[j])\n                if g == k:\n                    count += 1\n                elif g > k:\n                    break\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2446", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\n        start1, end1 = [int(t) for t in event1[0].split(':')] \n        start2, end2 = [int(t) for t in event1[1].split(':')] \n        start3, end3 = [int(t) for t in event2[0].split(':')] \n        start4, end4 = [int(t) for t in event2[1].split(':')] \n        \n        start1, end1 = start1 * 60 + end1, start2 * 60 + end2\n        start3, end3 = start3 * 60 + end3, start4 * 60 + end4\n        \n        return (start1 < start3 < end1) or (start3 < start1 < end3)\n```", "extracted_code": "\nclass Solution:\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\n        start1, end1 = [int(t) for t in event1[0].split(':')] \n        start2, end2 = [int(t) for t in event1[1].split(':')] \n        start3, end3 = [int(t) for t in event2[0].split(':')] \n        start4, end4 = [int(t) for t in event2[1].split(':')] \n        \n        start1, end1 = start1 * 60 + end1, start2 * 60 + end2\n        start3, end3 = start3 * 60 + end3, start4 * 60 + end4\n        \n        return (start1 < start3 < end1) or (start3 < start1 < end3)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2444", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        result = 0\n        left = right = 0\n        min_count = max_count = 0\n\n        for num in nums:\n            if num > maxK:\n                max_count = 0\n            else:\n                max_count += 1\n                right += max_count\n\n            if num >= minK:\n                min_count = 0\n            else:\n                min_count += 1\n                left += min_count\n\n            result += right - left\n\n        return result\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        result = 0\n        left = right = 0\n        min_count = max_count = 0\n\n        for num in nums:\n            if num > maxK:\n                max_count = 0\n            else:\n                max_count += 1\n                right += max_count\n\n            if num >= minK:\n                min_count = 0\n            else:\n                min_count += 1\n                left += min_count\n\n            result += right - left\n\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2443", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        for i in range(num + 1):\n            reverse_i = int(str(i)[::-1])\n            if i + reverse_i == num:\n                return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        for i in range(num + 1):\n            reverse_i = int(str(i)[::-1])\n            if i + reverse_i == num:\n                return True\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2442", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        distinct_integers = set(nums)\n        for num in nums:\n            reversed_num = int(str(num)[::-1])\n            distinct_integers.add(reversed_num)\n        return len(distinct_integers)\n```", "extracted_code": "\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        distinct_integers = set(nums)\n        for num in nums:\n            reversed_num = int(str(num)[::-1])\n            distinct_integers.add(reversed_num)\n        return len(distinct_integers)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2441", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        max_k = -1\n        for num in nums_set:\n            if num > 0 and -num in nums_set:\n                max_k = max(max_k, num)\n        return max_k\n```", "extracted_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums_set = set(nums)\n        max_k = -1\n        for num in nums_set:\n            if num > 0 and -num in nums_set:\n                max_k = max(max_k, num)\n        return max_k\n", "difficulty": 1.0}
{"task_id": "LeetCode/2440", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node, parent, total):\n            nonlocal res\n            total += nums[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node, total)\n            if total == target:\n                res += 1\n                return 0\n            return total\n        \n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        total_value = sum(nums)\n        if total_value % 2 != 0:\n            return 0\n        \n        target = total_value // 2\n        res = 0\n        dfs(0, -1, 0)\n\n        return res - 1 if res > 0 else 0\n```", "extracted_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        def dfs(node, parent, total):\n            nonlocal res\n            total += nums[node]\n            for neighbor in tree[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node, total)\n            if total == target:\n                res += 1\n                return 0\n            return total\n        \n        tree = defaultdict(list)\n        for a, b in edges:\n            tree[a].append(b)\n            tree[b].append(a)\n        \n        total_value = sum(nums)\n        if total_value % 2 != 0:\n            return 0\n        \n        target = total_value // 2\n        res = 0\n        dfs(0, -1, 0)\n\n        return res - 1 if res > 0 else 0\n", "difficulty": 3.0}
{"task_id": "LeetCode/2439", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeArrayValue(self, nums: List[int]) -> int:\n        return max(nums[0], max(nums[1:]) - 1)\n```", "extracted_code": "\nclass Solution:\n    def minimizeArrayValue(self, nums: List[int]) -> int:\n        return max(nums[0], max(nums[1:]) - 1)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2438", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "class Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def generate_powers(n: int) -> List[int]:\n            powers = []\n            while n > 0:\n                power = 1\n                curr = 2\n                while curr - 1 <= n:\n                    power *= curr\n                    curr *= 2\n                n -= power // 2\n                powers.append(power // 2)\n            return powers\n        \n        powers = generate_powers(n)\n        mod = 10**9 + 7\n        answers = []\n        \n        for left, right in queries:\n            product = 1\n            for j in range(left, right + 1):\n                product *= powers[j]\n                product %= mod\n            answers.append(product)\n        \n        return answers", "extracted_code": "class Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        def generate_powers(n: int) -> List[int]:\n            powers = []\n            while n > 0:\n                power = 1\n                curr = 2\n                while curr - 1 <= n:\n                    power *= curr\n                    curr *= 2\n                n -= power // 2\n                powers.append(power // 2)\n            return powers\n        \n        powers = generate_powers(n)\n        mod = 10**9 + 7\n        answers = []\n        \n        for left, right in queries:\n            product = 1\n            for j in range(left, right + 1):\n                product *= powers[j]\n                product %= mod\n            answers.append(product)\n        \n        return answers", "difficulty": 2.0}
{"task_id": "LeetCode/2437", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countTime(self, time: str) -> int:\n        def count_digits(s: str, max_val: int) -> int:\n            if '?' not in s:\n                return 1 if int(s) <= max_val else 0\n            return sum(1 for i in range(10) if int(s.replace('?', str(i))) <= max_val)\n\n        hours, minutes = time.split(':')\n        return count_digits(hours, 23) * count_digits(minutes, 59)\n```", "extracted_code": "\nclass Solution:\n    def countTime(self, time: str) -> int:\n        def count_digits(s: str, max_val: int) -> int:\n            if '?' not in s:\n                return 1 if int(s) <= max_val else 0\n            return sum(1 for i in range(10) if int(s.replace('?', str(i))) <= max_val)\n\n        hours, minutes = time.split(':')\n        return count_digits(hours, 23) * count_digits(minutes, 59)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2435", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[[0] * k for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0] % k] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                for p in range(k):\n                    if i > 0:\n                        dp[i][j][(p + grid[i][j]) % k] += dp[i - 1][j][p] % mod\n                    if j > 0:\n                        dp[i][j][(p + grid[i][j]) % k] += dp[i][j - 1][p] % mod\n        \n        return dp[m - 1][n - 1][0] % mod\n```\n", "extracted_code": "\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[[0] * k for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0] % k] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                for p in range(k):\n                    if i > 0:\n                        dp[i][j][(p + grid[i][j]) % k] += dp[i - 1][j][p] % mod\n                    if j > 0:\n                        dp[i][j][(p + grid[i][j]) % k] += dp[i][j - 1][p] % mod\n        \n        return dp[m - 1][n - 1][0] % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2434", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = \"\"\n        p = \"\"\n        while s or t:\n            if not t:\n                t += s[0]\n                s = s[1:]\n            elif not s:\n                p += t[-1]\n                t = t[:-1]\n            else:\n                if s[0] < t[-1]:\n                    t += s[0]\n                    s = s[1:]\n                else:\n                    p += t[-1]\n                    t = t[:-1]\n        return p\n```", "extracted_code": "\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = \"\"\n        p = \"\"\n        while s or t:\n            if not t:\n                t += s[0]\n                s = s[1:]\n            elif not s:\n                p += t[-1]\n                t = t[:-1]\n            else:\n                if s[0] < t[-1]:\n                    t += s[0]\n                    s = s[1:]\n                else:\n                    p += t[-1]\n                    t = t[:-1]\n        return p\n", "difficulty": 2.0}
{"task_id": "LeetCode/2433", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findArray(self, pref: List[int]) -> List[int]:\n        arr = [pref[0]]\n        for i in range(1, len(pref)):\n            arr.append(pref[i] ^ pref[i - 1])\n        return arr\n```", "extracted_code": "\nclass Solution:\n    def findArray(self, pref: List[int]) -> List[int]:\n        arr = [pref[0]]\n        for i in range(1, len(pref)):\n            arr.append(pref[i] ^ pref[i - 1])\n        return arr\n", "difficulty": 2.0}
{"task_id": "LeetCode/2432", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        max_time = 0\n        hardest_worker_id = -1\n        prev_time = 0\n        for i in range(len(logs)):\n            task_time = logs[i][1] - prev_time\n            if task_time > max_time:\n                max_time = task_time\n                hardest_worker_id = logs[i][0]\n            prev_time = logs[i][1]\n        return hardest_worker_id\n```", "extracted_code": "\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        max_time = 0\n        hardest_worker_id = -1\n        prev_time = 0\n        for i in range(len(logs)):\n            task_time = logs[i][1] - prev_time\n            if task_time > max_time:\n                max_time = task_time\n                hardest_worker_id = logs[i][0]\n            prev_time = logs[i][1]\n        return hardest_worker_id\n", "difficulty": 1.0}
