{"task_id": "LeetCode/2818", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        prefix = [0]*(n+1)\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            prefix[i] = prefix[i-1] + nums[i-1]\n        for i in range(1, n+1):\n            dp[i] = max(dp[i], dp[i-1]*nums[i-1])\n            for j in range(i):\n                dp[i] = max(dp[i], dp[j]*(prefix[i]-prefix[j]))\n        return dp[n] % mod\n```\n\nThis solution uses dynamic programming to keep track of the maximum score that can be achieved up to each index in the array. The dp array stores the maximum score that can be achieved up to index i. The inner loop iterates over all possible subarrays ending at index i, and for each subarray, it calculates the product of the score up to the start of the subarray and the sum of the subarray. The maximum of these products is then stored in the dp array. The final answer is the maximum score that can be achieved, which is the value in the dp array at the last index.", "extracted_code": "\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        prefix = [0]*(n+1)\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            prefix[i] = prefix[i-1] + nums[i-1]\n        for i in range(1, n+1):\n            dp[i] = max(dp[i], dp[i-1]*nums[i-1])\n            for j in range(i):\n                dp[i] = max(dp[i], dp[j]*(prefix[i]-prefix[j]))\n        return dp[n] % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2813", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nfrom itertools import islice\n\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key=lambda x: (-x[0], -x[1]))\n        max_elegance = 0\n        distinct_categories = set()\n        for item in islice(items, k):\n            max_elegance += item[0]\n            distinct_categories.add(item[1])\n        max_elegance += len(distinct_categories) ** 2\n        return max_elegance\n```\n\nThis function first sorts the items in descending order of profit and then in descending order of category. It then iterates over the first k items of the sorted list and adds their profits to the max_elegance. It also adds their categories to a set to keep track of distinct categories. After the loop, it adds the square of the number of distinct categories to the max_elegance. This gives the maximum elegance of a subsequence of size k.", "extracted_code": "\nfrom typing import List\nfrom itertools import islice\n\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key=lambda x: (-x[0], -x[1]))\n        max_elegance = 0\n        distinct_categories = set()\n        for item in islice(items, k):\n            max_elegance += item[0]\n            distinct_categories.add(item[1])\n        max_elegance += len(distinct_categories) ** 2\n        return max_elegance\n", "difficulty": 3.0}
{"task_id": "LeetCode/2812", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        thieves = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n        dist = [[np.inf]*n for _ in range(n)]\n        for i, j in thieves:\n            for x, y in thieves:\n                if i != x or j != y:\n                    dist[i][j] = min(dist[i][j], abs(i-x) + abs(j-y))\n        return max(dist[n-1][n-1])\n```\n\nThis function works by first finding all the thieves in the grid and storing their positions. Then, for each thief, it calculates the Manhattan distance to all other cells in the grid and stores the minimum distance in a distance matrix. Finally, it returns the maximum value in the last row and column of the distance matrix, which represents the maximum safeness factor of all paths leading to cell (n-1, n-1).", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        thieves = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n        dist = [[np.inf]*n for _ in range(n)]\n        for i, j in thieves:\n            for x, y in thieves:\n                if i != x or j != y:\n                    dist[i][j] = min(dist[i][j], abs(i-x) + abs(j-y))\n        return max(dist[n-1][n-1])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2811", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        total_sum = sum(nums)\n        if total_sum < m:\n            return False\n        max_num = max(nums)\n        if max_num >= m:\n            return True\n        dp = [0] * (total_sum + 1)\n        dp[0] = 1\n        cur_sum = 0\n        for num in nums:\n            cur_sum += num\n            for j in range(cur_sum, num - 1, -1):\n                dp[j] |= dp[j - num]\n        for j in range(total_sum - m + 1, -1, -1):\n            if dp[j]:\n                return True\n        return False\n```", "extracted_code": "\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        total_sum = sum(nums)\n        if total_sum < m:\n            return False\n        max_num = max(nums)\n        if max_num >= m:\n            return True\n        dp = [0] * (total_sum + 1)\n        dp[0] = 1\n        cur_sum = 0\n        for num in nums:\n            cur_sum += num\n            for j in range(cur_sum, num - 1, -1):\n                dp[j] |= dp[j - num]\n        for j in range(total_sum - m + 1, -1, -1):\n            if dp[j]:\n                return True\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2809", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total = sum(nums1)\n        if total <= x:\n            return 0\n        n = len(nums1)\n        l, r = 0, n\n        while l < r:\n            mid = (l + r) // 2\n            if sum(max(0, nums1[i] + nums2[i] - mid) for i in range(n)) <= x:\n                r = mid\n            else:\n                l = mid + 1\n        return l if sum(max(0, nums1[i] + nums2[i] - l) for i in range(n)) <= x else -1\n```", "extracted_code": "\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total = sum(nums1)\n        if total <= x:\n            return 0\n        n = len(nums1)\n        l, r = 0, n\n        while l < r:\n            mid = (l + r) // 2\n            if sum(max(0, nums1[i] + nums2[i] - mid) for i in range(n)) <= x:\n                r = mid\n            else:\n                l = mid + 1\n        return l if sum(max(0, nums1[i] + nums2[i] - l) for i in range(n)) <= x else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2808", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        if len(set(nums)) == 1:\n            return 0\n        else:\n            return 1\n```\n\nThis function checks if all elements in the array are the same. If they are, it returns 0 as no operation is needed. If they are not, it returns 1 because in the worst case, we need to perform one operation to make all elements equal.", "extracted_code": "\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        if len(set(nums)) == 1:\n            return 0\n        else:\n            return 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2807", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            gcd = math.gcd(curr.val, curr.next.val)\n            new_node = ListNode(gcd, curr.next)\n            prev.next = new_node\n            prev = new_node\n            curr = curr.next\n        return dummy.next\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            gcd = math.gcd(curr.val, curr.next.val)\n            new_node = ListNode(gcd, curr.next)\n            prev.next = new_node\n            prev = new_node\n            curr = curr.next\n        return dummy.next\n", "difficulty": 2.0}
{"task_id": "LeetCode/2806", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = round(purchaseAmount / 10) * 10\n        return 100 - roundedAmount\n```", "extracted_code": "\nclass Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = round(purchaseAmount / 10) * 10\n        return 100 - roundedAmount\n", "difficulty": 1.0}
{"task_id": "LeetCode/2801", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        mod = 10**9 + 7\n        n = len(low)\n        dp = [[0]*10 for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(10):\n                for k in range(10):\n                    if abs(k-j) == 1 or k == j == 0:\n                        dp[i][k] = (dp[i][k] + dp[i-1][j]) % mod\n        ans = 0\n        for i in range(1, n+1):\n            for j in range(10):\n                if i == n and j == 0:\n                    continue\n                ans = (ans + dp[i][j]) % mod\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        mod = 10**9 + 7\n        n = len(low)\n        dp = [[0]*10 for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(10):\n                for k in range(10):\n                    if abs(k-j) == 1 or k == j == 0:\n                        dp[i][k] = (dp[i][k] + dp[i-1][j]) % mod\n        ans = 0\n        for i in range(1, n+1):\n            for j in range(10):\n                if i == n and j == 0:\n                    continue\n                ans = (ans + dp[i][j]) % mod\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2800", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        # Find the minimum length among a, b, and c\n        min_len = min(len(a), len(b), len(c))\n        \n        # Initialize the result with the minimum length string\n        result = a if len(a) == min_len else (b if len(b) == min_len else c)\n        \n        # Iterate over the possible positions for the other two strings\n        for i in range(len(result) - min_len + 1):\n            for j in range(i + min_len, len(result) - min_len + 1):\n                # Check if the other two strings can be inserted at the current positions\n                if all(s[i:i+min_len] in result[k:k+min_len] or s[i:i+min_len][::-1] in result[k:k+min_len] for s in (a, b, c) for k in (i, j)):\n                    # Update the result if the current positions give a lexicographically smaller string\n                    result = min(result, result[i:i+min_len] + result[j:j+min_len])\n        \n        return result\n```", "extracted_code": "\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        # Find the minimum length among a, b, and c\n        min_len = min(len(a), len(b), len(c))\n        \n        # Initialize the result with the minimum length string\n        result = a if len(a) == min_len else (b if len(b) == min_len else c)\n        \n        # Iterate over the possible positions for the other two strings\n        for i in range(len(result) - min_len + 1):\n            for j in range(i + min_len, len(result) - min_len + 1):\n                # Check if the other two strings can be inserted at the current positions\n                if all(s[i:i+min_len] in result[k:k+min_len] or s[i:i+min_len][::-1] in result[k:k+min_len] for s in (a, b, c) for k in (i, j)):\n                    # Update the result if the current positions give a lexicographically smaller string\n                    result = min(result, result[i:i+min_len] + result[j:j+min_len])\n        \n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2799", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        distinct_nums = set()\n        left = 0\n        for right in range(n):\n            if nums[right] not in distinct_nums:\n                distinct_nums.add(nums[right])\n            while len(distinct_nums) == len(nums):\n                res += left + 1\n                if nums[left] in distinct_nums:\n                    distinct_nums.remove(nums[left])\n                left += 1\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        distinct_nums = set()\n        left = 0\n        for right in range(n):\n            if nums[right] not in distinct_nums:\n                distinct_nums.add(nums[right])\n            while len(distinct_nums) == len(nums):\n                res += left + 1\n                if nums[left] in distinct_nums:\n                    distinct_nums.remove(nums[left])\n                left += 1\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2791", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        tree = [[] for _ in range(n)]\n        for i in range(1, n):\n            tree[parent[i]].append(i)\n\n        def dfs(node, path):\n            count = [0] * 26\n            for i in path:\n                count[ord(s[i]) - ord('a')] += 1\n            odd = sum(v % 2 for v in count)\n            return (odd + 1) // 2\n\n        def solve(node):\n            count = dfs(node, [])\n            for child in tree[node]:\n                count += solve(child)\n            return count\n\n        return solve(0)\n```\n\nThis solution uses depth-first search (DFS) to traverse the tree. For each node, it calculates the count of each character in the path from the node to the root. Then, it counts the number of odd occurrences of characters, because a palindrome can be formed if and only if there is at most one character with an odd count. The time complexity is O(n log n) due to the sorting of characters, and the space complexity is O(n) for storing the tree and the DFS stack.", "extracted_code": "\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        tree = [[] for _ in range(n)]\n        for i in range(1, n):\n            tree[parent[i]].append(i)\n\n        def dfs(node, path):\n            count = [0] * 26\n            for i in path:\n                count[ord(s[i]) - ord('a')] += 1\n            odd = sum(v % 2 for v in count)\n            return (odd + 1) // 2\n\n        def solve(node):\n            count = dfs(node, [])\n            for child in tree[node]:\n                count += solve(child)\n            return count\n\n        return solve(0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2790", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i):\n                if usageLimits[i] <= usageLimits[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n```\n\nThis function uses dynamic programming to solve the problem. It iterates over the `usageLimits` array and for each element, it checks all the previous elements to find the maximum number of groups that can be formed while satisfying the conditions. The time complexity of this function is O(n^2), where n is the length of the `usageLimits` array.", "extracted_code": "\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i):\n                if usageLimits[i] <= usageLimits[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2788", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            result.extend(word.split(separator))\n        return [item for item in result if item]\n```", "extracted_code": "\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            result.extend(word.split(separator))\n        return [item for item in result if item]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2787", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*(n+1) for _ in range(x+1)]\n        dp[0][0] = 1\n        for i in range(1, x+1):\n            for j in range(1, n+1):\n                dp[i][j] = dp[i][j-1]\n                if j >= i**(i-1):\n                    dp[i][j] += dp[i-1][j-i**(i-1)]\n                dp[i][j] %= MOD\n        return dp[x][n]\n```", "extracted_code": "\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0]*(n+1) for _ in range(x+1)]\n        dp[0][0] = 1\n        for i in range(1, x+1):\n            for j in range(1, n+1):\n                dp[i][j] = dp[i][j-1]\n                if j >= i**(i-1):\n                    dp[i][j] += dp[i-1][j-i**(i-1)]\n                dp[i][j] %= MOD\n        return dp[x][n]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2785", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = {i: c for i, c in enumerate(s) if c in vowels}\n        sorted_vowels = sorted(vowel_indices.values(), key=lambda c: ord(c.lower()))\n        for i, c in vowel_indices.items():\n            s = s[:i] + sorted_vowels.pop(0) + s[i+1:]\n        return s\n```\n\nThis function works by first creating a dictionary `vowel_indices` where the keys are the indices of the vowels in the string `s` and the values are the vowels themselves. The vowels are sorted in nondecreasing order of their ASCII values, and then the sorted vowels are inserted back into the string `s` at their original indices. The consonants remain in their original places because they are not modified.", "extracted_code": "\nclass Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = {i: c for i, c in enumerate(s) if c in vowels}\n        sorted_vowels = sorted(vowel_indices.values(), key=lambda c: ord(c.lower()))\n        for i, c in vowel_indices.items():\n            s = s[:i] + sorted_vowels.pop(0) + s[i+1:]\n        return s\n", "difficulty": 2.0}
{"task_id": "LeetCode/2784", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = len(nums)\n        max_num = max(nums)\n        if n != max_num:\n            return False\n        count = [0] * (n + 1)\n        for num in nums:\n            count[num] += 1\n        if any(x % 2 != 0 for x in count[:-1]):\n            return False\n        if count[-1] < 2:\n            return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        n = len(nums)\n        max_num = max(nums)\n        if n != max_num:\n            return False\n        count = [0] * (n + 1)\n        for num in nums:\n            count[num] += 1\n        if any(x % 2 != 0 for x in count[:-1]):\n            return False\n        if count[-1] < 2:\n            return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2781", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        max_length = 0\n        left = 0\n        for right in range(len(word)):\n            current_word = word[left:right+1]\n            if current_word not in forbidden_set:\n                max_length = max(max_length, len(current_word))\n            else:\n                left = right + 1\n        return max_length\n```\n\nThis function works by iterating over the characters in the word from left to right. For each character, it checks if the current substring is in the forbidden set. If it is not, it updates the maximum length if the length of the current substring is greater than the current maximum length. If the current substring is in the forbidden set, it moves the left pointer to the right of the current character, effectively removing the characters to the left of the current character from the current substring. This ensures that the function only checks substrings that end at the current character, as the problem statement only requires the longest valid substring ending at each character.", "extracted_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        max_length = 0\n        left = 0\n        for right in range(len(word)):\n            current_word = word[left:right+1]\n            if current_word not in forbidden_set:\n                max_length = max(max_length, len(current_word))\n            else:\n                left = right + 1\n        return max_length\n", "difficulty": 3.0}
{"task_id": "LeetCode/2772", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        while min(nums) > 0:\n            for i in range(len(nums) - k + 1):\n                if min(nums[i:i+k]) > 0:\n                    nums[i:i+k] = [x - 1 for x in nums[i:i+k]]\n        return min(nums) == 0\n```\n\nThis function works by iteratively applying the operation on the array until all elements become 0. The operation is applied on the subarrays of size `k` where the minimum element is greater than 0. If after all possible operations, the minimum element is still greater than 0, the function returns `False`. Otherwise, it returns `True`.", "extracted_code": "\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        while min(nums) > 0:\n            for i in range(len(nums) - k + 1):\n                if min(nums[i:i+k]) > 0:\n                    nums[i:i+k] = [x - 1 for x in nums[i:i+k]]\n        return min(nums) == 0\n", "difficulty": 2.0}
{"task_id": "LeetCode/2771", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        nums3 = [max(nums1[i], nums2[i]) for i in range(n)]\n        longest_length = 1\n        current_length = 1\n        for i in range(1, n):\n            if nums3[i] >= nums3[i - 1]:\n                current_length += 1\n            else:\n                longest_length = max(longest_length, current_length)\n                current_length = 1\n        return max(longest_length, current_length)\n```", "extracted_code": "\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        nums3 = [max(nums1[i], nums2[i]) for i in range(n)]\n        longest_length = 1\n        current_length = 1\n        for i in range(1, n):\n            if nums3[i] >= nums3[i - 1]:\n                current_length += 1\n            else:\n                longest_length = max(longest_length, current_length)\n                current_length = 1\n        return max(longest_length, current_length)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2770", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        stack = []\n        for i in range(n):\n            while stack:\n                if nums[i] - nums[stack[-1]] <= target and nums[i] - nums[stack[-1]] >= -target:\n                    dp[i] = max(dp[i], dp[stack.pop()] + 1)\n                else:\n                    break\n            stack.append(i)\n        return dp[-1] if dp[-1] > 0 else -1\n```", "extracted_code": "\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        stack = []\n        for i in range(n):\n            while stack:\n                if nums[i] - nums[stack[-1]] <= target and nums[i] - nums[stack[-1]] >= -target:\n                    dp[i] = max(dp[i], dp[stack.pop()] + 1)\n                else:\n                    break\n            stack.append(i)\n        return dp[-1] if dp[-1] > 0 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2768", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        grid = [[0]*(n+1) for _ in range(m+1)]\n        for x, y in coordinates:\n            grid[x][y] = 1\n        res = [0]*5\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if grid[i+1][j] == 1 and grid[i][j+1] == 1 and grid[i+1][j+1] == 1:\n                        res[4] += 1\n                    elif grid[i+1][j] == 1 and grid[i][j+1] == 1:\n                        res[2] += 1\n                    elif grid[i+1][j] == 1:\n                        res[1] += 1\n                    elif grid[i][j+1] == 1:\n                        res[1] += 1\n                    else:\n                        res[0] += 1\n        return res\n```\n\nThis function first initializes a grid of size `m x n` with all cells as 0. Then it iterates through the coordinates and sets the corresponding cells to 1. After that, it iterates through the grid and checks the number of black cells in each block. It increments the corresponding count in the result array. Finally, it returns the result array.", "extracted_code": "\nclass Solution:\n    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:\n        grid = [[0]*(n+1) for _ in range(m+1)]\n        for x, y in coordinates:\n            grid[x][y] = 1\n        res = [0]*5\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if grid[i+1][j] == 1 and grid[i][j+1] == 1 and grid[i+1][j+1] == 1:\n                        res[4] += 1\n                    elif grid[i+1][j] == 1 and grid[i][j+1] == 1:\n                        res[2] += 1\n                    elif grid[i+1][j] == 1:\n                        res[1] += 1\n                    elif grid[i][j+1] == 1:\n                        res[1] += 1\n                    else:\n                        res[0] += 1\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2766", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        marbles = collections.defaultdict(int)\n        for pos in nums:\n            marbles[pos] += 1\n        for i in range(len(moveFrom)):\n            marbles[moveTo[i]] += marbles[moveFrom[i]]\n            marbles[moveFrom[i]] = 0\n        return sorted(pos for pos, count in marbles.items() if count > 0)\n```", "extracted_code": "\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        marbles = collections.defaultdict(int)\n        for pos in nums:\n            marbles[pos] += 1\n        for i in range(len(moveFrom)):\n            marbles[moveTo[i]] += marbles[moveFrom[i]]\n            marbles[moveFrom[i]] = 0\n        return sorted(pos for pos, count in marbles.items() if count > 0)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2763", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        sorted_nums = sorted(nums)\n        imbalance_sum = 0\n        for i in range(n - 1):\n            if sorted_nums[i + 1] - sorted_nums[i] > 1:\n                imbalance_sum += 1\n        return imbalance_sum\n```", "extracted_code": "\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        sorted_nums = sorted(nums)\n        imbalance_sum = 0\n        for i in range(n - 1):\n            if sorted_nums[i + 1] - sorted_nums[i] > 1:\n                imbalance_sum += 1\n        return imbalance_sum\n", "difficulty": 3.0}
{"task_id": "LeetCode/2762", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = 0\n        for i in range(n):\n            for j in range(i, n):\n                if max(nums[i:j+1]) - min(nums[i:j+1]) <= 2:\n                    total += 1\n        return total\n```\n\nThis function works by iterating over all possible subarrays of `nums` and checking if the difference between the maximum and minimum values in the subarray is less than or equal to 2. If it is, the subarray is continuous and we increment `total`. The function finally returns `total`, which represents the total number of continuous subarrays.", "extracted_code": "\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = 0\n        for i in range(n):\n            for j in range(i, n):\n                if max(nums[i:j+1]) - min(nums[i:j+1]) <= 2:\n                    total += 1\n        return total\n", "difficulty": 2.0}
{"task_id": "LeetCode/2751", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        n = len(positions)\n        robots = list(zip(positions, healths, directions))\n        robots.sort()\n        stack = []\n        for pos, health, direction in robots:\n            while stack:\n                if direction == 'R' and stack[-1][0] < pos:\n                    break\n                if direction == 'L' and stack[-1][0] > pos:\n                    break\n                if stack[-1][1] < health:\n                    health -= 1\n                else:\n                    stack.pop()\n                if health <= 0:\n                    break\n            else:\n                stack.append((pos, health))\n        return [health for pos, health in stack]\n```", "extracted_code": "\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        n = len(positions)\n        robots = list(zip(positions, healths, directions))\n        robots.sort()\n        stack = []\n        for pos, health, direction in robots:\n            while stack:\n                if direction == 'R' and stack[-1][0] < pos:\n                    break\n                if direction == 'L' and stack[-1][0] > pos:\n                    break\n                if stack[-1][1] < health:\n                    health -= 1\n                else:\n                    stack.pop()\n                if health <= 0:\n                    break\n            else:\n                stack.append((pos, health))\n        return [health for pos, health in stack]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2750", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        suffix_sum = [0] * (n + 1)\n        good_subarrays = 0\n\n        for i in range(1, n + 1):\n            if nums[i - 1] == 1:\n                prefix_sum[i] = prefix_sum[i - 1] + 1\n                good_subarrays += prefix_sum[i]\n                good_subarrays %= MOD\n            else:\n                prefix_sum[i] = prefix_sum[i - 1]\n\n        for i in range(n - 1, -1, -1):\n            if nums[i] == 1:\n                suffix_sum[i] = suffix_sum[i + 1] + 1\n                good_subarrays += suffix_sum[i]\n                good_subarrays %= MOD\n            else:\n                suffix_sum[i] = suffix_sum[i + 1]\n\n        return good_subarrays\n```", "extracted_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        suffix_sum = [0] * (n + 1)\n        good_subarrays = 0\n\n        for i in range(1, n + 1):\n            if nums[i - 1] == 1:\n                prefix_sum[i] = prefix_sum[i - 1] + 1\n                good_subarrays += prefix_sum[i]\n                good_subarrays %= MOD\n            else:\n                prefix_sum[i] = prefix_sum[i - 1]\n\n        for i in range(n - 1, -1, -1):\n            if nums[i] == 1:\n                suffix_sum[i] = suffix_sum[i + 1] + 1\n                good_subarrays += suffix_sum[i]\n                good_subarrays %= MOD\n            else:\n                suffix_sum[i] = suffix_sum[i + 1]\n\n        return good_subarrays\n", "difficulty": 2.0}
{"task_id": "LeetCode/2749", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        if num1 == 0:\n            return 0\n        if num1 < 0:\n            return -1\n        res = 0\n        for i in range(60, -1, -1):\n            if num1 >= 2**i + num2:\n                num1 -= 2**i + num2\n                res += 1\n            else:\n                break\n        if num1 == 0:\n            return res\n        else:\n            return -1\n```", "extracted_code": "\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        if num1 == 0:\n            return 0\n        if num1 < 0:\n            return -1\n        res = 0\n        for i in range(60, -1, -1):\n            if num1 >= 2**i + num2:\n                num1 -= 2**i + num2\n                res += 1\n            else:\n                break\n        if num1 == 0:\n            return res\n        else:\n            return -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2747", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        server_logs = [[] for _ in range(n+1)]\n        for log in logs:\n            server_logs[log[0]].append(log[1])\n        res = []\n        for q in queries:\n            count = n\n            for log in server_logs:\n                if not log or max(log) < q-x or min(log) > q:\n                    count -= 1\n            res.append(count)\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        server_logs = [[] for _ in range(n+1)]\n        for log in logs:\n            server_logs[log[0]].append(log[1])\n        res = []\n        for q in queries:\n            count = n\n            for log in server_logs:\n                if not log or max(log) < q-x or min(log) > q:\n                    count -= 1\n            res.append(count)\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2744", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        word_set = set(words)\n        return sum(word_set.count(word) // 2 for word in word_set)\n```", "extracted_code": "\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        word_set = set(words)\n        return sum(word_set.count(word) // 2 for word in word_set)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2742", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        min_cost = [0] * n\n        min_cost[0] = cost[0]\n        for i in range(1, n):\n            min_cost[i] = min(min_cost[i-1] + cost[i], cost[i] + min_cost[i-2] if i >= 2 else cost[i])\n        return min_cost[-1]\n```\n\nThis function uses a dynamic programming approach to find the minimum cost of painting the walls. It iterates through the cost and time arrays, calculating the minimum cost of painting the current wall either by the paid painter (adding the cost of the current wall to the minimum cost of painting the previous wall) or by the free painter (adding the cost of the current wall to the minimum cost of painting the second previous wall, if it exists). The minimum cost of painting the last wall is then returned.", "extracted_code": "\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        min_cost = [0] * n\n        min_cost[0] = cost[0]\n        for i in range(1, n):\n            min_cost[i] = min(min_cost[i-1] + cost[i], cost[i] + min_cost[i-2] if i >= 2 else cost[i])\n        return min_cost[-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2736", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        nums1.sort()\n        nums2.sort()\n        result = []\n        for x, y in queries:\n            i = j = 0\n            while i < n and nums1[i] >= x:\n                i += 1\n            while j < n and nums2[j] >= y:\n                j += 1\n            if i == 0 or j == 0:\n                result.append(-1)\n            else:\n                result.append(nums1[i-1] + nums2[j-1])\n        return result\n```", "extracted_code": "\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        nums1.sort()\n        nums2.sort()\n        result = []\n        for x, y in queries:\n            i = j = 0\n            while i < n and nums1[i] >= x:\n                i += 1\n            while j < n and nums2[j] >= y:\n                j += 1\n            if i == 0 or j == 0:\n                result.append(-1)\n            else:\n                result.append(nums1[i-1] + nums2[j-1])\n        return result\n", "difficulty": 3.0}
{"task_id": "LeetCode/2734", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        return ''.join(chr((ord(c) - ord('a') - 1) % 26 + ord('a')) for c in s)\n```\n\nThis function works by iterating over each character in the input string `s`. For each character, it calculates the ASCII value of the previous character in the alphabet by subtracting the ASCII value of 'a' from the ASCII value of the current character, then subtracting 1. The modulo operation with 26 ensures that 'a' wraps around to 'z'. The resulting ASCII value is converted back to a character using the `chr` function, and the characters are joined together into a string using the `join` method.", "extracted_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        return ''.join(chr((ord(c) - ord('a') - 1) % 26 + ord('a')) for c in s)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2732", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        row_sums = [sum(row) for row in grid]\n        good_rows = sorted([i for i in range(m) if row_sums[i] <= m // 2])\n        return good_rows\n```", "extracted_code": "\nclass Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        row_sums = [sum(row) for row in grid]\n        good_rows = sorted([i for i in range(m) if row_sums[i] <= m // 2])\n        return good_rows\n", "difficulty": 3.0}
{"task_id": "LeetCode/2730", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        max_len = 0\n        for i in range(n):\n            for j in range(i+2, n):\n                if s[i:j] == s[j:j+j-i] and len(s[i:j]) % 2 == 0:\n                    max_len = max(max_len, len(s[i:j]))\n        return max_len\n```\n\nThis function works by iterating over the string `s` and checking every possible substring of length greater than 2. If a substring is semi-repetitive (i.e., it has at most one consecutive pair of the same digits and its length is even), the function updates `max_len` to the length of the current substring if it is greater than the current `max_len`. The function returns `max_len` at the end, which represents the length of the longest semi-repetitive substring in `s`.", "extracted_code": "\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        max_len = 0\n        for i in range(n):\n            for j in range(i+2, n):\n                if s[i:j] == s[j:j+j-i] and len(s[i:j]) % 2 == 0:\n                    max_len = max(max_len, len(s[i:j]))\n        return max_len\n", "difficulty": 2.0}
{"task_id": "LeetCode/2729", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Concatenate n, 2 * n, and 3 * n\n        result = str(n) + str(2 * n) + str(3 * n)\n        \n        # Check if result contains all digits from 1 to 9 exactly once and does not contain any 0's\n        return set(result) == set(map(str, range(1, 10)))\n```", "extracted_code": "\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Concatenate n, 2 * n, and 3 * n\n        result = str(n) + str(2 * n) + str(3 * n)\n        \n        # Check if result contains all digits from 1 to 9 exactly once and does not contain any 0's\n        return set(result) == set(map(str, range(1, 10)))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2719", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        num1, num2 = int(num1), int(num2)\n        min_sum, max_sum = max(min_sum, num1), min(max_sum, num2)\n        return sum(max(0, min(max_sum, num2) - max(min_sum, num1) + 1)) % MOD\n```", "extracted_code": "\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        num1, num2 = int(num1), int(num2)\n        min_sum, max_sum = max(min_sum, num1), min(max_sum, num2)\n        return sum(max(0, min(max_sum, num2) - max(min_sum, num1) + 1)) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2716", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if stack and stack[-1] == c:\n                stack.append(c)\n            else:\n                stack.append([c])\n        res = []\n        for c in stack:\n            if isinstance(c, list):\n                res.extend(c)\n            else:\n                res.append(c)\n        return len(res)\n```\n\nThis function works by iterating over the string and maintaining a stack of characters. If the current character is the same as the top of the stack, it's pushed again to the stack. Otherwise, a new list is created for the different character. After iterating over the string, the stack is flattened into a list, which is then returned. The length of this list is the minimized length of the string.", "extracted_code": "\nclass Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if stack and stack[-1] == c:\n                stack.append(c)\n            else:\n                stack.append([c])\n        res = []\n        for c in stack:\n            if isinstance(c, list):\n                res.extend(c)\n            else:\n                res.append(c)\n        return len(res)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2713", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        directions = [(0, 1), (1, 0)]\n        res = 0\n\n        for i in range(m):\n            for j in range(n):\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < m and 0 <= y < n and mat[i][j] < mat[x][y]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[x][y])\n                res = max(res, dp[i][j])\n\n        return res\n```\n\nThis function uses dynamic programming to solve the problem. It iterates over each cell in the matrix, and for each cell, it checks if it can move to any other cell in the same row or column with a value strictly greater than the current cell. If it can, it updates the dynamic programming table with the maximum number of cells that can be visited. The maximum value in the dynamic programming table is the maximum number of cells that can be visited in the matrix.", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        directions = [(0, 1), (1, 0)]\n        res = 0\n\n        for i in range(m):\n            for j in range(n):\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < m and 0 <= y < n and mat[i][j] < mat[x][y]:\n                        dp[i][j] = max(dp[i][j], 1 + dp[x][y])\n                res = max(res, dp[i][j])\n\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2712", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        ones = 0\n        for i in range(n):\n            if s[i] == '1':\n                ones += 1\n        zeros = n - ones\n        for i in range(n):\n            if s[i] == '1':\n                cost += min(ones, zeros)\n                ones -= 1\n            else:\n                cost += min(ones, zeros)\n                zeros -= 1\n        return cost\n```", "extracted_code": "\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        ones = 0\n        for i in range(n):\n            if s[i] == '1':\n                ones += 1\n        zeros = n - ones\n        for i in range(n):\n            if s[i] == '1':\n                cost += min(ones, zeros)\n                ones -= 1\n            else:\n                cost += min(ones, zeros)\n                zeros -= 1\n        return cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2709", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        n = len(nums)\n        gcd_matrix = np.zeros((n, n), dtype=int)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                gcd_matrix[i, j] = np.gcd(nums[i], nums[j])\n                gcd_matrix[j, i] = gcd_matrix[i, j]\n        \n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if gcd_matrix[i, k] > 1 and gcd_matrix[k, j] > 1:\n                        gcd_matrix[i, j] = max(gcd_matrix[i, j], gcd_matrix[i, k] * gcd_matrix[k, j])\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                if gcd_matrix[i, j] <= 1:\n                    return False\n        \n        return True\n```\n\nThis solution uses a dynamic programming approach to build a matrix `gcd_matrix` where `gcd_matrix[i][j]` is the greatest common divisor of `nums[i]` and `nums[j]`. Then, it iteratively updates the matrix by considering all possible intermediate nodes `k` to check if there exists a sequence of traversals from `i` to `j`. Finally, it checks", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        n = len(nums)\n        gcd_matrix = np.zeros((n, n), dtype=int)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                gcd_matrix[i, j] = np.gcd(nums[i], nums[j])\n                gcd_matrix[j, i] = gcd_matrix[i, j]\n        \n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if gcd_matrix[i, k] > 1 and gcd_matrix[k, j] > 1:\n                        gcd_matrix[i, j] = max(gcd_matrix[i, j], gcd_matrix[i, k] * gcd_matrix[k, j])\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                if gcd_matrix[i, j] <= 1:\n                    return False\n        \n        return True\n", "difficulty": 3.0}
{"task_id": "LeetCode/2708", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        nums.sort()\n        return max(nums[i] * nums[i+1] * nums[-1] for i in range(len(nums)-2))\n```", "extracted_code": "\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        nums.sort()\n        return max(nums[i] * nums[i+1] * nums[-1] for i in range(len(nums)-2))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2707", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        # Sort the dictionary in descending order of length\n        dictionary.sort(key=len, reverse=True)\n        \n        # Initialize the result\n        extra_char = 0\n        \n        # Iterate over the sorted dictionary\n        for word in dictionary:\n            # Find the index of the word in the string\n            index = s.find(word)\n            \n            # If the word is not found in the string\n            if index == -1:\n                # Increment the extra characters count\n                extra_char += len(word)\n            else:\n                # Remove the found word from the string\n                s = s[:index] + s[index+len(word):]\n        \n        # Return the extra characters count\n        return extra_char + len(s)\n```", "extracted_code": "\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        # Sort the dictionary in descending order of length\n        dictionary.sort(key=len, reverse=True)\n        \n        # Initialize the result\n        extra_char = 0\n        \n        # Iterate over the sorted dictionary\n        for word in dictionary:\n            # Find the index of the word in the string\n            index = s.find(word)\n            \n            # If the word is not found in the string\n            if index == -1:\n                # Increment the extra characters count\n                extra_char += len(word)\n            else:\n                # Remove the found word from the string\n                s = s[:index] + s[index+len(word):]\n        \n        # Return the extra characters count\n        return extra_char + len(s)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2699", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\n\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        dist = [float('inf')] * n\n        dist[source] = 0\n        heap = [(0, source)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if d != dist[node]:\n                continue\n            for neighbor, weight in graph[node]:\n                if weight < 0:\n                    new_weight = target - dist[node]\n                    if new_weight < 1 or new_weight > 2 * 10**9:\n                        return []\n                    weight = new_weight\n                if dist[node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[node] + weight\n                    heapq.heappush(heap, (dist[neighbor], neighbor))\n        if dist[destination] != target:\n            return []\n        for i, (u, v, w) in enumerate(edges):\n            if w < 0:\n                edges[i][2] = target - dist[u]\n        return edges\n```\n\nThis function first builds an adjacency list representation of the graph. Then it uses Dijkstra's algorithm to find the shortest distance from the source to all", "extracted_code": "\nimport heapq\n\nclass Solution:\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        dist = [float('inf')] * n\n        dist[source] = 0\n        heap = [(0, source)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if d != dist[node]:\n                continue\n            for neighbor, weight in graph[node]:\n                if weight < 0:\n                    new_weight = target - dist[node]\n                    if new_weight < 1 or new_weight > 2 * 10**9:\n                        return []\n                    weight = new_weight\n                if dist[node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[node] + weight\n                    heapq.heappush(heap, (dist[neighbor], neighbor))\n        if dist[destination] != target:\n            return []\n        for i, (u, v, w) in enumerate(edges):\n            if w < 0:\n                edges[i][2] = target - dist[u]\n        return edges\n", "difficulty": 3.0}
{"task_id": "LeetCode/2698", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        punishment_sum = 0\n        for i in range(1, n+1):\n            square = i * i\n            square_str = str(square)\n            substrings = [square_str[j:k] for j in range(len(square_str)) for k in range(j + 1, len(square_str) + 1)]\n            if any(int(substring) == i for substring in substrings):\n                punishment_sum += square\n        return punishment_sum\n```", "extracted_code": "\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        punishment_sum = 0\n        for i in range(1, n+1):\n            square = i * i\n            square_str = str(square)\n            substrings = [square_str[j:k] for j in range(len(square_str)) for k in range(j + 1, len(square_str) + 1)]\n            if any(int(substring) == i for substring in substrings):\n                punishment_sum += square\n        return punishment_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2697", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        for i in range(n//2):\n            if s[i] != s[n-i-1]:\n                if ord(s[i]) > ord(s[n-i-1]):\n                    s = s[:i] + s[n-i-1] + s[i+1:]\n                else:\n                    s = s[:i] + s[i] + s[i+1:n-i-1] + s[i] + s[n-i:]\n                break\n        return s\n```\n\nThis function works by iterating over the first half of the string and comparing each character with its corresponding character from the end of the string. If the characters are not equal, it replaces the character in the first half with the smaller of the two characters, and then appends the larger character to the end of the first half. This ensures that the resulting string is a palindrome and is lexicographically smallest.", "extracted_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        for i in range(n//2):\n            if s[i] != s[n-i-1]:\n                if ord(s[i]) > ord(s[n-i-1]):\n                    s = s[:i] + s[n-i-1] + s[i+1:]\n                else:\n                    s = s[:i] + s[i] + s[i+1:n-i-1] + s[i] + s[n-i:]\n                break\n        return s\n", "difficulty": 1.0}
{"task_id": "LeetCode/2681", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i-1]**2)\n        return (dp[-1] - nums[-1]**2 + MOD) % MOD\n```", "extracted_code": "\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        dp = [0]*(n+1)\n        for i in range(1, n+1):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i-1]**2)\n        return (dp[-1] - nums[-1]**2 + MOD) % MOD\n", "difficulty": 3.0}
{"task_id": "LeetCode/2680", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            if k >= i:\n                nums[i] *= 2\n                k -= i\n            else:\n                break\n        return sum(nums)\n```", "extracted_code": "\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        nums.sort()\n        for i in range(n):\n            if k >= i:\n                nums[i] *= 2\n                k -= i\n            else:\n                break\n        return sum(nums)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2670", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_counts = [0] * (n + 1)\n        suffix_counts = [0] * (n + 1)\n        for i in range(n):\n            prefix_counts[i + 1] = prefix_counts[i] + (nums[i] not in nums[:i])\n            suffix_counts[n - i - 1] = suffix_counts[n - i] + (nums[n - i - 1] not in nums[i + 1:])\n        return [prefix_counts[i] - suffix_counts[i] for i in range(n)]\n```", "extracted_code": "\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_counts = [0] * (n + 1)\n        suffix_counts = [0] * (n + 1)\n        for i in range(n):\n            prefix_counts[i + 1] = prefix_counts[i] + (nums[i] not in nums[:i])\n            suffix_counts[n - i - 1] = suffix_counts[n - i] + (nums[n - i - 1] not in nums[i + 1:])\n        return [prefix_counts[i] - suffix_counts[i] for i in range(n)]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2663", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        n = len(s)\n        if n == k:\n            for c in alphabet:\n                if c > s[-1]:\n                    return s[:-1] + c\n            return ''\n        else:\n            for c in alphabet:\n                if c > s[-1]:\n                    return s + c\n            return ''\n```\n\nThis function works by first checking if the length of the input string `s` is equal to `k`. If it is, we iterate through the alphabet and find the first character that is larger than the last character of `s`. We then return `s` with the last character replaced by this larger character. If no such character is found, we return an empty string.\n\nIf the length of `s` is not equal to `k`, we iterate through the alphabet and find the first character that is larger than the last character of `s`. We then return `s` with this larger character appended to the end. If no such character is found, we return an empty string.\n\nThis function assumes that the input string `s` is a beautiful string and that `k` is a positive integer. It does not check these assumptions.", "extracted_code": "\nclass Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        n = len(s)\n        if n == k:\n            for c in alphabet:\n                if c > s[-1]:\n                    return s[:-1] + c\n            return ''\n        else:\n            for c in alphabet:\n                if c > s[-1]:\n                    return s + c\n            return ''\n", "difficulty": 3.0}
{"task_id": "LeetCode/2659", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        operations = 0\n        while nums:\n            if nums[0] == min(nums):\n                nums.pop(0)\n            else:\n                nums.append(nums.pop(0))\n            operations += 1\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        operations = 0\n        while nums:\n            if nums[0] == min(nums):\n                nums.pop(0)\n            else:\n                nums.append(nums.pop(0))\n            operations += 1\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2658", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_fish = 0\n        visited = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def dfs(r, c):\n            nonlocal max_fish\n            max_fish = max(max_fish, grid[r][c])\n            visited[r][c] = 1\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] > 0:\n                    dfs(nr, nc)\n\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] > 0 and not visited[r][c]:\n                    dfs(r, c)\n\n        return max_fish\n```", "extracted_code": "\nclass Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_fish = 0\n        visited = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def dfs(r, c):\n            nonlocal max_fish\n            max_fish = max(max_fish, grid[r][c])\n            visited[r][c] = 1\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] > 0:\n                    dfs(nr, nc)\n\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] > 0 and not visited[r][c]:\n                    dfs(r, c)\n\n        return max_fish\n", "difficulty": 2.0}
{"task_id": "LeetCode/2657", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        n = len(A)\n        C = [0] * n\n        common = set(A) & set(B)\n        for i in range(n):\n            C[i] = len(common & set(range(1, i+2)))\n        return C\n```", "extracted_code": "\nclass Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        n = len(A)\n        C = [0] * n\n        common = set(A) & set(B)\n        for i in range(n):\n            C[i] = len(common & set(range(1, i+2)))\n        return C\n", "difficulty": 2.0}
{"task_id": "LeetCode/2653", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        n = len(nums)\n        result = []\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            negatives = sorted([num for num in subarray if num < 0])\n            if len(negatives) < x:\n                result.append(0)\n            else:\n                result.append(negatives[x - 1])\n        return result\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        n = len(nums)\n        result = []\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            negatives = sorted([num for num in subarray if num < 0])\n            if len(negatives) < x:\n                result.append(0)\n            else:\n                result.append(negatives[x - 1])\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2652", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n```", "extracted_code": "\nclass Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2651", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24 or 24\n```", "extracted_code": "\nclass Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24 or 24\n", "difficulty": 1.0}
{"task_id": "LeetCode/2646", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal min_price\n            min_price[node] = price[node]\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    min_price[node] = min(min_price[node], min_price[child] + price[node])\n        \n        min_price = [0] * n\n        dfs(0, -1)\n        \n        total_price = 0\n        for start, end in trips:\n            total_price += min_price[start] + price[end] - price[start]\n        \n        return total_price\n```", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal min_price\n            min_price[node] = price[node]\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    min_price[node] = min(min_price[node], min_price[child] + price[node])\n        \n        min_price = [0] * n\n        dfs(0, -1)\n        \n        total_price = 0\n        for start, end in trips:\n            total_price += min_price[start] + price[end] - price[start]\n        \n        return total_price\n", "difficulty": 3.0}
{"task_id": "LeetCode/2645", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count = [0, 0, 0]\n        for c in word:\n            count[ord(c) - ord('a')] += 1\n        a, b, c = count\n        return min(a, b, c) if a == b == c else min(a, b) + min(b, c) + min(c, a)\n```", "extracted_code": "\nclass Solution:\n    def addMinimum(self, word: str) -> int:\n        count = [0, 0, 0]\n        for c in word:\n            count[ord(c) - ord('a')] += 1\n        a, b, c = count\n        return min(a, b, c) if a == b == c else min(a, b) + min(b, c) + min(c, a)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2642", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nimport heapq\nfrom collections import defaultdict\n\nclass Graph:\n\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.n = n\n        self.edges = defaultdict(list)\n        self.weights = defaultdict(list)\n        for u, v, w in edges:\n            self.edges[u].append(v)\n            self.weights[(u, v)] = w\n\n    def addEdge(self, edge: List[int]) -> None:\n        u, v, w = edge\n        self.edges[u].append(v)\n        self.weights[(u, v)] = w\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        queue = [(0, node1, [])]\n        visited = set()\n        while queue:\n            d, node, path = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                path = path + [node]\n                if node == node2:\n                    return d\n                for nei in self.edges[node]:\n                    if nei not in visited:\n                        heapq.heappush(queue, (d + self.weights[(node, nei)], nei, path))\n        return -1\n```", "extracted_code": "\nimport heapq\nfrom collections import defaultdict\n\nclass Graph:\n\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.n = n\n        self.edges = defaultdict(list)\n        self.weights = defaultdict(list)\n        for u, v, w in edges:\n            self.edges[u].append(v)\n            self.weights[(u, v)] = w\n\n    def addEdge(self, edge: List[int]) -> None:\n        u, v, w = edge\n        self.edges[u].append(v)\n        self.weights[(u, v)] = w\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        queue = [(0, node1, [])]\n        visited = set()\n        while queue:\n            d, node, path = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                path = path + [node]\n                if node == node2:\n                    return d\n                for nei in self.edges[node]:\n                    if nei not in visited:\n                        heapq.heappush(queue, (d + self.weights[(node, nei)], nei, path))\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2640", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, nums[i])\n            ans[i] = max_val * (i + 1)\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, nums[i])\n            ans[i] = max_val * (i + 1)\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2617", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        res = 0\n        \n        while heap:\n            cells, i, j = heapq.heappop(heap)\n            res += 1\n            for k in range(j+1, min(n, j+grid[i][j]+2)):\n                if not visited[i][k]:\n                    visited[i][k] = 1\n                    heapq.heappush(heap, (cells-k+grid[i][k], i, k))\n            for k in range(i+1, min(m, i+grid[i][j]+2)):\n                if not visited[k][j]:\n                    visited[k][j] = 1\n                    heapq.heappush(heap, (cells-i+grid[k][j], k, j))\n        \n        return res if visited[m-1][n-1] else -1\n```\n\nThis solution uses a priority queue to store the cells to visit next, ordered by the number of cells visited so far (cells) and the current position (i, j). It starts at the top-left cell (0, 0) and explores the grid in a breadth-first manner, visiting the cells that can be reached in one step from", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        res = 0\n        \n        while heap:\n            cells, i, j = heapq.heappop(heap)\n            res += 1\n            for k in range(j+1, min(n, j+grid[i][j]+2)):\n                if not visited[i][k]:\n                    visited[i][k] = 1\n                    heapq.heappush(heap, (cells-k+grid[i][k], i, k))\n            for k in range(i+1, min(m, i+grid[i][j]+2)):\n                if not visited[k][j]:\n                    visited[k][j] = 1\n                    heapq.heappush(heap, (cells-i+grid[k][j], k, j))\n        \n        return res if visited[m-1][n-1] else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2616", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        pairs = []\n        for i in range(p):\n            pairs.append((nums[i], nums[n-i-1]))\n        return min(max(abs(x-y) for x, y in pairs) for pairs in itertools.permutations(pairs, p))\n```\n\nThis function first sorts the input array in ascending order. Then it creates pairs of elements, one from the beginning and one from the end. The pairs are created in such a way that the sum of the elements in each pair is as small as possible. Finally, it calculates the maximum difference for each possible combination of pairs and returns the minimum of these values. This ensures that the maximum difference is minimized across all possible pairs.", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        pairs = []\n        for i in range(p):\n            pairs.append((nums[i], nums[n-i-1]))\n        return min(max(abs(x-y) for x, y in pairs) for pairs in itertools.permutations(pairs, p))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2615", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [0] * n\n        pos = {}\n        for i in range(n):\n            if nums[i] not in pos:\n                pos[nums[i]] = []\n            pos[nums[i]].append(i)\n        for k in pos:\n            indices = pos[k]\n            for i in range(len(indices)):\n                for j in range(i+1, len(indices)):\n                    arr[indices[i]] += abs(indices[i] - indices[j])\n                    arr[indices[j]] += abs(indices[i] - indices[j])\n        return arr\n```", "extracted_code": "\nclass Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [0] * n\n        pos = {}\n        for i in range(n):\n            if nums[i] not in pos:\n                pos[nums[i]] = []\n            pos[nums[i]].append(i)\n        for k in pos:\n            indices = pos[k]\n            for i in range(len(indices)):\n                for j in range(i+1, len(indices)):\n                    arr[indices[i]] += abs(indices[i] - indices[j])\n                    arr[indices[j]] += abs(indices[i] - indices[j])\n        return arr\n", "difficulty": 2.0}
{"task_id": "LeetCode/2612", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        ans = [0] * n\n        banned = set(banned)\n        left, right = p, p\n        for i in range(1, k):\n            if left - i >= 0 and left - i not in banned:\n                left -= 1\n            if right + i < n and right + i not in banned:\n                right += 1\n        for i in range(n):\n            if i in banned:\n                ans[i] = -1\n            elif i <= right and i >= left:\n                ans[i] = min(i - left, right - i)\n            elif i < left:\n                ans[i] = left - i\n            else:\n                ans[i] = i - right\n        return ans\n```\n\nThis function works by first initializing an answer array `ans` of size `n` with all elements as `0`. Then, it converts the `banned` list into a set for faster lookup.\n\nNext, it uses a sliding window approach to find the minimum number of reverse operations needed to bring the `1` to each position. The window size is `k`, and it starts from the initial position `p`. The window is moved to the left and right by one position at a time, and the window boundaries are updated accordingly.\n\nFinally, for each position `i` in the answer array, if it is in the `banned` set, the answer is set to `-1`. Otherwise, if the position is within the window, the answer is set to the", "extracted_code": "\nclass Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        ans = [0] * n\n        banned = set(banned)\n        left, right = p, p\n        for i in range(1, k):\n            if left - i >= 0 and left - i not in banned:\n                left -= 1\n            if right + i < n and right + i not in banned:\n                right += 1\n        for i in range(n):\n            if i in banned:\n                ans[i] = -1\n            elif i <= right and i >= left:\n                ans[i] = min(i - left, right - i)\n            elif i < left:\n                ans[i] = left - i\n            else:\n                ans[i] = i - right\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2608", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = [0] * n\n        min_cycle_len = float('inf')\n        \n        def dfs(node, parent, length):\n            nonlocal min_cycle_len\n            visited[node] = 1\n            for child in graph[node]:\n                if child == parent:\n                    min_cycle_len = min(min_cycle_len, length + 1)\n                elif visited[child] == 0:\n                    dfs(child, node, length + 1)\n        \n        for node in range(n):\n            if visited[node] == 0:\n                dfs(node, -1, 0)\n        \n        return -1 if min_cycle_len == float('inf') else min_cycle_len\n```\n\nThis function uses a depth-first search (DFS) algorithm to find the shortest cycle in the graph. It first builds a graph from the given edges, then it iterates through each unvisited node and performs a DFS from that node. During the DFS, it keeps track of the current path length and updates the minimum cycle length whenever it finds a cycle. If no cycle is found after visiting all nodes, it returns -1. Otherwise, it returns the length of the shortest cycle.", "extracted_code": "\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = [0] * n\n        min_cycle_len = float('inf')\n        \n        def dfs(node, parent, length):\n            nonlocal min_cycle_len\n            visited[node] = 1\n            for child in graph[node]:\n                if child == parent:\n                    min_cycle_len = min(min_cycle_len, length + 1)\n                elif visited[child] == 0:\n                    dfs(child, node, length + 1)\n        \n        for node in range(n):\n            if visited[node] == 0:\n                dfs(node, -1, 0)\n        \n        return -1 if min_cycle_len == float('inf') else min_cycle_len\n", "difficulty": 3.0}
{"task_id": "LeetCode/2603", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal steps\n            coin_steps = coins[node]\n            for child in graph[node]:\n                if child != parent:\n                    dfs_steps = dfs(child, node)\n                    steps += min(coin_steps, dfs_steps)\n                    coin_steps -= dfs_steps\n            return coin_steps\n        \n        steps = 0\n        dfs(0, -1)\n        return steps\n```\n\nThis solution uses depth-first search (DFS) to traverse the tree. The `dfs` function is called recursively for each node, and it collects the coins at the node and its children. The minimum number of steps to collect the coins is calculated by taking the minimum of the number of coins at the current node and the number of steps required to collect the coins in the subtree rooted at the current node. The `steps` variable keeps track of the total number of steps required to collect all the coins and return to the initial vertex.", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            nonlocal steps\n            coin_steps = coins[node]\n            for child in graph[node]:\n                if child != parent:\n                    dfs_steps = dfs(child, node)\n                    steps += min(coin_steps, dfs_steps)\n                    coin_steps -= dfs_steps\n            return coin_steps\n        \n        steps = 0\n        dfs(0, -1)\n        return steps\n", "difficulty": 3.0}
{"task_id": "LeetCode/2601", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        for i in range(len(nums)):\n            if i > 0 and nums[i] <= nums[i - 1]:\n                for j in range(i - 1, -1, -1):\n                    if nums[j] < nums[i] and is_prime(nums[i] - nums[j]):\n                        nums[i] -= nums[j]\n                        break\n                else:\n                    return False\n        return True\n```\n\nThis function works by iterating over the array and checking if each element is less than or equal to the previous one. If it is, we need to find a prime number that can be subtracted from the current element to make it greater than the previous one. We do this by iterating over the previous elements in reverse order and checking if the current element minus the previous element is a prime number. If we find such a prime number, we subtract it from the current element and continue with the next element. If we can't find such a prime number, we return False. If we finish iterating over the array without returning False, it means we've successfully made the array strictly increasing and we return True.", "extracted_code": "\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        for i in range(len(nums)):\n            if i > 0 and nums[i] <= nums[i - 1]:\n                for j in range(i - 1, -1, -1):\n                    if nums[j] < nums[i] and is_prime(nums[i] - nums[j]):\n                        nums[i] -= nums[j]\n                        break\n                else:\n                    return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2592", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort(reverse=True)\n        perm = [0] * n\n        perm[0] = nums[0]\n        for i in range(1, n):\n            perm[i] = nums[i] if nums[i] > perm[i-1] else perm[i-1]\n        return perm.count(perm[0])\n```\n\nThis function works by first sorting the input array in descending order. Then, it iterates through the sorted array and assigns each element to the corresponding position in the permuted array, ensuring that each element is greater than or equal to the previous one. Finally, it counts the number of times the maximum value appears in the permuted array, which gives the maximum possible greatness.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort(reverse=True)\n        perm = [0] * n\n        perm[0] = nums[0]\n        for i in range(1, n):\n            perm[i] = nums[i] if nums[i] > perm[i-1] else perm[i-1]\n        return perm.count(perm[0])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2591", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children:\n            return -1\n        if money == children:\n            return children\n        if money == children * 8:\n            return children\n        if money == children * 9:\n            return 0\n        if money == children * 10 - 2:\n            return 1\n        if money == children * 10 - 6:\n            return 2\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children:\n            return -1\n        if money == children:\n            return children\n        if money == children * 8:\n            return children\n        if money == children * 9:\n            return 0\n        if money == children * 10 - 2:\n            return 1\n        if money == children * 10 - 6:\n            return 2\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2589", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x: x[1])\n        on_time = end_time = 0\n        for start, end, duration in tasks:\n            if start >= end_time:\n                on_time += duration\n            else:\n                on_time += max(0, duration - (end_time - start))\n            end_time = max(end_time, end)\n        return on_time\n```\n\nThis function sorts the tasks by their end times. Then, it iterates over the sorted tasks and calculates the minimum time the computer should be turned on. It checks if the current task can be completed within the idle time of the computer or not. If it can, then the task duration is added to the `on_time`, otherwise, the remaining duration of the task is added to the `on_time`. Finally, it updates the `end_time` to the maximum of the current `end_time` and the end time of the current task. The `on_time` returned at the end is the minimum time the computer should be turned on to complete all tasks.", "extracted_code": "\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x: x[1])\n        on_time = end_time = 0\n        for start, end, duration in tasks:\n            if start >= end_time:\n                on_time += duration\n            else:\n                on_time += max(0, duration - (end_time - start))\n            end_time = max(end_time, end)\n        return on_time\n", "difficulty": 3.0}
{"task_id": "LeetCode/2587", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort()\n        prefix = [nums[0]]\n        for i in range(1, len(nums)):\n            prefix.append(prefix[i-1] + nums[i])\n        return len([x for x in prefix if x > 0])\n```\n\nThis function first sorts the input array `nums`. Then it calculates the prefix sum array `prefix` and counts the number of positive numbers in it. The score is the count of positive numbers in the prefix sum array. The function returns the maximum score that can be achieved.\n\nThe time complexity of this function is O(n log n) due to the sorting operation, where n is the length of the input array. The space complexity is O(n) for storing the prefix sum array.", "extracted_code": "\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort()\n        prefix = [nums[0]]\n        for i in range(1, len(nums)):\n            prefix.append(prefix[i-1] + nums[i])\n        return len([x for x in prefix if x > 0])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2585", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for count, marks in types:\n            for t in range(target, marks - 1, -1):\n                dp[t] = (dp[t] + dp[t - marks]) % MOD\n        return dp[target]\n```", "extracted_code": "\nclass Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for count, marks in types:\n            for t in range(target, marks - 1, -1):\n                dp[t] = (dp[t] + dp[t - marks]) % MOD\n        return dp[target]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2584", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        n = len(nums)\n        gcd_product = [0] * n\n        gcd_product[0] = nums[0]\n        for i in range(1, n):\n            gcd_product[i] = math.gcd(gcd_product[i - 1], nums[i])\n        for i in range(n - 1, 0, -1):\n            if math.gcd(gcd_product[i - 1], gcd_product[n - 1]) == 1:\n                return i\n        return -1\n```\n\nThis function works by first calculating the gcd of the product of the first i + 1 elements and the product of the remaining elements at each index i. Then, it iterates over the gcd_product array in reverse order, checking if the gcd of the product of the first i + 1 elements and the product of the remaining elements is 1. If it is, it returns the current index i. If no such index is found, it returns -1.", "extracted_code": "\nclass Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        n = len(nums)\n        gcd_product = [0] * n\n        gcd_product[0] = nums[0]\n        for i in range(1, n):\n            gcd_product[i] = math.gcd(gcd_product[i - 1], nums[i])\n        for i in range(n - 1, 0, -1):\n            if math.gcd(gcd_product[i - 1], gcd_product[n - 1]) == 1:\n                return i\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2581", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        parent_count = [0] * n\n        for u, v in guesses:\n            parent_count[v] += 1\n        queue = [i for i in range(n) if parent_count[i] == 0]\n        depth = [0] * n\n        while queue:\n            node = queue.pop(0)\n            for child in graph[node]:\n                if depth[child] == 0:\n                    depth[child] = depth[node] + 1\n                    if parent_count[child] == k - 1:\n                        queue.append(child)\n        return sum(depth[i] == 0 or depth[i] == k - 1 for i in range(n))\n```\n\nThis function works by first building an adjacency list representation of the tree. It then initializes an array `parent_count` to count the number of guesses for each node, and a queue to store nodes that have no parents. The function then performs a breadth-first search from the nodes in the queue, updating the `depth` array with the depth of each node in the tree. The function finally returns the number of nodes that are potential roots of the tree, which are either leaf nodes (depth of 0) or nodes that have exactly `k", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        parent_count = [0] * n\n        for u, v in guesses:\n            parent_count[v] += 1\n        queue = [i for i in range(n) if parent_count[i] == 0]\n        depth = [0] * n\n        while queue:\n            node = queue.pop(0)\n            for child in graph[node]:\n                if depth[child] == 0:\n                    depth[child] = depth[node] + 1\n                    if parent_count[child] == k - 1:\n                        queue.append(child)\n        return sum(depth[i] == 0 or depth[i] == k - 1 for i in range(n))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2579", "status": "Memory Limit Exceeded", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        rows, cols = 2*n, 2*n\n        grid = [[0]*cols for _ in range(rows)]\n        grid[n][n] = 1\n        colored = {(n, n)}\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for _ in range(n-1):\n            new_colored = set()\n            for r, c in colored:\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        new_colored.add((nr, nc))\n            colored = new_colored\n        \n        return sum(sum(row) for row in grid)\n```", "extracted_code": "\nclass Solution:\n    def coloredCells(self, n: int) -> int:\n        rows, cols = 2*n, 2*n\n        grid = [[0]*cols for _ in range(rows)]\n        grid[n][n] = 1\n        colored = {(n, n)}\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for _ in range(n-1):\n            new_colored = set()\n            for r, c in colored:\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:\n                        grid[nr][nc] = 1\n                        new_colored.add((nr, nc))\n            colored = new_colored\n        \n        return sum(sum(row) for row in grid)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2577", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        heap = [(grid[0][0], 0, 0)]\n        visited = [[False]*n for _ in range(m)]\n        visited[0][0] = True\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while heap:\n            time, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                return time\n            \n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and time + 1 >= grid[nx][ny]:\n                    visited[nx][ny] = True\n                    heapq.heappush(heap, (time + 1, nx, ny))\n        \n        return -1\n```\n\nThis solution uses a priority queue to store the cells to visit next, sorted by the time required to reach them. It starts at the top-left cell and explores its neighbors in all four directions. If a neighbor can be visited (i.e., its time requirement is met), it is added to the priority queue and marked as visited. The process continues until the bottom-right cell is reached or all possible cells have been visited. If the bottom-right cell is reached, the minimum time required to reach it is returned. If it is not reach", "extracted_code": "\nimport heapq\n\nclass Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        heap = [(grid[0][0], 0, 0)]\n        visited = [[False]*n for _ in range(m)]\n        visited[0][0] = True\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while heap:\n            time, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                return time\n            \n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and time + 1 >= grid[nx][ny]:\n                    visited[nx][ny] = True\n                    heapq.heappush(heap, (time + 1, nx, ny))\n        \n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2576", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        marked = [False] * len(nums)\n        count = 0\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i - 1, -1, -1):\n                if not marked[j] and 2 * nums[j] <= nums[i]:\n                    marked[j] = True\n                    count += 1\n        return count\n```\n\nThis function first sorts the input array in ascending order. Then, it initializes a boolean array `marked` to keep track of the marked indices and a counter `count` to store the number of marked indices.\n\nThe function then iterates over the sorted array in reverse order, for each element `nums[i]`, it iterates over the elements before `nums[i]` in the array, if an element `nums[j]` is not marked and `2 * nums[j] <= nums[i]`, it marks `nums[j]` and increments the counter `count`.\n\nFinally, the function returns the counter `count` which represents the maximum possible number of marked indices.", "extracted_code": "\nclass Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        marked = [False] * len(nums)\n        count = 0\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i - 1, -1, -1):\n                if not marked[j] and 2 * nums[j] <= nums[i]:\n                    marked[j] = True\n                    count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2573", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        word = \"\"\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] == n - 1:\n                    word = chr(ord('a') + i) * n\n                    break\n            if word:\n                break\n        return word\n```", "extracted_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        word = \"\"\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] == n - 1:\n                    word = chr(ord('a') + i) * n\n                    break\n            if word:\n                break\n        return word\n", "difficulty": 3.0}
{"task_id": "LeetCode/2570", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        nums1_dict = {id: val for id, val in nums1}\n        nums2_dict = {id: val for id, val in nums2}\n        all_ids = set(nums1_dict.keys()).union(nums2_dict.keys())\n        result = [[id, nums1_dict.get(id, 0) + nums2_dict.get(id, 0)] for id in sorted(all_ids)]\n        return result\n```", "extracted_code": "\nclass Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        nums1_dict = {id: val for id, val in nums1}\n        nums2_dict = {id: val for id, val in nums2}\n        all_ids = set(nums1_dict.keys()).union(nums2_dict.keys())\n        result = [[id, nums1_dict.get(id, 0) + nums2_dict.get(id, 0)] for id in sorted(all_ids)]\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/2569", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        res = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                nums1[l:r+1] = [1-i for i in nums1[l:r+1]]\n            elif query[0] == 2:\n                p = query[1]\n                nums2 = [i+i*p for i in nums1]\n            elif query[0] == 3:\n                res.append(sum(nums2))\n        return res\n```", "extracted_code": "\nclass Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        res = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                nums1[l:r+1] = [1-i for i in nums1[l:r+1]]\n            elif query[0] == 2:\n                p = query[1]\n                nums2 = [i+i*p for i in nums1]\n            elif query[0] == 3:\n                res.append(sum(nums2))\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2568", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        result = 1\n        for num in nums:\n            if num > result:\n                break\n            while num > result:\n                result <<= 1\n        return result\n```\n\nThis function works by first sorting the input array. Then it initializes a variable `result` to 1, which will hold the minimum non-expressible integer. It iterates over the sorted array, and for each number, it checks if it is greater than `result`. If it is, it breaks the loop, because `result` is the minimum non-expressible integer, and it has already been found. If the number is not greater than `result`, it means that `result` can be expressed as the bitwise OR of some subsequence of `nums`, so it left-shifts `result` by one bit, effectively doubling its value. This ensures that `result` is not expressible as the bitwise OR of any subsequence of `nums`. After the loop, it returns `result`, which is the minimum non-expressible integer.", "extracted_code": "\nclass Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        result = 1\n        for num in nums:\n            if num > result:\n                break\n            while num > result:\n                result <<= 1\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2565", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        s = \" \" + s\n        t = \" \" + t\n        m, n = len(s), len(t)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return m + n - 2 * dp[-1][-1]\n```\n\nThis function uses dynamic programming to find the longest common subsequence (LCS) of `s` and `t`. The LCS is a subsequence of both `s` and `t` which is as long as possible. The score is then calculated as `m + n - 2 * len(LCS)`, where `m` and `n` are the lengths of `s` and `t`, respectively. The time complexity of this function is O(m * n), where `m` and `n` are the lengths of `s` and `t`, respectively.", "extracted_code": "\nclass Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        s = \" \" + s\n        t = \" \" + t\n        m, n = len(s), len(t)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return m + n - 2 * dp[-1][-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2564", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        prefix_xor = [0] * (len(s) + 1)\n        for i in range(len(s)):\n            prefix_xor[i + 1] = prefix_xor[i] ^ int(s[i])\n\n        ans = []\n        for first, second in queries:\n            left, right = -1, -1\n            for i in range(first + 1, len(s) + 1):\n                if prefix_xor[i] == second ^ first:\n                    if left == -1 or i - first < right - left:\n                        left, right = first, i - 1\n            ans.append([left, right])\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        prefix_xor = [0] * (len(s) + 1)\n        for i in range(len(s)):\n            prefix_xor[i + 1] = prefix_xor[i] ^ int(s[i])\n\n        ans = []\n        for first, second in queries:\n            left, right = -1, -1\n            for i in range(first + 1, len(s) + 1):\n                if prefix_xor[i] == second ^ first:\n                    if left == -1 or i - first < right - left:\n                        left, right = first, i - 1\n            ans.append([left, right])\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2563", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                total = prefix_sum[j + 1] - prefix_sum[i]\n                if lower <= total <= upper:\n                    res += 1\n        return res\n```\n\nThis function works by first calculating the prefix sum of the array. Then, for each pair `(i, j)` with `i < j`, it calculates the sum of `nums[i:j+1]` using the prefix sum. If this sum lies in the range `[lower, upper]`, it increments the result. The time complexity is O(n^2) and the space complexity is O(n).", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                total = prefix_sum[j + 1] - prefix_sum[i]\n                if lower <= total <= upper:\n                    res += 1\n        return res\n", "difficulty": 2.0}
{"task_id": "LeetCode/2561", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        basket1.sort()\n        basket2.sort()\n        total_cost = 0\n        i, j = 0, 0\n        while i < len(basket1) and j < len(basket2):\n            if basket1[i] < basket2[j]:\n                total_cost += basket1[i]\n                i += 1\n            elif basket1[i] > basket2[j]:\n                total_cost += basket2[j]\n                j += 1\n            else:\n                total_cost += basket1[i]\n                i += 1\n                j += 1\n        while i < len(basket1):\n            total_cost += basket1[i]\n            i += 1\n        while j < len(basket2):\n            total_cost += basket2[j]\n            j += 1\n        return total_cost if total_cost <= 10**9 else -1\n```\n\nThis function first sorts both the baskets. Then it iterates over both the baskets simultaneously. If the current fruit in `basket1` is cheaper, it adds the cost to `total_cost` and moves the iterator of `basket1`. If the current fruit in `basket2` is cheaper, it adds the cost to `total_cost` and moves the iterator of `basket2`. If the fruits are of equal cost, it adds the cost to `total_cost` and moves both the iterators. After iterating over both the baskets,", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        basket1.sort()\n        basket2.sort()\n        total_cost = 0\n        i, j = 0, 0\n        while i < len(basket1) and j < len(basket2):\n            if basket1[i] < basket2[j]:\n                total_cost += basket1[i]\n                i += 1\n            elif basket1[i] > basket2[j]:\n                total_cost += basket2[j]\n                j += 1\n            else:\n                total_cost += basket1[i]\n                i += 1\n                j += 1\n        while i < len(basket1):\n            total_cost += basket1[i]\n            i += 1\n        while j < len(basket2):\n            total_cost += basket2[j]\n            j += 1\n        return total_cost if total_cost <= 10**9 else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2560", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if k == 1:\n            return min(nums)\n        if k == n:\n            return max(nums)\n        dp = [0] * (n + 2)\n        dp[1] = nums[0]\n        dp[2] = max(nums[0], nums[1])\n        for i in range(3, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])\n        return min(dp[k:])\n```\n\nThis function uses dynamic programming to solve the problem. The `dp` array stores the maximum amount of money that can be stolen from the first `i` houses, where `i` is the index of the current house. The `dp` array is initialized with the first two houses. Then, for each house from the third to the last, the maximum amount of money that can be stolen is either the maximum amount of money that can be stolen from the previous house (i.e., `dp[i - 1]`) or the maximum amount of money that can be stolen from the two previous houses plus the amount of money in the current house (i.e., `dp[i - 2] + nums[i - 1]`). Finally, the function returns the minimum of the maximum amounts of money that can be stolen from the first `k` houses.", "extracted_code": "\nclass Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if k == 1:\n            return min(nums)\n        if k == n:\n            return max(nums)\n        dp = [0] * (n + 2)\n        dp[1] = nums[0]\n        dp[2] = max(nums[0], nums[1])\n        for i in range(3, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])\n        return min(dp[k:])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2458", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node, parent):\n            if not node:\n                return\n            node.parent = parent\n            dfs(node.left, node)\n            dfs(node.right, node)\n        \n        def height(node):\n            h = 0\n            while node:\n                h += 1\n                node = node.parent\n            return h\n        \n        dfs(root, None)\n        return [height(root.left) + height(root.right) + 1 if node.val == queries[i] else height(node) for i, node in enumerate(root.left)]\n```\n\nThis solution first performs a depth-first search (DFS) on the tree to add parent pointers to each node. The height function computes the height of a given node by climbing up to the root. The main part of the solution is a list comprehension that iterates over the queries. For each query, it checks if the node with the queried value is in the left subtree of the root. If it is, it removes the subtree rooted at that node and computes the new height of the tree. If the node is not in the left subtree, it simply computes the height of the tree. The time complexity of this solution is O(n) for the DFS and", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def dfs(node, parent):\n            if not node:\n                return\n            node.parent = parent\n            dfs(node.left, node)\n            dfs(node.right, node)\n        \n        def height(node):\n            h = 0\n            while node:\n                h += 1\n                node = node.parent\n            return h\n        \n        dfs(root, None)\n        return [height(root.left) + height(root.right) + 1 if node.val == queries[i] else height(node) for i, node in enumerate(root.left)]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2457", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        n_digits = len(str(n))\n        n_sum = sum(int(digit) for digit in str(n))\n        if n_sum <= target:\n            return 0\n        else:\n            return (target+1)*(10**n_digits) - n - 1\n```\n\nThis function works by first calculating the number of digits in `n` and the sum of its digits `n_sum`. If `n_sum` is already less than or equal to `target`, it returns 0 as no additional digits need to be added.\n\nOtherwise, it calculates the minimum additional number `x` needed to make `n + x` beautiful. This is done by finding the smallest number that is a multiple of `target + 1` and greater than `n`. This is achieved by calculating `(target+1)*(10**n_digits) - n - 1`.", "extracted_code": "\nclass Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        n_digits = len(str(n))\n        n_sum = sum(int(digit) for digit in str(n))\n        if n_sum <= target:\n            return 0\n        else:\n            return (target+1)*(10**n_digits) - n - 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2455", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if not even_divisible_by_3:\n            return 0\n        return sum(even_divisible_by_3) // len(even_divisible_by_3)\n```", "extracted_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        even_divisible_by_3 = [num for num in nums if num % 2 == 0 and num % 3 == 0]\n        if not even_divisible_by_3:\n            return 0\n        return sum(even_divisible_by_3) // len(even_divisible_by_3)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2454", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        res = [-1] * len(nums)\n        for i, num in enumerate(nums):\n            while stack:\n                if nums[stack[-1]] > num:\n                    res[stack.pop()] = num\n                else:\n                    stack.pop()\n            stack.append(i)\n        return res\n```", "extracted_code": "\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        stack = []\n        res = [-1] * len(nums)\n        for i, num in enumerate(nums):\n            while stack:\n                if nums[stack[-1]] > num:\n                    res[stack.pop()] = num\n                else:\n                    stack.pop()\n            stack.append(i)\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2449", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        nums_counter = Counter(nums)\n        target_counter = Counter(target)\n        operations = 0\n        for num, freq in nums_counter.items():\n            if num not in target_counter:\n                operations += freq\n            else:\n                operations += abs(freq - target_counter[num])\n        return operations // 2\n```\n\nThis function works by first creating a Counter object for both the nums and target arrays. A Counter object is a dictionary where keys are array elements and values are the frequency of those elements in the array. Then, it iterates over the keys in the nums_counter. For each key, it checks if it is present in the target_counter. If it is not, it adds the frequency of that key in nums_counter to the operations. If it is present, it adds the absolute difference between the frequencies of that key in nums_counter and target_counter to the operations. Finally, it returns operations divided by 2, because each operation involves two indices.", "extracted_code": "\nclass Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        nums_counter = Counter(nums)\n        target_counter = Counter(target)\n        operations = 0\n        for num, freq in nums_counter.items():\n            if num not in target_counter:\n                operations += freq\n            else:\n                operations += abs(freq - target_counter[num])\n        return operations // 2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2448", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        min_num = min(nums)\n        min_index = nums.index(min_num)\n        total_cost = 0\n        for i in range(n):\n            if nums[i] != min_num:\n                diff = abs(nums[i] - min_num)\n                total_cost += cost[i] * diff\n                nums[i] = min_num\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        min_num = min(nums)\n        min_index = nums.index(min_num)\n        total_cost = 0\n        for i in range(n):\n            if nums[i] != min_num:\n                diff = abs(nums[i] - min_num)\n                total_cost += cost[i] * diff\n                nums[i] = min_num\n        return total_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2444", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        min_count = [0] * (n + 1)\n        max_count = [0] * (n + 1)\n        min_count[0] = max_count[0] = 1\n        res = 0\n\n        for i in range(1, n + 1):\n            min_count[i] = min_count[i - 1] + (nums[i - 1] == minK)\n            max_count[i] = max_count[i - 1] + (nums[i - 1] == maxK)\n\n        for i in range(n):\n            if nums[i] == minK or nums[i] == maxK:\n                res += min_count[i] * max_count[n] + max_count[i] * min_count[n]\n            else:\n                res += min_count[i] * max_count[i]\n\n        return res\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        n = len(nums)\n        min_count = [0] * (n + 1)\n        max_count = [0] * (n + 1)\n        min_count[0] = max_count[0] = 1\n        res = 0\n\n        for i in range(1, n + 1):\n            min_count[i] = min_count[i - 1] + (nums[i - 1] == minK)\n            max_count[i] = max_count[i - 1] + (nums[i - 1] == maxK)\n\n        for i in range(n):\n            if nums[i] == minK or nums[i] == maxK:\n                res += min_count[i] * max_count[n] + max_count[i] * min_count[n]\n            else:\n                res += min_count[i] * max_count[i]\n\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2443", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        return num == int(str(num)[::-1]) * 2\n```", "extracted_code": "\nclass Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        return num == int(str(num)[::-1]) * 2\n", "difficulty": 2.0}
{"task_id": "LeetCode/2442", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        nums.extend(int(str(num)[::-1]) for num in nums)\n        return len(set(nums))\n```", "extracted_code": "\nclass Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        nums.extend(int(str(num)[::-1]) for num in nums)\n        return len(set(nums))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2440", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node, parent):\n            subtree_sum = nums[node]\n            children_count = 1\n            for child in graph[node]:\n                if child != parent:\n                    child_sum, child_count = dfs(child, node)\n                    subtree_sum += child_sum\n                    children_count += child_count\n            return subtree_sum, children_count\n\n        total_sum, total_count = dfs(0, -1)\n        target_value = total_sum // total_count\n\n        def check(edges_to_delete):\n            remaining_edges = set(range(len(edges))) - set(edges_to_delete)\n            visited = [False] * len(nums)\n            stack = [0]\n            while stack:\n                node = stack.pop()\n                if not visited[node]:\n                    subtree_sum, children_count = dfs(node, -1)\n                    if subtree_sum != target_value * children_count:\n                        return False\n                    visited[node] = True\n                    for child in graph[node]:\n                        if not visited[child]:\n                            stack.append(child)\n            return True\n\n        left, right = 0, len(edges)", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node, parent):\n            subtree_sum = nums[node]\n            children_count = 1\n            for child in graph[node]:\n                if child != parent:\n                    child_sum, child_count = dfs(child, node)\n                    subtree_sum += child_sum\n                    children_count += child_count\n            return subtree_sum, children_count\n\n        total_sum, total_count = dfs(0, -1)\n        target_value = total_sum // total_count\n\n        def check(edges_to_delete):\n            remaining_edges = set(range(len(edges))) - set(edges_to_delete)\n            visited = [False] * len(nums)\n            stack = [0]\n            while stack:\n                node = stack.pop()\n                if not visited[node]:\n                    subtree_sum, children_count = dfs(node, -1)\n                    if subtree_sum != target_value * children_count:\n                        return False\n                    visited[node] = True\n                    for child in graph[node]:\n                        if not visited[child]:\n                            stack.append(child)\n            return True\n\n        left, right = 0, len(edges)", "difficulty": 3.0}
{"task_id": "LeetCode/2438", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 10**9 + 7\n        powers = [1]\n        while powers[-1] < n:\n            powers.append(powers[-1] * 2 % MOD)\n        answers = []\n        for start, end in queries:\n            if start == 0:\n                answers.append(powers[end])\n            else:\n                answers.append(powers[end] * powers[start-1] % MOD)\n        return answers\n```", "extracted_code": "\nclass Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = 10**9 + 7\n        powers = [1]\n        while powers[-1] < n:\n            powers.append(powers[-1] * 2 % MOD)\n        answers = []\n        for start, end in queries:\n            if start == 0:\n                answers.append(powers[end])\n            else:\n                answers.append(powers[end] * powers[start-1] % MOD)\n        return answers\n", "difficulty": 2.0}
{"task_id": "LeetCode/2435", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        mod = 10**9 + 7\n\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod\n\n        return dp[m-1][n-1] - sum(dp[i][n-1] for i in range(m) if (grid[i][0] + i * grid[i][1]) % k != 0) % mod\n```\n\nThis function uses dynamic programming to calculate the number of paths from the top-left corner to the bottom-right corner. The `dp` array stores the number of paths to each cell. The number of paths to cell `(i, j)` is the sum of the paths to cell `(i-1, j)` and `(i, j-1)`.\n\nThe function then subtracts the number of paths where the sum of the elements on the path is not divisible by `k`. This is calculated by summing the number of paths to the last column for each row where the sum of the elements in the row is not divisible by `k`.\n\nThe result is", "extracted_code": "\nclass Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        mod = 10**9 + 7\n\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod\n\n        return dp[m-1][n-1] - sum(dp[i][n-1] for i in range(m) if (grid[i][0] + i * grid[i][1]) % k != 0) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2434", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = ''\n        while s or t:\n            if s:\n                t += s[0]\n                s = s[1:]\n            if t:\n                t = t[:-1]\n        return t\n```", "extracted_code": "\nclass Solution:\n    def robotWithString(self, s: str) -> str:\n        t = ''\n        while s or t:\n            if s:\n                t += s[0]\n                s = s[1:]\n            if t:\n                t = t[:-1]\n        return t\n", "difficulty": 2.0}
{"task_id": "LeetCode/2432", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        times = [0] * n\n        for log in logs:\n            times[log[0]] += log[1]\n        max_time = max(times)\n        min_id = times.index(max_time)\n        return min_id\n```", "extracted_code": "\nclass Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        times = [0] * n\n        for log in logs:\n            times[log[0]] += log[1]\n        max_time = max(times)\n        min_id = times.index(max_time)\n        return min_id\n", "difficulty": 1.0}
{"task_id": "LeetCode/2430", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = i\n            for j in range(i):\n                if s[j] == s[i - 1]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return n - dp[n]\n```", "extracted_code": "\nclass Solution:\n    def deleteString(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = i\n            for j in range(i):\n                if s[j] == s[i - 1]:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return n - dp[n]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2429", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        x = num1\n        while True:\n            if bin(x).count('1') == bin(num2).count('1'):\n                return x\n            x += 1\n```", "extracted_code": "\nclass Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        x = num1\n        while True:\n            if bin(x).count('1') == bin(num2).count('1'):\n                return x\n            x += 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2427", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        if a > b:\n            a, b = b, a\n        common_factors = 0\n        for i in range(1, a+1):\n            if a % i == 0 and b % i == 0:\n                common_factors += 1\n        return common_factors\n```", "extracted_code": "\nclass Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        if a > b:\n            a, b = b, a\n        common_factors = 0\n        for i in range(1, a+1):\n            if a % i == 0 and b % i == 0:\n                common_factors += 1\n        return common_factors\n", "difficulty": 1.0}
{"task_id": "LeetCode/2426", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(i+1, len(nums1)):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(i+1, len(nums1)):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2425", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_result = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_result ^= num1 ^ num2\n        return xor_result\n```", "extracted_code": "\nclass Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        xor_result = 0\n        for num1 in nums1:\n            for num2 in nums2:\n                xor_result ^= num1 ^ num2\n        return xor_result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2424", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.uploaded = set()\n        self.longest_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded.add(video)\n        while video - self.longest_prefix not in self.uploaded:\n            self.longest_prefix += 1\n\n    def longest(self) -> int:\n        return self.longest_prefix", "extracted_code": "\nclass LUPrefix:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.uploaded = set()\n        self.longest_prefix = 0\n\n    def upload(self, video: int) -> None:\n        self.uploaded.add(video)\n        while video - self.longest_prefix not in self.uploaded:\n            self.longest_prefix += 1\n\n    def longest(self) -> int:\n        return self.longest_prefix", "difficulty": 2.0}
{"task_id": "LeetCode/2421", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport numpy as np\n\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n        tree = [[] for _ in range(n)]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        dp = [0] * n\n        dp[0] = 1\n        mod = 10**9 + 7\n\n        def dfs(node, parent):\n            val = vals[node]\n            for child in tree[node]:\n                if child != parent:\n                    dfs(child, node)\n                    dp[node] = (dp[node] + dp[child]) % mod\n                    if vals[child] <= val:\n                        dp[node] = (dp[node] + dp[child]) % mod\n            if node != 0:\n                dp[parent] = (dp[parent] + dp[node]) % mod\n\n        dfs(0, -1)\n        return dp[0]\n```\n\nThis function uses depth-first search (DFS) to traverse the tree and calculate the number of good paths. It maintains a dp array to store the number of good paths ending at each node. For each node, it iterates through its children. If a child's value is less than or equal to the node's value, it adds the number of good paths from the child to the node's dp value. After visiting all children, it adds the node's dp value to", "extracted_code": "\nimport numpy as np\n\nclass Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n        tree = [[] for _ in range(n)]\n        for u, v in edges:\n            tree[u].append(v)\n            tree[v].append(u)\n        dp = [0] * n\n        dp[0] = 1\n        mod = 10**9 + 7\n\n        def dfs(node, parent):\n            val = vals[node]\n            for child in tree[node]:\n                if child != parent:\n                    dfs(child, node)\n                    dp[node] = (dp[node] + dp[child]) % mod\n                    if vals[child] <= val:\n                        dp[node] = (dp[node] + dp[child]) % mod\n            if node != 0:\n                dp[parent] = (dp[parent] + dp[node]) % mod\n\n        dfs(0, -1)\n        return dp[0]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2419", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_and = 0\n        longest_subarray = 0\n        for i in range(n):\n            curr_and = nums[i]\n            for j in range(i+1, n):\n                curr_and &= nums[j]\n                if curr_and > max_and:\n                    max_and = curr_and\n                    longest_subarray = j - i + 1\n                elif curr_and == max_and:\n                    longest_subarray = max(longest_subarray, j - i + 1)\n        return longest_subarray\n```\n\nThis function works by iterating over all possible subarrays of `nums` and calculating their bitwise AND. If the bitwise AND is greater than `max_and`, we update `max_and` and `longest_subarray`. If the bitwise AND is equal to `max_and`, we update `longest_subarray` if the current subarray is longer. The function finally returns the length of the longest subarray with the maximum possible bitwise AND.\n\nThe time complexity of this function is O(n^2), where n is the length of `nums`. This is because we are iterating over all possible subarrays of `nums`. The space complexity is O(1), as we are only using a constant amount of space to store `max_and` and `longest_subarray`.", "extracted_code": "\nclass Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_and = 0\n        longest_subarray = 0\n        for i in range(n):\n            curr_and = nums[i]\n            for j in range(i+1, n):\n                curr_and &= nums[j]\n                if curr_and > max_and:\n                    max_and = curr_and\n                    longest_subarray = j - i + 1\n                elif curr_and == max_and:\n                    longest_subarray = max(longest_subarray, j - i + 1)\n        return longest_subarray\n", "difficulty": 2.0}
{"task_id": "LeetCode/2416", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                node = node.setdefault(letter, {})\n        scores = [0] * len(words)\n        for i, word in enumerate(words):\n            node = trie\n            for letter in word:\n                node = node[letter]\n                for j, other_word in enumerate(words):\n                    if j == i or other_word.startswith(word):\n                        continue\n                    if other_word.startswith(word[:len(other_word)]):\n                        scores[i] += 1\n        return scores\n```", "extracted_code": "\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                node = node.setdefault(letter, {})\n        scores = [0] * len(words)\n        for i, word in enumerate(words):\n            node = trie\n            for letter in word:\n                node = node[letter]\n                for j, other_word in enumerate(words):\n                    if j == i or other_word.startswith(word):\n                        continue\n                    if other_word.startswith(word[:len(other_word)]):\n                        scores[i] += 1\n        return scores\n", "difficulty": 3.0}
{"task_id": "LeetCode/2415", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(node, level):\n            if not node:\n                return\n            if level % 2:\n                node.val, node.left.val = node.left.val, node.val\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n            else:\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n        dfs(root, 1)\n        return root\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(node, level):\n            if not node:\n                return\n            if level % 2:\n                node.val, node.left.val = node.left.val, node.val\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n            else:\n                dfs(node.left, level + 1)\n                dfs(node.right, level + 1)\n        dfs(root, 1)\n        return root\n", "difficulty": 2.0}
{"task_id": "LeetCode/2414", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_length = 0\n        current_length = 1\n        prev_char = s[0]\n\n        for char in s[1:]:\n            if char == chr(ord(prev_char) + 1):\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n            prev_char = char\n\n        return max(max_length, current_length)\n```", "extracted_code": "\nclass Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        max_length = 0\n        current_length = 1\n        prev_char = s[0]\n\n        for char in s[1:]:\n            if char == chr(ord(prev_char) + 1):\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n            prev_char = char\n\n        return max(max_length, current_length)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2413", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n * 2\n```", "extracted_code": "\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n * 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2412", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        total_cost = sum(t[0] for t in transactions)\n        total_cashback = sum(t[1] for t in transactions)\n        return max(total_cost - total_cashback, 0)\n```", "extracted_code": "\nclass Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        total_cost = sum(t[0] for t in transactions)\n        total_cashback = sum(t[1] for t in transactions)\n        return max(total_cost - total_cashback, 0)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2409", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        a_arrive, a_leave = map(int, arriveAlice.split('-'))\n        b_arrive, b_leave = map(int, arriveBob.split('-'))\n        b_leave += 1\n        if a_arrive < b_arrive:\n            a_arrive = b_arrive\n        else:\n            b_arrive = a_arrive\n        if a_leave > b_leave:\n            a_leave = b_leave\n        else:\n            b_leave = a_leave\n        return max(0, (b_leave - a_arrive) * month_days[a_arrive - 1] - (a_arrive - b_arrive) * month_days[b_arrive - 1] + min(month_days[a_arrive - 1] - a_arrive + 1, month_days[b_arrive - 1] - b_arrive + 1))\n```", "extracted_code": "\nclass Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        a_arrive, a_leave = map(int, arriveAlice.split('-'))\n        b_arrive, b_leave = map(int, arriveBob.split('-'))\n        b_leave += 1\n        if a_arrive < b_arrive:\n            a_arrive = b_arrive\n        else:\n            b_arrive = a_arrive\n        if a_leave > b_leave:\n            a_leave = b_leave\n        else:\n            b_leave = a_leave\n        return max(0, (b_leave - a_arrive) * month_days[a_arrive - 1] - (a_arrive - b_arrive) * month_days[b_arrive - 1] + min(month_days[a_arrive - 1] - a_arrive + 1, month_days[b_arrive - 1] - b_arrive + 1))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2407", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        dp = [1] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n```", "extracted_code": "\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        dp = [1] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2402", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        room_counts = [0] * n\n        heap = []\n        for start, end in meetings:\n            while heap and heap[0][0] < start:\n                heapq.heappop(heap)\n            room = heap[0][1] if heap else 0\n            room_counts[room] += 1\n            heapq.heappush(heap, (end, room))\n        return room_counts.index(max(room_counts))\n```\n\nThis solution uses a priority queue to keep track of the rooms that are currently being used and their expected free time. The priority queue is ordered by the expected free time of the rooms.\n\nFor each meeting, we first remove all rooms from the priority queue that are expected to be free before the start time of the current meeting. Then, we assign the current meeting to the room that is expected to be free the earliest, or to room 0 if no such room exists. After the assignment, we update the room's expected free time in the priority queue.\n\nFinally, we count the number of meetings assigned to each room and return the room that held the most meetings. If there are multiple such rooms, we return the one with the lowest number.", "extracted_code": "\nclass Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        room_counts = [0] * n\n        heap = []\n        for start, end in meetings:\n            while heap and heap[0][0] < start:\n                heapq.heappop(heap)\n            room = heap[0][1] if heap else 0\n            room_counts[room] += 1\n            heapq.heappush(heap, (end, room))\n        return room_counts.index(max(room_counts))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2401", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_length = 1\n        for i in range(n):\n            for j in range(i+1, n):\n                if (nums[i] & nums[j]) == 0:\n                    max_length = max(max_length, j-i+1)\n        return max_length\n```", "extracted_code": "\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_length = 1\n        for i in range(n):\n            for j in range(i+1, n):\n                if (nums[i] & nums[j]) == 0:\n                    max_length = max(max_length, j-i+1)\n        return max_length\n", "difficulty": 2.0}
{"task_id": "LeetCode/2399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        letter_positions = {}\n        for i, letter in enumerate(s):\n            if letter in letter_positions:\n                if i - letter_positions[letter] - 1 != distance[ord(letter) - ord('a')]:\n                    return False\n            else:\n                letter_positions[letter] = i\n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        letter_positions = {}\n        for i, letter in enumerate(s):\n            if letter in letter_positions:\n                if i - letter_positions[letter] - 1 != distance[ord(letter) - ord('a')]:\n                    return False\n            else:\n                letter_positions[letter] = i\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/2398", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        robots = sorted(zip(chargeTimes, runningCosts), key=lambda x: x[0])\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + robots[i][1]\n        l, r = 0, n\n        while l < r:\n            m = (l + r + 1) // 2\n            if self.check(robots, prefix_sum, m, budget):\n                l = m\n            else:\n                r = m - 1\n        return l\n\n    def check(self, robots, prefix_sum, m, budget):\n        total_cost = max(robots[i][0] for i in range(m)) + prefix_sum[m]\n        for i in range(m - 1, -1, -1):\n            total_cost -= robots[i][1]\n            if total_cost + robots[i][0] <= budget:\n                return True\n            total_cost += robots[i][1]\n        return False\n```", "extracted_code": "\nclass Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        n = len(chargeTimes)\n        robots = sorted(zip(chargeTimes, runningCosts), key=lambda x: x[0])\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + robots[i][1]\n        l, r = 0, n\n        while l < r:\n            m = (l + r + 1) // 2\n            if self.check(robots, prefix_sum, m, budget):\n                l = m\n            else:\n                r = m - 1\n        return l\n\n    def check(self, robots, prefix_sum, m, budget):\n        total_cost = max(robots[i][0] for i in range(m)) + prefix_sum[m]\n        for i in range(m - 1, -1, -1):\n            total_cost -= robots[i][1]\n            if total_cost + robots[i][0] <= budget:\n                return True\n            total_cost += robots[i][1]\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2397", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        n = len(matrix[0])\n        cols = [0]*n\n        for row in matrix:\n            for j in range(n):\n                if row[j]:\n                    cols[j] += 1\n        select = sorted(range(n), key=lambda i: cols[i], reverse=True)\n        select = select[:numSelect]\n        rows = [0]*len(matrix)\n        for j in select:\n            for i in range(len(matrix)):\n                if matrix[i][j]:\n                    rows[i] = 1\n        return sum(rows)\n```\n\nThis function works by first counting the number of ones in each column and storing it in the `cols` list. Then, it sorts the indices of the columns based on the count in descending order. It then selects the first `numSelect` columns from this sorted list. For each of these selected columns, it iterates through the rows and sets the corresponding index in the `rows` list to 1 if the cell in the matrix is 1. Finally, it returns the sum of the `rows` list, which represents the number of rows that are covered.", "extracted_code": "\nclass Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        n = len(matrix[0])\n        cols = [0]*n\n        for row in matrix:\n            for j in range(n):\n                if row[j]:\n                    cols[j] += 1\n        select = sorted(range(n), key=lambda i: cols[i], reverse=True)\n        select = select[:numSelect]\n        rows = [0]*len(matrix)\n        for j in select:\n            for i in range(len(matrix)):\n                if matrix[i][j]:\n                    rows[i] = 1\n        return sum(rows)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2396", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        for b in range(2, n - 1):\n            s = str(int(str(n), b))\n            if s != s[::-1]:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        for b in range(2, n - 1):\n            s = str(int(str(n), b))\n            if s != s[::-1]:\n                return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2392", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        matrix = [[0]*k for _ in range(k)]\n        row_map = {i: [] for i in range(1, k+1)}\n        col_map = {i: [] for i in range(1, k+1)}\n        \n        for condition in rowConditions:\n            above, below = condition\n            row_map[above].append(below)\n            row_map[below].append(above)\n        \n        for condition in colConditions:\n            left, right = condition\n            col_map[left].append(right)\n            col_map[right].append(left)\n        \n        for i in range(1, k+1):\n            if len(row_map[i]) != len(col_map[i]):\n                return []\n        \n        for i in range(1, k+1):\n            if len(row_map[i]) == 0:\n                matrix[0][i-1] = i\n                row_map[i+1].append(i)\n                col_map[i+1].append(i)\n        \n        for i in range(1, k):\n            for j in range(1, k):\n                if matrix[i][j] == 0:\n                    matrix[i][j] = row_map[matrix[i-1][j]][0]\n                    matrix[i+1][j] = col_map[matrix[i][j+1]][", "extracted_code": "\nclass Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        matrix = [[0]*k for _ in range(k)]\n        row_map = {i: [] for i in range(1, k+1)}\n        col_map = {i: [] for i in range(1, k+1)}\n        \n        for condition in rowConditions:\n            above, below = condition\n            row_map[above].append(below)\n            row_map[below].append(above)\n        \n        for condition in colConditions:\n            left, right = condition\n            col_map[left].append(right)\n            col_map[right].append(left)\n        \n        for i in range(1, k+1):\n            if len(row_map[i]) != len(col_map[i]):\n                return []\n        \n        for i in range(1, k+1):\n            if len(row_map[i]) == 0:\n                matrix[0][i-1] = i\n                row_map[i+1].append(i)\n                col_map[i+1].append(i)\n        \n        for i in range(1, k):\n            for j in range(1, k):\n                if matrix[i][j] == 0:\n                    matrix[i][j] = row_map[matrix[i-1][j]][0]\n                    matrix[i+1][j] = col_map[matrix[i][j+1]][", "difficulty": 3.0}
{"task_id": "LeetCode/2390", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        while '*' in s:\n            star_index = s.index('*')\n            s = s[:star_index] + s[star_index+1:]\n            if star_index > 0:\n                s = s[:star_index-1] + s[star_index:]\n        return s\n```", "extracted_code": "\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        while '*' in s:\n            star_index = s.index('*')\n            s = s[:star_index] + s[star_index+1:]\n            if star_index > 0:\n                s = s[:star_index-1] + s[star_index:]\n        return s\n", "difficulty": 2.0}
{"task_id": "LeetCode/2386", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nimport numpy as np\n\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        presum = np.zeros(n + 1)\n        for i in range(n):\n            presum[i + 1] = presum[i] + nums[i]\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(min(i, k) + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if j >= 1:\n                    dp[i][j] -= dp[i - 1][j - 1]\n                if j >= 2:\n                    dp[i][j] += dp[i - 1][j - 2] * (presum[i - 1] - (j - 2) * nums[i - 1])\n        return dp[n][k]\n```\n\nThis function uses dynamic programming to find the k-sum of the array. The dp array stores the number of ways to get a sum of j using the first i numbers. The inner two loops update the dp array based on the previous row and the current number. The last line returns the k-sum, which is the sum of ways to get a sum of k using all the numbers.", "extracted_code": "\nimport numpy as np\n\nclass Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        nums = sorted(nums)\n        n = len(nums)\n        presum = np.zeros(n + 1)\n        for i in range(n):\n            presum[i + 1] = presum[i] + nums[i]\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(min(i, k) + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if j >= 1:\n                    dp[i][j] -= dp[i - 1][j - 1]\n                if j >= 2:\n                    dp[i][j] += dp[i - 1][j - 2] * (presum[i - 1] - (j - 2) * nums[i - 1])\n        return dp[n][k]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2385", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import deque\n\nclass Solution:\n    def amountOfTime(self, root: TreeNode, start: int) -> int:\n        queue = deque([(root, 0)])\n        infected = set()\n        minutes = 0\n\n        while queue:\n            node, time = queue.popleft()\n            if node.val not in infected:\n                infected.add(node.val)\n                minutes = time\n                if node.left:\n                    queue.append((node.left, time + 1))\n                if node.right:\n                    queue.append((node.right, time + 1))\n\n        return minutes\n```\n\nThis solution uses a breadth-first search (BFS) to traverse the tree. It uses a queue to store the nodes and their corresponding time of infection. The time of infection for a node is the time it takes for the infection to reach the node from the starting node.\n\nThe algorithm starts at the root node and adds it to the queue. Then it enters a while loop that continues until the queue is empty. In each iteration of the loop, it removes a node from the queue and checks if it has been infected. If not, it infects the node, updates the time of infection, and adds its children to the queue. The algorithm stops when all nodes have been infected and returns the time of infection for the last node to be infected.", "extracted_code": "\nfrom collections import deque\n\nclass Solution:\n    def amountOfTime(self, root: TreeNode, start: int) -> int:\n        queue = deque([(root, 0)])\n        infected = set()\n        minutes = 0\n\n        while queue:\n            node, time = queue.popleft()\n            if node.val not in infected:\n                infected.add(node.val)\n                minutes = time\n                if node.left:\n                    queue.append((node.left, time + 1))\n                if node.right:\n                    queue.append((node.right, time + 1))\n\n        return minutes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2382", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        max_sum = 0\n        answer = []\n        for i in sorted(removeQueries):\n            max_sum = max(max_sum, prefix_sum[i] - prefix_sum[i - 1])\n            answer.append(max_sum)\n            prefix_sum[i + 1] = prefix_sum[i] - nums[i - 1]\n        \n        return answer\n```", "extracted_code": "\nclass Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        max_sum = 0\n        answer = []\n        for i in sorted(removeQueries):\n            max_sum = max(max_sum, prefix_sum[i] - prefix_sum[i - 1])\n            answer.append(max_sum)\n            prefix_sum[i + 1] = prefix_sum[i] - nums[i - 1]\n        \n        return answer\n", "difficulty": 3.0}
{"task_id": "LeetCode/2376", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        return sum(len(set(str(i))) == len(str(i)) for i in range(1, n+1))\n```", "extracted_code": "\nclass Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        return sum(len(set(str(i))) == len(str(i)) for i in range(1, n+1))\n", "difficulty": 3.0}
{"task_id": "LeetCode/2368", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        dist = [0] * n\n        visited = [False] * n\n        heap = [0]\n        while heap:\n            node = heappop(heap)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for nei in graph[node]:\n                if not visited[nei]:\n                    heappush(heap, nei)\n                    dist[nei] = dist[node] + 1\n        ans = len(visited) - len(restricted)\n        for node in restricted:\n            if not visited[node]:\n                ans += 1\n        return ans\n```", "extracted_code": "\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        dist = [0] * n\n        visited = [False] * n\n        heap = [0]\n        while heap:\n            node = heappop(heap)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for nei in graph[node]:\n                if not visited[nei]:\n                    heappush(heap, nei)\n                    dist[nei] = dist[node] + 1\n        ans = len(visited) - len(restricted)\n        for node in restricted:\n            if not visited[node]:\n                ans += 1\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2366", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        n = len(nums)\n        operations = 0\n        stack = []\n        for i in range(n):\n            while stack and nums[i] < nums[stack[-1]]:\n                idx = stack.pop()\n                a = nums[idx] - idx - 1\n                b = idx + 1\n                operations += (a // b) + (a % b != 0)\n                nums[idx] = a\n            stack.append(i)\n        return operations\n```", "extracted_code": "\nclass Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        n = len(nums)\n        operations = 0\n        stack = []\n        for i in range(n):\n            while stack and nums[i] < nums[stack[-1]]:\n                idx = stack.pop()\n                a = nums[idx] - idx - 1\n                b = idx + 1\n                operations += (a // b) + (a % b != 0)\n                nums[idx] = a\n            stack.append(i)\n        return operations\n", "difficulty": 3.0}
{"task_id": "LeetCode/2365", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import Counter\nfrom heapq import *\n\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_counts = list(Counter(tasks).values())\n        total_tasks = len(tasks)\n        \n        task_counts.sort(reverse=True)\n        intervals = [0] * len(task_counts)\n        heap = []\n        \n        for i in range(len(task_counts)):\n            if i < space:\n                intervals[i] = task_counts[i]\n            else:\n                intervals[i] = task_counts[i] + intervals[i - space]\n            heappush(heap, -intervals[i])\n        \n        max_interval = -heappop(heap)\n        for _ in range(space):\n            max_interval -= task_counts[_]\n            if max_interval < 0:\n                max_interval = 0\n        \n        return total_tasks + max(intervals)\n```\n\nThis function first counts the frequency of each task type and sorts them in descending order. It then calculates the maximum number of tasks that can be scheduled in each interval, considering the given space constraint. The minimum number of days needed to complete all tasks is then the sum of the total number of tasks and the maximum interval.", "extracted_code": "\nfrom collections import Counter\nfrom heapq import *\n\nclass Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        task_counts = list(Counter(tasks).values())\n        total_tasks = len(tasks)\n        \n        task_counts.sort(reverse=True)\n        intervals = [0] * len(task_counts)\n        heap = []\n        \n        for i in range(len(task_counts)):\n            if i < space:\n                intervals[i] = task_counts[i]\n            else:\n                intervals[i] = task_counts[i] + intervals[i - space]\n            heappush(heap, -intervals[i])\n        \n        max_interval = -heappop(heap)\n        for _ in range(space):\n            max_interval -= task_counts[_]\n            if max_interval < 0:\n                max_interval = 0\n        \n        return total_tasks + max(intervals)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2360", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        visited = [0] * n\n        longest_cycle = 0\n\n        for i in range(n):\n            if visited[i] == 0:\n                node = i\n                cycle_length = 0\n                while True:\n                    visited[node] = 1\n                    next_node = edges[node]\n                    if next_node == -1 or visited[next_node] == 2:\n                        break\n                    if visited[next_node] == 1:\n                        cycle_length += 1\n                        break\n                    node = next_node\n                    cycle_length += 1\n                if cycle_length > 0:\n                    longest_cycle = max(longest_cycle, cycle_length)\n                    while True:\n                        visited[node] = 2\n                        next_node = edges[node]\n                        if next_node == -1 or visited[next_node] != 0:\n                            break\n                        node = next_node\n\n        return longest_cycle if longest_cycle > 0 else -1\n```", "extracted_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        visited = [0] * n\n        longest_cycle = 0\n\n        for i in range(n):\n            if visited[i] == 0:\n                node = i\n                cycle_length = 0\n                while True:\n                    visited[node] = 1\n                    next_node = edges[node]\n                    if next_node == -1 or visited[next_node] == 2:\n                        break\n                    if visited[next_node] == 1:\n                        cycle_length += 1\n                        break\n                    node = next_node\n                    cycle_length += 1\n                if cycle_length > 0:\n                    longest_cycle = max(longest_cycle, cycle_length)\n                    while True:\n                        visited[node] = 2\n                        next_node = edges[node]\n                        if next_node == -1 or visited[next_node] != 0:\n                            break\n                        node = next_node\n\n        return longest_cycle if longest_cycle > 0 else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2359", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        dist1, dist2 = [0] * n, [0] * n\n        stack1, stack2 = [node1], [node2]\n        \n        while stack1:\n            node = stack1.pop()\n            if node != -1:\n                dist1[node] = dist1[edges[node]] + 1\n                stack1.append(edges[node])\n        \n        while stack2:\n            node = stack2.pop()\n            if node != -1:\n                dist2[node] = dist2[edges[node]] + 1\n                stack2.append(edges[node])\n        \n        min_dist = float('inf')\n        min_node = -1\n        for i in range(n):\n            if edges[i] != -1 and max(dist1[i], dist2[i]) < min_dist:\n                min_dist = max(dist1[i], dist2[i])\n                min_node = i\n        \n        return min_node\n```", "extracted_code": "\nclass Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        dist1, dist2 = [0] * n, [0] * n\n        stack1, stack2 = [node1], [node2]\n        \n        while stack1:\n            node = stack1.pop()\n            if node != -1:\n                dist1[node] = dist1[edges[node]] + 1\n                stack1.append(edges[node])\n        \n        while stack2:\n            node = stack2.pop()\n            if node != -1:\n                dist2[node] = dist2[edges[node]] + 1\n                stack2.append(edges[node])\n        \n        min_dist = float('inf')\n        min_node = -1\n        for i in range(n):\n            if edges[i] != -1 and max(dist1[i], dist2[i]) < min_dist:\n                min_dist = max(dist1[i], dist2[i])\n                min_node = i\n        \n        return min_node\n", "difficulty": 2.0}
{"task_id": "LeetCode/2354", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        from collections import Counter\n        from itertools import combinations\n\n        n = len(nums)\n        cnt = Counter(nums)\n        ans = 0\n\n        for x, y in combinations(cnt, 2):\n            if x & y == 0:\n                ans += cnt[x] * cnt[y]\n            else:\n                ans += cnt[x] * cnt[y] - cnt[x & y]\n\n        return ans // 2 >= k\n```\n\nThis function first counts the frequency of each number in the input array using the Counter class from the collections library. It then iterates over all pairs of distinct numbers and calculates the number of excellent pairs. The function finally returns True if the total number of excellent pairs is greater than or equal to k, and False otherwise.", "extracted_code": "\nclass Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        from collections import Counter\n        from itertools import combinations\n\n        n = len(nums)\n        cnt = Counter(nums)\n        ans = 0\n\n        for x, y in combinations(cnt, 2):\n            if x & y == 0:\n                ans += cnt[x] * cnt[y]\n            else:\n                ans += cnt[x] * cnt[y] - cnt[x & y]\n\n        return ans // 2 >= k\n", "difficulty": 3.0}
{"task_id": "LeetCode/2353", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.foods = foods\n        self.cuisines = cuisines\n        self.ratings = ratings\n        self.cuisine_dict = {}\n        for i in range(len(foods)):\n            if cuisines[i] not in self.cuisine_dict:\n                self.cuisine_dict[cuisines[i]] = [(foods[i], ratings[i])]\n            else:\n                self.cuisine_dict[cuisines[i]].append((foods[i], ratings[i]))\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        index = self.foods.index(food)\n        self.ratings[index] = newRating\n        for i in range(len(self.cuisines)):\n            if self.foods[i] == food:\n                self.cuisine_dict[self.cuisines[i]][i] = (self.foods[i], newRating)\n                break\n\n    def highestRated(self, cuisine: str) -> str:\n        cuisine_list = sorted(self.cuisine_dict[cuisine], key=lambda x: (-x[1], x[0]))\n        return cuisine_list[0][0]", "extracted_code": "\nfrom typing import List\n\nclass FoodRatings:\n\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.foods = foods\n        self.cuisines = cuisines\n        self.ratings = ratings\n        self.cuisine_dict = {}\n        for i in range(len(foods)):\n            if cuisines[i] not in self.cuisine_dict:\n                self.cuisine_dict[cuisines[i]] = [(foods[i], ratings[i])]\n            else:\n                self.cuisine_dict[cuisines[i]].append((foods[i], ratings[i]))\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        index = self.foods.index(food)\n        self.ratings[index] = newRating\n        for i in range(len(self.cuisines)):\n            if self.foods[i] == food:\n                self.cuisine_dict[self.cuisines[i]][i] = (self.foods[i], newRating)\n                break\n\n    def highestRated(self, cuisine: str) -> str:\n        cuisine_list = sorted(self.cuisine_dict[cuisine], key=lambda x: (-x[1], x[0]))\n        return cuisine_list[0][0]", "difficulty": 2.0}
{"task_id": "LeetCode/2350", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        freq = [0] * k\n        for roll in rolls:\n            freq[roll - 1] += 1\n        for i in range(k - 1, -1, -1):\n            if freq[i] > 0:\n                for j in range(i + 1, k):\n                    freq[j] -= freq[i]\n                return i + 1\n        return k + 1\n```\n\nThis function works by first counting the frequency of each number from 1 to k in the rolls. Then, it iterates from the highest number to the lowest, checking if the frequency of the current number is greater than 0. If it is, it subtracts the frequency of the current number from the frequencies of all numbers greater than the current number, and returns the current number plus 1 as the length of the shortest sequence that cannot be taken from rolls. If no number has a frequency greater than 0, it returns k + 1 as the length of the shortest sequence that cannot be taken from rolls.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        freq = [0] * k\n        for roll in rolls:\n            freq[roll - 1] += 1\n        for i in range(k - 1, -1, -1):\n            if freq[i] > 0:\n                for j in range(i + 1, k):\n                    freq[j] -= freq[i]\n                return i + 1\n        return k + 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2349", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass NumberContainers:\n\n    def __init__(self):\n        self.index_dict = {}\n        self.number_dict = {}\n\n    def change(self, index: int, number: int) -> None:\n        if number not in self.number_dict:\n            self.number_dict[number] = []\n        self.number_dict[number].append(index)\n        self.index_dict[index] = number\n\n    def find(self, number: int) -> int:\n        if number not in self.number_dict or not self.number_dict[number]:\n            return -1\n        return min(self.number_dict[number])", "extracted_code": "\nclass NumberContainers:\n\n    def __init__(self):\n        self.index_dict = {}\n        self.number_dict = {}\n\n    def change(self, index: int, number: int) -> None:\n        if number not in self.number_dict:\n            self.number_dict[number] = []\n        self.number_dict[number].append(index)\n        self.index_dict[index] = number\n\n    def find(self, number: int) -> int:\n        if number not in self.number_dict or not self.number_dict[number]:\n            return -1\n        return min(self.number_dict[number])", "difficulty": 2.0}
{"task_id": "LeetCode/2344", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        nums.sort()\n        smallest = nums[0]\n        deletions = 0\n        for num in numsDivide:\n            if num % smallest != 0:\n                while num % smallest != 0:\n                    smallest += 1\n                    deletions += 1\n        if smallest > max(numsDivide):\n            return -1\n        return deletions\n```", "extracted_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        nums.sort()\n        smallest = nums[0]\n        deletions = 0\n        for num in numsDivide:\n            if num % smallest != 0:\n                while num % smallest != 0:\n                    smallest += 1\n                    deletions += 1\n        if smallest > max(numsDivide):\n            return -1\n        return deletions\n", "difficulty": 3.0}
{"task_id": "LeetCode/2343", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        result = []\n        for k, trim in queries:\n            trimmed = [num[-trim:] for num in nums]\n            trimmed_sorted = sorted(trimmed)\n            result.append(trimmed_sorted.index(trimmed[k-1]))\n        return result\n```\n\nThis function works by iterating over each query. For each query, it first creates a new list `trimmed` by trimming each number in `nums` to its rightmost `trim` digits. It then sorts this list of trimmed numbers and finds the index of the `k-th` smallest trimmed number in the sorted list. This index is then appended to the result list. The function finally returns the result list.", "extracted_code": "\nclass Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        result = []\n        for k, trim in queries:\n            trimmed = [num[-trim:] for num in nums]\n            trimmed_sorted = sorted(trimmed)\n            result.append(trimmed_sorted.index(trimmed[k-1]))\n        return result\n", "difficulty": 2.0}
{"task_id": "LeetCode/2342", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i, num in enumerate(nums):\n            digit_sum = sum(int(digit) for digit in str(num))\n            digit_sums[digit_sum].append(num)\n        max_sum = -1\n        for digit_sum, nums_list in digit_sums.items():\n            if len(nums_list) >= 2:\n                max_sum = max(max_sum, max(nums_list[i] + nums_list[j] for i in range(len(nums_list)) for j in range(i+1, len(nums_list))))\n        return max_sum\n```", "extracted_code": "\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i, num in enumerate(nums):\n            digit_sum = sum(int(digit) for digit in str(num))\n            digit_sums[digit_sum].append(num)\n        max_sum = -1\n        for digit_sum, nums_list in digit_sums.items():\n            if len(nums_list) >= 2:\n                max_sum = max(max_sum, max(nums_list[i] + nums_list[j] for i in range(len(nums_list)) for j in range(i+1, len(nums_list))))\n        return max_sum\n", "difficulty": 2.0}
{"task_id": "LeetCode/2556", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        visited = [[False]*n for _ in range(m)]\n        \n        def dfs(x, y):\n            if x == m-1 and y == n-1:\n                return True\n            visited[x][y] = True\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1:\n                    if dfs(nx, ny):\n                        return True\n            return False\n        \n        if not dfs(0, 0):\n            return False\n        \n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1 and not visited[x][y]:\n                    grid[x][y] = 0\n                    if dfs(0, 0):\n                        return True\n                    grid[x][y] = 1\n        return False\n```\n\nThis function uses depth-first search (DFS) to check if there is a path from `(0, 0)` to `(m - 1, n - 1)` in the original grid. If there is no such path, it returns `False`. If there is a path, it iterates over all cells in the grid and flips a cell if it is not visited in the previous DFS", "extracted_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        visited = [[False]*n for _ in range(m)]\n        \n        def dfs(x, y):\n            if x == m-1 and y == n-1:\n                return True\n            visited[x][y] = True\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1:\n                    if dfs(nx, ny):\n                        return True\n            return False\n        \n        if not dfs(0, 0):\n            return False\n        \n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1 and not visited[x][y]:\n                    grid[x][y] = 0\n                    if dfs(0, 0):\n                        return True\n                    grid[x][y] = 1\n        return False\n", "difficulty": 2.0}
{"task_id": "LeetCode/2555", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        n = len(prizePositions)\n        if k == 0:\n            return min(n, 2)\n        left, right = 0, k - 1\n        total = sum(prizePositions[i] for i in range(k))\n        max_prizes = total\n        while right < n - 1:\n            total = total - prizePositions[left] + prizePositions[right + 1]\n            max_prizes = max(max_prizes, total)\n            left += 1\n            right += 1\n        return max_prizes\n```\n\nThis function works by first initializing two pointers, `left` and `right`, to the start and end of the first segment. It then calculates the total prize values within these two segments. It iterates by moving both pointers one step to the right, subtracting the value of the prize at the left pointer and adding the value of the prize at the new right pointer. During each iteration, it updates the maximum total prize value. Finally, it returns the maximum total prize value.", "extracted_code": "\nclass Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        n = len(prizePositions)\n        if k == 0:\n            return min(n, 2)\n        left, right = 0, k - 1\n        total = sum(prizePositions[i] for i in range(k))\n        max_prizes = total\n        while right < n - 1:\n            total = total - prizePositions[left] + prizePositions[right + 1]\n            max_prizes = max(max_prizes, total)\n            left += 1\n            right += 1\n        return max_prizes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2554", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        dp = [0] * (maxSum + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if i not in banned:\n                for j in range(maxSum, i - 1, -1):\n                    dp[j] = max(dp[j], dp[j - i] + 1)\n        return dp[maxSum]\n```\n\nThis function uses dynamic programming to find the maximum number of integers that can be chosen. It first converts the banned list into a set for efficient lookups. Then, it initializes a dp array to keep track of the maximum number of integers that can be chosen with a sum less than or equal to j. The dp array is filled in a bottom-up manner, where for each integer i (not in the banned list), it updates the dp array by considering all sums that can be obtained by including i. The final answer is the value of dp[maxSum], which represents the maximum number of integers that can be chosen with a sum less than or equal to maxSum.", "extracted_code": "\nclass Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        banned = set(banned)\n        dp = [0] * (maxSum + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if i not in banned:\n                for j in range(maxSum, i - 1, -1):\n                    dp[j] = max(dp[j], dp[j - i] + 1)\n        return dp[maxSum]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2552", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        if nums[i] < nums[k] < nums[j] < nums[l]:\n                            count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2551", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        n = len(weights)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            dp[i][0] = dp[i - 1][0] + prefix_sum[i]\n            for j in range(1, n + 1):\n                dp[i][j] = min(dp[i - 1][j - 1] + prefix_sum[j] - prefix_sum[j - i],\n                               dp[i][j - 1] + prefix_sum[j] - prefix_sum[j - 1])\n\n        return max(dp[k]) - min(dp[k])\n```", "extracted_code": "\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        n = len(weights)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            dp[i][0] = dp[i - 1][0] + prefix_sum[i]\n            for j in range(1, n + 1):\n                dp[i][j] = min(dp[i - 1][j - 1] + prefix_sum[j] - prefix_sum[j - i],\n                               dp[i][j - 1] + prefix_sum[j] - prefix_sum[j - 1])\n\n        return max(dp[k]) - min(dp[k])\n", "difficulty": 3.0}
{"task_id": "LeetCode/2550", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        MOD = 10**9 + 7\n        # For a polygon with n vertices, there are n possible collisions\n        # Each collision can happen in n! / (n-2)! ways\n        # Since there are n-2 vertices left after a collision, we can recursively calculate the number of ways\n        # Therefore, the total number of ways is (n-2)! * (n-2)\n        # Since n can be very large, we use modulo arithmetic to avoid overflow\n        return (n-2) * (n-1) % MOD\n```", "extracted_code": "\nclass Solution:\n    def monkeyMove(self, n: int) -> int:\n        MOD = 10**9 + 7\n        # For a polygon with n vertices, there are n possible collisions\n        # Each collision can happen in n! / (n-2)! ways\n        # Since there are n-2 vertices left after a collision, we can recursively calculate the number of ways\n        # Therefore, the total number of ways is (n-2)! * (n-2)\n        # Since n can be very large, we use modulo arithmetic to avoid overflow\n        return (n-2) * (n-1) % MOD\n", "difficulty": 2.0}
{"task_id": "LeetCode/2547", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        counter = Counter(nums)\n        freq = sorted([(counter[i], i) for i in counter], reverse=True)\n        cost = [0] * n\n        stack = []\n\n        for i in range(n):\n            while stack and nums[i] != nums[stack[-1]]:\n                stack.pop()\n            cost[i] = k + (i - stack[-1]) if stack else k\n            stack.append(i)\n\n        dp = [0] * (n + 1)\n        dp[0] = cost[0]\n        for i in range(1, n):\n            dp[i] = min(dp[j] + cost[i] for j in range(i))\n\n        return dp[-1]\n```\n\nThis function first counts the frequency of each number in the input array `nums` and sorts them in descending order based on the frequency. Then it initializes a `cost` array to store the cost of each subarray ending at a certain index. The `stack` is used to keep track of the indices of the subarrays.\n\nNext, it initializes a dynamic programming array `dp` to store the minimum cost for splitting the array up to a certain index. The cost for splitting the array at index `i` is calculated as the minimum cost for splitting the array up to index `j` plus the cost of the subarray from index `j` to `i`.\n\nFinally,", "extracted_code": "\nfrom collections import Counter\nfrom typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        counter = Counter(nums)\n        freq = sorted([(counter[i], i) for i in counter], reverse=True)\n        cost = [0] * n\n        stack = []\n\n        for i in range(n):\n            while stack and nums[i] != nums[stack[-1]]:\n                stack.pop()\n            cost[i] = k + (i - stack[-1]) if stack else k\n            stack.append(i)\n\n        dp = [0] * (n + 1)\n        dp[0] = cost[0]\n        for i in range(1, n):\n            dp[i] = min(dp[j] + cost[i] for j in range(i))\n\n        return dp[-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2546", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        if len(s) != len(target):\n            return False\n        if s == target:\n            return True\n        freq_s = [0]*26\n        freq_t = [0]*26\n        for i in range(len(s)):\n            freq_s[ord(s[i])-ord('a')] += 1\n            freq_t[ord(target[i])-ord('a')] += 1\n        for i in range(26):\n            if freq_s[i] != freq_t[i]:\n                return False\n        return True\n```\n\nThis function checks if two strings can be made equal by performing the operations described. It first checks if the strings are already equal, then checks if their lengths are equal. If not, it returns False. Then it creates two frequency arrays for the characters in both strings. If the frequency arrays are not equal, it returns False. Otherwise, it returns True.", "extracted_code": "\nclass Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        if len(s) != len(target):\n            return False\n        if s == target:\n            return True\n        freq_s = [0]*26\n        freq_t = [0]*26\n        for i in range(len(s)):\n            freq_s[ord(s[i])-ord('a')] += 1\n            freq_t[ord(target[i])-ord('a')] += 1\n        for i in range(26):\n            if freq_s[i] != freq_t[i]:\n                return False\n        return True\n", "difficulty": 2.0}
{"task_id": "LeetCode/2545", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(score, key=lambda x: -x[k])\n```", "extracted_code": "\nclass Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(score, key=lambda x: -x[k])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2543", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        if targetX < targetY:\n            targetX, targetY = targetY, targetX\n        while targetY:\n            if targetX < targetY:\n                return False\n            targetX, targetY = targetX - targetY, targetX\n        return targetX == 1\n```\n\nThis function works by iteratively subtracting the smaller value from the larger one. If at any point the smaller value becomes zero and the larger value is not equal to 1, then it is impossible to reach the target point. If the larger value becomes 1, then it is possible to reach the target point.", "extracted_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        if targetX < targetY:\n            targetX, targetY = targetY, targetX\n        while targetY:\n            if targetX < targetY:\n                return False\n            targetX, targetY = targetX - targetY, targetX\n        return targetX == 1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2538", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            sub_tree_price_sum = price[node]\n            max_price_sum = price[node]\n            min_price_sum = price[node]\n            \n            for child in graph[node]:\n                if child == parent:\n                    continue\n                \n                child_max_price_sum, child_min_price_sum = dfs(child, node)\n                sub_tree_price_sum += child_max_price_sum\n                max_price_sum = max(max_price_sum, child_max_price_sum + price[node])\n                min_price_sum = min(min_price_sum, child_min_price_sum + price[node])\n            \n            return max_price_sum, min_price_sum\n        \n        max_cost = -np.inf\n        for node in range(n):\n            _, min_price_sum = dfs(node, -1)\n            max_cost = max(max_cost, min_price_sum)\n        \n        return max_cost\n```", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            sub_tree_price_sum = price[node]\n            max_price_sum = price[node]\n            min_price_sum = price[node]\n            \n            for child in graph[node]:\n                if child == parent:\n                    continue\n                \n                child_max_price_sum, child_min_price_sum = dfs(child, node)\n                sub_tree_price_sum += child_max_price_sum\n                max_price_sum = max(max_price_sum, child_max_price_sum + price[node])\n                min_price_sum = min(min_price_sum, child_min_price_sum + price[node])\n            \n            return max_price_sum, min_price_sum\n        \n        max_cost = -np.inf\n        for node in range(n):\n            _, min_price_sum = dfs(node, -1)\n            max_cost = max(max_cost, min_price_sum)\n        \n        return max_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2532", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Worker:\n    def __init__(self, efficiency, time):\n        self.efficiency = efficiency\n        self.time = time\n\n    def __lt__(self, other):\n        return self.efficiency < other.efficiency\n\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = []\n        for i in range(k):\n            left_to_right, pick_old, right_to_left, put_new = time[i]\n            efficiency = left_to_right + right_to_left\n            workers.append(Worker(efficiency, [left_to_right, pick_old, right_to_left, put_new]))\n\n        workers.sort()\n        time_elapsed = 0\n        while n > 0:\n            for worker in workers:\n                if worker.time[1] <= 0 and worker.time[3] <= 0:\n                    continue\n                if worker.time[0] <= time_elapsed:\n                    worker.time[1] -= 1\n                    if worker.time[1] == 0:\n                        worker.time[2] -= 1\n                        if worker.time[2] == 0:\n                            worker.time[3] -= 1\n                            if worker.time[3] == 0:\n                                n -= 1\n                time_elapsed += 1\n        return time_elapsed\n```", "extracted_code": "\nclass Worker:\n    def __init__(self, efficiency, time):\n        self.efficiency = efficiency\n        self.time = time\n\n    def __lt__(self, other):\n        return self.efficiency < other.efficiency\n\nclass Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        workers = []\n        for i in range(k):\n            left_to_right, pick_old, right_to_left, put_new = time[i]\n            efficiency = left_to_right + right_to_left\n            workers.append(Worker(efficiency, [left_to_right, pick_old, right_to_left, put_new]))\n\n        workers.sort()\n        time_elapsed = 0\n        while n > 0:\n            for worker in workers:\n                if worker.time[1] <= 0 and worker.time[3] <= 0:\n                    continue\n                if worker.time[0] <= time_elapsed:\n                    worker.time[1] -= 1\n                    if worker.time[1] == 0:\n                        worker.time[2] -= 1\n                        if worker.time[2] == 0:\n                            worker.time[3] -= 1\n                            if worker.time[3] == 0:\n                                n -= 1\n                time_elapsed += 1\n        return time_elapsed\n", "difficulty": 3.0}
{"task_id": "LeetCode/2531", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        word1_chars = set(word1)\n        word2_chars = set(word2)\n        return len(word1_chars) - len(word1) == len(word2_chars) - len(word2) == 1\n```\n\nThis function works by first converting each string into a set, which automatically removes duplicates. It then checks if the difference in lengths between the original strings and the sets is equal to 1. If it is, that means it's possible to get the number of distinct characters in both strings to be equal with exactly one move.", "extracted_code": "\nclass Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        word1_chars = set(word1)\n        word2_chars = set(word2)\n        return len(word1_chars) - len(word1) == len(word2_chars) - len(word2) == 1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2528", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n        max_power = 0\n        for i in range(n):\n            left = max(0, i - r)\n            right = min(n, i + r + 1)\n            total_power = prefix_sum[right] - prefix_sum[left]\n            max_power = max(max_power, total_power)\n\n        if k >= n:\n            return max_power\n\n        for i in range(n):\n            if stations[i] == 0:\n                stations[i] = 1\n                break\n\n        for _ in range(k):\n            max_power = max(max_power, max(stations))\n            for i in range(n):\n                if stations[i] > 0:\n                    stations[i] += 1\n                    break\n\n        return max_power\n```", "extracted_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        n = len(stations)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + stations[i]\n\n        max_power = 0\n        for i in range(n):\n            left = max(0, i - r)\n            right = min(n, i + r + 1)\n            total_power = prefix_sum[right] - prefix_sum[left]\n            max_power = max(max_power, total_power)\n\n        if k >= n:\n            return max_power\n\n        for i in range(n):\n            if stations[i] == 0:\n                stations[i] = 1\n                break\n\n        for _ in range(k):\n            max_power = max(max_power, max(stations))\n            for i in range(n):\n                if stations[i] > 0:\n                    stations[i] += 1\n                    break\n\n        return max_power\n", "difficulty": 3.0}
{"task_id": "LeetCode/2523", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right + 1) if is_prime(i)]\n        if len(primes) < 2:\n            return [-1, -1]\n        else:\n            min_diff = float('inf')\n            min_primes = None\n            for i in range(len(primes) - 1):\n                if primes[i + 1] - primes[i] < min_diff:\n                    min_diff = primes[i + 1] - primes[i]\n                    min_primes = [primes[i], primes[i + 1]]\n            return min_primes\n```", "extracted_code": "\nclass Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        primes = [i for i in range(left, right + 1) if is_prime(i)]\n        if len(primes) < 2:\n            return [-1, -1]\n        else:\n            min_diff = float('inf')\n            min_primes = None\n            for i in range(len(primes) - 1):\n                if primes[i + 1] - primes[i] < min_diff:\n                    min_diff = primes[i + 1] - primes[i]\n                    min_primes = [primes[i], primes[i + 1]]\n            return min_primes\n", "difficulty": 2.0}
{"task_id": "LeetCode/2521", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        product = 1\n        for num in nums:\n            product *= num\n        factors = set()\n        i = 2\n        while i * i <= product:\n            if product % i:\n                i += 1\n            else:\n                product //= i\n                factors.add(i)\n        if product > 1:\n            factors.add(product)\n        return len(factors)\n```", "extracted_code": "\nclass Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        product = 1\n        for num in nums:\n            product *= num\n        factors = set()\n        i = 2\n        while i * i <= product:\n            if product % i:\n                i += 1\n            else:\n                product //= i\n                factors.add(i)\n        if product > 1:\n            factors.add(product)\n        return len(factors)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2518", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        total_sum = sum(nums)\n        if total_sum < k:\n            return 0\n        dp = [[0]*(total_sum+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            num = nums[i-1]\n            for j in range(total_sum, num-1, -1):\n                for l in range(1, i+1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-num]) % mod\n        count = 0\n        for j in range(k, total_sum+1):\n            count = (count + dp[n][j]) % mod\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        total_sum = sum(nums)\n        if total_sum < k:\n            return 0\n        dp = [[0]*(total_sum+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            num = nums[i-1]\n            for j in range(total_sum, num-1, -1):\n                for l in range(1, i+1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-num]) % mod\n        count = 0\n        for j in range(k, total_sum+1):\n            count = (count + dp[n][j]) % mod\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2517", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        n = len(price)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = min(dp[j] + price[i - 1] - price[j] for j in range(i - 1))\n        return max(dp[i] for i in range(k, n + 1))\n```\n\nThis function first sorts the price array. Then it initializes a dp array to keep track of the minimum tastiness for each basket size from 1 to n. For each basket size i, it calculates the minimum tastiness by iterating over all possible previous basket sizes j and calculating the absolute difference of the prices of the i-th and j-th candies. Finally, it returns the maximum tastiness among all possible k-sized baskets.", "extracted_code": "\nclass Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        n = len(price)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = min(dp[j] + price[i - 1] - price[j] for j in range(i - 1))\n        return max(dp[i] for i in range(k, n + 1))\n", "difficulty": 2.0}
{"task_id": "LeetCode/2516", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        from collections import Counter\n        cnt = Counter(s)\n        left, right = 0, 0\n        while right < len(s):\n            cnt[s[right]] -= 1\n            while all(x >= k for x in cnt.values()):\n                cnt[s[left]] += 1\n                left += 1\n            right += 1\n        return right if all(x >= k for x in cnt.values()) else -1\n```\n\nThis function uses a sliding window approach to solve the problem. It first counts the occurrence of each character in the string `s` using `collections.Counter`. Then, it iterates over the string from left to right, subtracting the current character from the count and adding the next character to the count. If all counts are greater than or equal to `k`, it moves the left boundary of the window to the right. If it is not possible to satisfy the condition, it returns `-1`. The function returns the right boundary of the window as the minimum number of minutes needed.", "extracted_code": "\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        from collections import Counter\n        cnt = Counter(s)\n        left, right = 0, 0\n        while right < len(s):\n            cnt[s[right]] -= 1\n            while all(x >= k for x in cnt.values()):\n                cnt[s[left]] += 1\n                left += 1\n            right += 1\n        return right if all(x >= k for x in cnt.values()) else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2514", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from collections import Counter\n        from math import factorial\n\n        words = s.split(' ')\n        n = len(words)\n        mod = 10**9 + 7\n\n        # Compute the frequency of each character in the first word\n        first_word_counter = Counter(words[0])\n\n        # Compute the number of permutations of the first word\n        first_word_permutations = factorial(len(words[0]))\n        for letter in first_word_counter:\n            first_word_permutations //= factorial(first_word_counter[letter])\n\n        total_anagrams = first_word_permutations\n\n        # For each subsequent word, compute the number of permutations\n        # that are anagrams of the previous word\n        for i in range(1, n):\n            current_word_counter = Counter(words[i])\n            common_letters = first_word_counter & current_word_counter\n            anagrams_current_word = factorial(len(words[i]))\n            for letter in common_letters:\n                anagrams_current_word //= factorial(common_letters[letter])\n            total_anagrams = (total_anagrams + anagrams_current_word) % mod\n\n        return total_anagrams\n```\n\nThis function works by first computing the number of permutations of the first word. Then, for each subsequent word, it computes the number of permutations that are anagrams of the previous word. The total number of", "extracted_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        from collections import Counter\n        from math import factorial\n\n        words = s.split(' ')\n        n = len(words)\n        mod = 10**9 + 7\n\n        # Compute the frequency of each character in the first word\n        first_word_counter = Counter(words[0])\n\n        # Compute the number of permutations of the first word\n        first_word_permutations = factorial(len(words[0]))\n        for letter in first_word_counter:\n            first_word_permutations //= factorial(first_word_counter[letter])\n\n        total_anagrams = first_word_permutations\n\n        # For each subsequent word, compute the number of permutations\n        # that are anagrams of the previous word\n        for i in range(1, n):\n            current_word_counter = Counter(words[i])\n            common_letters = first_word_counter & current_word_counter\n            anagrams_current_word = factorial(len(words[i]))\n            for letter in common_letters:\n                anagrams_current_word //= factorial(common_letters[letter])\n            total_anagrams = (total_anagrams + anagrams_current_word) % mod\n\n        return total_anagrams\n", "difficulty": 3.0}
{"task_id": "LeetCode/2513", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        # Find the least common multiple (LCM) of divisor1 and divisor2\n        lcm = divisor1 * divisor2 // math.gcd(divisor1, divisor2)\n\n        # Calculate the maximum possible value for arr1 and arr2\n        max_val1 = (uniqueCnt1 * lcm) // divisor1\n        max_val2 = (uniqueCnt2 * lcm) // divisor2\n\n        # Return the minimum of the two maximum values\n        return min(max_val1, max_val2)\n```\n\nThis function works by first calculating the least common multiple (LCM) of `divisor1` and `divisor2`. The LCM is the smallest positive integer that is divisible by both `divisor1` and `divisor2`.\n\nNext, the function calculates the maximum possible value for `arr1` and `arr2` by multiplying the LCM by the number of unique integers required in each array and then dividing by the respective divisor. This is based on the observation that the maximum value in each array must be a multiple of the LCM, and the number of unique integers required in each array determines the smallest multiple that can be used.\n\nFinally, the function returns the minimum of the two maximum values, which is the minimum possible maximum integer that can be present in either array while satisfying all the conditions.", "extracted_code": "\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        # Find the least common multiple (LCM) of divisor1 and divisor2\n        lcm = divisor1 * divisor2 // math.gcd(divisor1, divisor2)\n\n        # Calculate the maximum possible value for arr1 and arr2\n        max_val1 = (uniqueCnt1 * lcm) // divisor1\n        max_val2 = (uniqueCnt2 * lcm) // divisor2\n\n        # Return the minimum of the two maximum values\n        return min(max_val1, max_val2)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2512", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        points = {}\n        for word in positive_feedback:\n            positive_feedback[word] = 3\n        for word in negative_feedback:\n            negative_feedback[word] = -1\n        for r, sid in zip(report, student_id):\n            score = 0\n            for word in r.split():\n                if word in positive_feedback:\n                    score += positive_feedback[word]\n                elif word in negative_feedback:\n                    score += negative_feedback[word]\n            if sid not in points or points[sid] < score:\n                points[sid] = score\n        top_k = sorted(points.items(), key=lambda x: (-x[1], x[0]))\n        return [sid for sid, score in top_k[:k]]\n```", "extracted_code": "\nclass Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        points = {}\n        for word in positive_feedback:\n            positive_feedback[word] = 3\n        for word in negative_feedback:\n            negative_feedback[word] = -1\n        for r, sid in zip(report, student_id):\n            score = 0\n            for word in r.split():\n                if word in positive_feedback:\n                    score += positive_feedback[word]\n                elif word in negative_feedback:\n                    score += negative_feedback[word]\n            if sid not in points or points[sid] < score:\n                points[sid] = score\n        top_k = sorted(points.items(), key=lambda x: (-x[1], x[0]))\n        return [sid for sid, score in top_k[:k]]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2509", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        parent = [i for i in range(2**n)]\n        depth = [0 for _ in range(2**n)]\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                if depth[root_x] < depth[root_y]:\n                    parent[root_x] = root_y\n                elif depth[root_x] > depth[root_y]:\n                    parent[root_y] = root_x\n                else:\n                    parent[root_y] = root_x\n                    depth[root_x] += 1\n        \n        for i in range(2**n - 1, 0, -1):\n            union(i, i//2)\n        \n        ans = []\n        for a, b in queries:\n            if find(a) == find(b):\n                ans.append(depth[find(a)] + depth[find(b)])\n            else:\n                union(a, b)\n                ans.append(depth[find(a)] + depth[find(b)] - 1)\n                parent[find(a)] = a\n                parent[find(b)] = b\n                depth[find(a)] = 0\n                depth[find(b", "extracted_code": "\nclass Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        parent = [i for i in range(2**n)]\n        depth = [0 for _ in range(2**n)]\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                if depth[root_x] < depth[root_y]:\n                    parent[root_x] = root_y\n                elif depth[root_x] > depth[root_y]:\n                    parent[root_y] = root_x\n                else:\n                    parent[root_y] = root_x\n                    depth[root_x] += 1\n        \n        for i in range(2**n - 1, 0, -1):\n            union(i, i//2)\n        \n        ans = []\n        for a, b in queries:\n            if find(a) == find(b):\n                ans.append(depth[find(a)] + depth[find(b)])\n            else:\n                union(a, b)\n                ans.append(depth[find(a)] + depth[find(b)] - 1)\n                parent[find(a)] = a\n                parent[find(b)] = b\n                depth[find(a)] = 0\n                depth[find(b", "difficulty": 3.0}
{"task_id": "LeetCode/2508", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for u, v in edges:\n            degree[u] += 1\n            degree[v] += 1\n        odd_count = sum(d % 2 for d in degree)\n        return odd_count <= 2\n```\n\nThis function works by first initializing an array `degree` to store the degree of each node. It then iterates over the `edges` list and increments the degree of each node that is connected by an edge. After that, it counts the number of odd degrees in the `degree` list and stores this count in `odd_count`. Finally, it checks if `odd_count` is less than or equal to 2. If it is, it returns `True`, indicating that it is possible to make the degree of each node even. Otherwise, it returns `False`.", "extracted_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        degree = [0] * (n + 1)\n        for u, v in edges:\n            degree[u] += 1\n            degree[v] += 1\n        odd_count = sum(d % 2 for d in degree)\n        return odd_count <= 2\n", "difficulty": 3.0}
{"task_id": "LeetCode/2507", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(n):\n            factors = []\n            i = 2\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            if n > 1:\n                factors.append(n)\n            return factors\n\n        factors = prime_factors(n)\n        while len(factors) > 1:\n            n = sum(factors)\n            factors = prime_factors(n)\n\n        return n\n```", "extracted_code": "\nclass Solution:\n    def smallestValue(self, n: int) -> int:\n        def prime_factors(n):\n            factors = []\n            i = 2\n            while i * i <= n:\n                if n % i:\n                    i += 1\n                else:\n                    n //= i\n                    factors.append(i)\n            if n > 1:\n                factors.append(n)\n            return factors\n\n        factors = prime_factors(n)\n        while len(factors) > 1:\n            n = sum(factors)\n            factors = prime_factors(n)\n\n        return n\n", "difficulty": 2.0}
{"task_id": "LeetCode/2503", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def dfs(x, y, q):\n            visited = [[0] * n for _ in range(m)]\n            stack = [(x, y, 1)]\n            points = 1\n            while stack:\n                i, j, p = stack.pop()\n                if p > points:\n                    points = p\n                for dx, dy in directions:\n                    ni, nj = i + dx, j + dy\n                    if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and grid[ni][nj] < q:\n                        visited[ni][nj] = 1\n                        stack.append((ni, nj, p + 1))\n            return points\n\n        return [dfs(i, j, q) for i in range(m) for j in range(n) for q in queries]\n```\n\nThis solution uses depth-first search (DFS) to explore all possible paths from the current cell to adjacent cells. The `dfs` function takes the current cell's coordinates and the query value as input and returns the maximum number of points that can be obtained. The `visited` matrix keeps track of the cells that have been visited during the current path. The `stack` is used to store the cells to be visited and their corresponding path lengths. The `points` variable keeps track of", "extracted_code": "\nclass Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def dfs(x, y, q):\n            visited = [[0] * n for _ in range(m)]\n            stack = [(x, y, 1)]\n            points = 1\n            while stack:\n                i, j, p = stack.pop()\n                if p > points:\n                    points = p\n                for dx, dy in directions:\n                    ni, nj = i + dx, j + dy\n                    if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and grid[ni][nj] < q:\n                        visited[ni][nj] = 1\n                        stack.append((ni, nj, p + 1))\n            return points\n\n        return [dfs(i, j, q) for i in range(m) for j in range(n) for q in queries]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2501", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return -1\n        max_len = 1\n        cur_len = 1\n        for i in range(1, n):\n            if nums[i] == nums[i-1] ** 2:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n                cur_len = 1\n        if cur_len > max_len:\n            max_len = cur_len\n        return max_len if max_len > 1 else -1\n```", "extracted_code": "\nclass Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return -1\n        max_len = 1\n        cur_len = 1\n        for i in range(1, n):\n            if nums[i] == nums[i-1] ** 2:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n                cur_len = 1\n        if cur_len > max_len:\n            max_len = cur_len\n        return max_len if max_len > 1 else -1\n", "difficulty": 2.0}
{"task_id": "LeetCode/2499", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_cost = sum(diff)\n        return total_cost\n```\n\nThis function works by calculating the absolute difference between the corresponding elements of `nums1` and `nums2`. The total cost is then the sum of these differences. This solution assumes that we can perform the operations in any order, which may not be the case in the original problem statement. However, the problem statement does not provide enough information to determine the correct order of operations.", "extracted_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        diff = [abs(nums1[i] - nums2[i]) for i in range(n)]\n        total_cost = sum(diff)\n        return total_cost\n", "difficulty": 3.0}
{"task_id": "LeetCode/2498", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [0] * n\n        dp[0] = stones[1] - stones[0]\n        for i in range(1, n - 1):\n            dp[i] = max(dp[i - 1], stones[i + 1] - stones[i])\n        return max(dp[-1], stones[-1] - stones[-2])\n```\n\nThis function works by iterating through the stones array and calculating the maximum jump length at each stone. The maximum jump length is either the maximum jump length at the previous stone or the distance between the current stone and the next stone. The function returns the maximum of the last maximum jump length and the distance between the last two stones, as the frog must return to the first stone after reaching the last stone.", "extracted_code": "\nclass Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [0] * n\n        dp[0] = stones[1] - stones[0]\n        for i in range(1, n - 1):\n            dp[i] = max(dp[i - 1], stones[i + 1] - stones[i])\n        return max(dp[-1], stones[-1] - stones[-2])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2497", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nimport heapq\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        graph = [[] for _ in range(len(vals))]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0] * len(vals)\n\n        def dfs(node, parent):\n            visited[node] = 1\n            neighbors = [x for x in graph[node] if x != parent]\n            heapq.heapify(neighbors)\n            total = vals[node]\n            while neighbors and len(neighbors) + visited.count(1) - 1 <= k:\n                neighbor = heapq.heappop(neighbors)\n                if not visited[neighbor]:\n                    total += dfs(neighbor, node)\n            return total\n\n        return max(dfs(i, -1) for i in range(len(vals)) if not visited[i])\n```\n\nThis solution uses depth-first search (DFS) to find the maximum star sum. It first constructs an adjacency list representation of the graph. Then, for each node, it performs a DFS to find the maximum sum of a star graph centered at that node, with at most `k` edges. The DFS explores all neighbors of the current node that have not been visited yet, and adds their values to the total sum. The maximum sum is then returned as the result.", "extracted_code": "\nimport heapq\n\nclass Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        graph = [[] for _ in range(len(vals))]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [0] * len(vals)\n\n        def dfs(node, parent):\n            visited[node] = 1\n            neighbors = [x for x in graph[node] if x != parent]\n            heapq.heapify(neighbors)\n            total = vals[node]\n            while neighbors and len(neighbors) + visited.count(1) - 1 <= k:\n                neighbor = heapq.heappop(neighbors)\n                if not visited[neighbor]:\n                    total += dfs(neighbor, node)\n            return total\n\n        return max(dfs(i, -1) for i in range(len(vals)) if not visited[i])\n", "difficulty": 2.0}
{"task_id": "LeetCode/2493", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = [0] * (n + 1)\n        groups = [0]\n        for i in range(1, n + 1):\n            if not visited[i]:\n                visited[i] = 1\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    for nei in graph[node]:\n                        if not visited[nei]:\n                            visited[nei] = 1\n                            stack.append(nei)\n                    else:\n                        groups.append(node)\n        \n        for i in range(1, len(groups)):\n            if abs(groups[i] - groups[i - 1]) != 1:\n                return -1\n        \n        return len(groups)\n```", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = [0] * (n + 1)\n        groups = [0]\n        for i in range(1, n + 1):\n            if not visited[i]:\n                visited[i] = 1\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    for nei in graph[node]:\n                        if not visited[nei]:\n                            visited[nei] = 1\n                            stack.append(nei)\n                    else:\n                        groups.append(node)\n        \n        for i in range(1, len(groups)):\n            if abs(groups[i] - groups[i - 1]) != 1:\n                return -1\n        \n        return len(groups)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2488", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        left, right = 0, 0\n\n        while right < n:\n            if nums[right] < k:\n                right += 1\n            else:\n                left = right\n                while right < n and nums[right] >= k:\n                    right += 1\n                count += (right - left) * (right - left - 1) // 2\n        return count\n```\n\nThis function works by maintaining two pointers, `left` and `right`, which define the current subarray. The `left` pointer is incremented whenever a number smaller than `k` is encountered, and the `right` pointer is incremented whenever a number greater than or equal to `k` is encountered. When the `right` pointer moves forward, it counts the number of subarrays that can be formed with the current `left` and `right` pointers. The count is incremented by the number of subarrays, which is calculated as `(right - left) * (right - left - 1) // 2`. The formula `(right - left) * (right - left - 1) // 2` is used to calculate the number of subarrays with `right - left` elements, where `right - left - 1` is the number of elements on the right of the `left` pointer. The `// 2` is used to calculate the number of subarrays, as each subarray can be formed by selecting two elements from the `right - left` elements.", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        left, right = 0, 0\n\n        while right < n:\n            if nums[right] < k:\n                right += 1\n            else:\n                left = right\n                while right < n and nums[right] >= k:\n                    right += 1\n                count += (right - left) * (right - left - 1) // 2\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2487", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        max_val = head.val\n        new_head = ListNode(max_val)\n        current = new_head\n        while head:\n            if head.val >= max_val:\n                max_val = head.val\n                current.next = ListNode(max_val)\n                current = current.next\n            head = head.next\n        current.next = None\n        return new_head.next\n```", "extracted_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        max_val = head.val\n        new_head = ListNode(max_val)\n        current = new_head\n        while head:\n            if head.val >= max_val:\n                max_val = head.val\n                current.next = ListNode(max_val)\n                current = current.next\n            head = head.next\n        current.next = None\n        return new_head.next\n", "difficulty": 2.0}
{"task_id": "LeetCode/2484", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        MOD = 10**9 + 7\n        alphabet_size = 10\n        str_length = len(s)\n        palindrome_count = 0\n\n        # Initialize a 2D array to store counts of characters\n        count = [[0]*alphabet_size for _ in range(str_length)]\n\n        # Fill the count array\n        for i in range(str_length):\n            for j in range(i+1, str_length+1):\n                count[i][int(s[j-1])] += 1\n\n        # Function to calculate palindrome count\n        def palindrome_count_util(start: int, end: int) -> int:\n            nonlocal palindrome_count\n            if start >= end:\n                return 0\n            temp = [0]*alphabet_size\n            for i in range(alphabet_size):\n                temp[i] = count[start][i]\n            for i in range(alphabet_size):\n                count[start][i] -= temp[i]\n            for i in range(start+1, end):\n                for j in range(alphabet_size):\n                    count[i][j] -= temp[j]\n            for i in range(alphabet_size):\n                palindrome_count = (palindrome_count + temp[i]*(temp[i]-1)//2) % MOD\n            palindrome_count_util(start+1, end)\n            for i in range(alphabet_size):\n", "extracted_code": "\nclass Solution:\n    def countPalindromes(self, s: str) -> int:\n        MOD = 10**9 + 7\n        alphabet_size = 10\n        str_length = len(s)\n        palindrome_count = 0\n\n        # Initialize a 2D array to store counts of characters\n        count = [[0]*alphabet_size for _ in range(str_length)]\n\n        # Fill the count array\n        for i in range(str_length):\n            for j in range(i+1, str_length+1):\n                count[i][int(s[j-1])] += 1\n\n        # Function to calculate palindrome count\n        def palindrome_count_util(start: int, end: int) -> int:\n            nonlocal palindrome_count\n            if start >= end:\n                return 0\n            temp = [0]*alphabet_size\n            for i in range(alphabet_size):\n                temp[i] = count[start][i]\n            for i in range(alphabet_size):\n                count[start][i] -= temp[i]\n            for i in range(start+1, end):\n                for j in range(alphabet_size):\n                    count[i][j] -= temp[j]\n            for i in range(alphabet_size):\n                palindrome_count = (palindrome_count + temp[i]*(temp[i]-1)//2) % MOD\n            palindrome_count_util(start+1, end)\n            for i in range(alphabet_size):\n", "difficulty": 3.0}
{"task_id": "LeetCode/2483", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        min_penalty = float('inf')\n        penalty = [0, 0]\n        close_time = 0\n        for i in range(n):\n            penalty[i%2] += (customers[i] == 'N')\n            if i >= 1:\n                penalty[i%2] -= (customers[i-1] == 'Y')\n            if i >= 2:\n                min_penalty = min(min_penalty, penalty[(i-1)%2])\n        for i in range(n-1, -1, -1):\n            if penalty[i%2] == min_penalty:\n                close_time = i\n                break\n        return close_time\n```\n\nThis function calculates the penalty for each hour and finds the minimum penalty. It then iterates backward from the hour with the minimum penalty to find the earliest hour at which the shop must be closed to incur a minimum penalty.", "extracted_code": "\nclass Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        min_penalty = float('inf')\n        penalty = [0, 0]\n        close_time = 0\n        for i in range(n):\n            penalty[i%2] += (customers[i] == 'N')\n            if i >= 1:\n                penalty[i%2] -= (customers[i-1] == 'Y')\n            if i >= 2:\n                min_penalty = min(min_penalty, penalty[(i-1)%2])\n        for i in range(n-1, -1, -1):\n            if penalty[i%2] == min_penalty:\n                close_time = i\n                break\n        return close_time\n", "difficulty": 2.0}
{"task_id": "LeetCode/2482", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ones_rows, ones_cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    ones_rows[i] += 1\n                    ones_cols[j] += 1\n        return [[ones_rows[i] + ones_cols[j] - (m-ones_rows[i]) - (n-ones_cols[j]) for j in range(n)] for i in range(m)]\n```", "extracted_code": "\nclass Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ones_rows, ones_cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    ones_rows[i] += 1\n                    ones_cols[j] += 1\n        return [[ones_rows[i] + ones_cols[j] - (m-ones_rows[i]) - (n-ones_cols[j]) for j in range(n)] for i in range(m)]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2481", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        return n - 1\n```", "extracted_code": "\nclass Solution:\n    def numberOfCuts(self, n: int) -> int:\n        return n - 1\n", "difficulty": 1.0}
{"task_id": "LeetCode/2478", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        primes = {'2', '3', '5', '7'}\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            dp[i] = dp[i - 1] * 2 % MOD\n            if s[i - 1] in primes:\n                dp[i] += dp[i - minLength]\n        return dp[len(s)]\n```\n\nThis function uses dynamic programming to solve the problem. The dp array stores the number of beautiful partitions of the first i characters of s. The base case is when there are no characters, in which case there is one beautiful partition (the empty partition). For each character, we double the number of beautiful partitions from the previous character. If the current character is a prime digit, we also add the number of beautiful partitions from i - minLength characters ago. This is because we can create a new partition that starts with the current prime digit and ends with the previous non-prime digit. Finally, we return the number of beautiful partitions of the entire string s.", "extracted_code": "\nclass Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        MOD = 10**9 + 7\n        primes = {'2', '3', '5', '7'}\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            dp[i] = dp[i - 1] * 2 % MOD\n            if s[i - 1] in primes:\n                dp[i] += dp[i - minLength]\n        return dp[len(s)]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2476", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def inorder(node, arr):\n            if node:\n                inorder(node.left, arr)\n                arr.append(node.val)\n                inorder(node.right, arr)\n\n        def find_closest(arr, target):\n            left, right = -1, -1\n            for val in arr:\n                if val <= target:\n                    left = max(left, val)\n                elif val >= target:\n                    right = min(right, val) if right != -1 else val\n            return [left, right]\n\n        tree_values = []\n        inorder(root, tree_values)\n        tree_values = sorted(tree_values)\n\n        return [find_closest(tree_values, q) for q in queries]\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        def inorder(node, arr):\n            if node:\n                inorder(node.left, arr)\n                arr.append(node.val)\n                inorder(node.right, arr)\n\n        def find_closest(arr, target):\n            left, right = -1, -1\n            for val in arr:\n                if val <= target:\n                    left = max(left, val)\n                elif val >= target:\n                    right = min(right, val) if right != -1 else val\n            return [left, right]\n\n        tree_values = []\n        inorder(root, tree_values)\n        tree_values = sorted(tree_values)\n\n        return [find_closest(tree_values, q) for q in queries]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2472", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        palindrome_count = 0\n        for i in range(k, n+1):\n            for j in range(n-i+1):\n                if s[j:j+i] == s[j:j+i][::-1]:\n                    palindrome_count += 1\n        return palindrome_count\n```\n\nThis function works by iterating over all possible substring lengths from `k` to `n` (the length of the string `s`). For each substring length, it iterates over all possible starting indices. If the substring at the current starting index and length is a palindrome, it increments the `palindrome_count`. Finally, it returns the `palindrome_count`.\n\nThe time complexity of this function is O(n^3), which is acceptable given the constraints of the problem (n <= 2000). The space complexity is O(1), as it only uses a constant amount of space to store the `palindrome_count` and the loop indices.", "extracted_code": "\nclass Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        palindrome_count = 0\n        for i in range(k, n+1):\n            for j in range(n-i+1):\n                if s[j:j+i] == s[j:j+i][::-1]:\n                    palindrome_count += 1\n        return palindrome_count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2471", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, depth):\n            if not node:\n                return []\n            res.append((node.val, depth))\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n\n        res = []\n        dfs(root, 0)\n        res.sort()\n        ans = 0\n        for i in range(1, len(res)):\n            if res[i][1] == res[i - 1][1]:\n                ans += 1\n        return ans\n```\n\nThis function works by first performing a depth-first search (DFS) on the tree to collect all the nodes along with their depths. The collected data is then sorted based on the depth and the value of the nodes. After sorting, the function iterates through the list and increments the counter whenever it encounters two nodes at the same level but in the wrong order. This counter is then returned as the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, depth):\n            if not node:\n                return []\n            res.append((node.val, depth))\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n\n        res = []\n        dfs(root, 0)\n        res.sort()\n        ans = 0\n        for i in range(1, len(res)):\n            if res[i][1] == res[i - 1][1]:\n                ans += 1\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2470", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        gcd = np.gcd\n        lcm = lambda a, b: a * b // gcd(a, b)\n        ans = 0\n        for i in range(n):\n            lcm_val = k\n            for j in range(i, n):\n                lcm_val = lcm(lcm_val, nums[j])\n                if lcm_val == k:\n                    ans += 1\n        return ans\n```\n\nThis function works by iterating over all possible subarrays of `nums` and calculating the least common multiple (LCM) of their elements. If the LCM equals `k`, we increment a counter (`ans`). The function finally returns this counter.\n\nThe LCM is calculated using a helper function that takes two numbers and calculates their LCM. The helper function uses the `gcd` function from the `numpy` library to calculate the greatest common divisor of the two numbers, which is then used to calculate the LCM.\n\nThe time complexity of this function is O(n^2), where n is the length of `nums`. This is because we need to iterate over all possible subarrays of `nums`, which requires two nested loops. The space complexity is O(1), as we only use a constant amount of space to store the current LCM and the final result.", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        gcd = np.gcd\n        lcm = lambda a, b: a * b // gcd(a, b)\n        ans = 0\n        for i in range(n):\n            lcm_val = k\n            for j in range(i, n):\n                lcm_val = lcm(lcm_val, nums[j])\n                if lcm_val == k:\n                    ans += 1\n        return ans\n", "difficulty": 2.0}
{"task_id": "LeetCode/2468", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        n = len(message)\n        parts = []\n        for i in range(0, n, limit):\n            part = message[i:i+limit]\n            if len(part) < limit:\n                part += ' ' * (limit - len(part))\n            parts.append(f\"{part[:-4]}<{i//limit + 1}/{n//limit + (i+limit>=n)}>\")\n        return parts if len(''.join(parts).strip()) == len(message) else []\n```\n\nThis function works by iterating over the message in chunks of size `limit`. For each chunk, it checks if its length is less than `limit`. If so, it appends spaces to the end of the chunk until its length is equal to `limit`. Then, it appends the chunk to the list `parts`.\n\nFinally, the function checks if the concatenation of all the parts (with whitespaces removed) has the same length as the original message. If it does, it returns `parts`. Otherwise, it returns an empty list.", "extracted_code": "\nclass Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        n = len(message)\n        parts = []\n        for i in range(0, n, limit):\n            part = message[i:i+limit]\n            if len(part) < limit:\n                part += ' ' * (limit - len(part))\n            parts.append(f\"{part[:-4]}<{i//limit + 1}/{n//limit + (i+limit>=n)}>\")\n        return parts if len(''.join(parts).strip()) == len(message) else []\n", "difficulty": 3.0}
{"task_id": "LeetCode/2466", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (one + 1) for _ in range(low + 1)]\n        dp[0][0] = 1\n        for i in range(1, low + 1):\n            for j in range(min(i, zero) + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                if j < one:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD\n        return sum(dp[i][zero] for i in range(low, high + 1)) % MOD\n```\n\nThis function uses dynamic programming to calculate the number of good strings. The `dp` array stores the number of good strings of length `i` with `j` zeros. The base case is `dp[0][0] = 1`, representing the empty string. For each length from 1 to `low`, we calculate the number of good strings with 0 to `zero` zeros. We add the number of good strings of the previous length with the same number of zeros and the number of good strings of the previous length with one more zero. For each length from 1 to `low`, we calculate the number of good strings with 0 to `one` ones. We add the number of good strings of the previous length with the same number of ones and the number of good strings of the previous length", "extracted_code": "\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (one + 1) for _ in range(low + 1)]\n        dp[0][0] = 1\n        for i in range(1, low + 1):\n            for j in range(min(i, zero) + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                if j < one:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD\n        return sum(dp[i][zero] for i in range(low, high + 1)) % MOD\n", "difficulty": 2.0}
{"task_id": "LeetCode/2463", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        factories = sorted((pos, -lim, lim) for pos, lim in factory)\n        robots = sorted(robot)\n        res, i = 0, 0\n        for r in robots:\n            while i < len(factories) and factories[i][1] < r:\n                _, pos, lim = factories[i]\n                if lim > 0:\n                    res += abs(pos - r)\n                    factories[i] = (pos, -lim + 1, lim)\n                else:\n                    i += 1\n            if i < len(factories):\n                _, pos, _ = factories[i]\n                res += abs(pos - r)\n        return res\n```", "extracted_code": "\nclass Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        factories = sorted((pos, -lim, lim) for pos, lim in factory)\n        robots = sorted(robot)\n        res, i = 0, 0\n        for r in robots:\n            while i < len(factories) and factories[i][1] < r:\n                _, pos, lim = factories[i]\n                if lim > 0:\n                    res += abs(pos - r)\n                    factories[i] = (pos, -lim + 1, lim)\n                else:\n                    i += 1\n            if i < len(factories):\n                _, pos, _ = factories[i]\n                res += abs(pos - r)\n        return res\n", "difficulty": 3.0}
{"task_id": "LeetCode/2462", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        sorted_costs = sorted([(costs[i], i) for i in range(n)])\n        total_cost = 0\n        for i in range(k):\n            if i < candidates:\n                total_cost += sorted_costs[i][0]\n            else:\n                total_cost += sorted_costs[n - k + i][0]\n        return total_cost\n```", "extracted_code": "\nclass Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        sorted_costs = sorted([(costs[i], i) for i in range(n)])\n        total_cost = 0\n        for i in range(k):\n            if i < candidates:\n                total_cost += sorted_costs[i][0]\n            else:\n                total_cost += sorted_costs[n - k + i][0]\n        return total_cost\n", "difficulty": 2.0}
{"task_id": "LeetCode/2461", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n < k:\n            return 0\n        \n        max_sum = float('-inf')\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        \n        return max_sum if max_sum != float('-inf') else 0\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n < k:\n            return 0\n        \n        max_sum = float('-inf')\n        for i in range(n - k + 1):\n            subarray = nums[i:i + k]\n            if len(set(subarray)) == k:\n                max_sum = max(max_sum, sum(subarray))\n        \n        return max_sum if max_sum != float('-inf') else 0\n", "difficulty": 2.0}
{"task_id": "LeetCode/2338", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*(maxValue+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, maxValue+1):\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % mod\n                if j <= i:\n                    dp[i][j] += dp[i-1][j-1]\n                    dp[i][j] %= mod\n        return sum(dp[-1]) % mod\n```", "extracted_code": "\nclass Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0]*(maxValue+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, maxValue+1):\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % mod\n                if j <= i:\n                    dp[i][j] += dp[i-1][j-1]\n                    dp[i][j] %= mod\n        return sum(dp[-1]) % mod\n", "difficulty": 3.0}
{"task_id": "LeetCode/2334", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        prefix_sum = 0\n        j = 0\n        for i in range(n):\n            prefix_sum += nums[i]\n            while prefix_sum > threshold:\n                min_sum = min(min_sum, i + 1 - j)\n                prefix_sum -= nums[j]\n                j += 1\n        return min_sum if min_sum != float('inf') else -1\n```", "extracted_code": "\nclass Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        prefix_sum = 0\n        j = 0\n        for i in range(n):\n            prefix_sum += nums[i]\n            while prefix_sum > threshold:\n                min_sum = min(min_sum, i + 1 - j)\n                prefix_sum -= nums[j]\n                j += 1\n        return min_sum if min_sum != float('inf') else -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2333", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        n = len(nums1)\n        diffs = [(a - b) ** 2 for a, b in zip(nums1, nums2)]\n        diffs.sort()\n\n        total = sum(diffs)\n        for i in range(min(k1, k2)):\n            total -= 2 * diffs[i]\n\n        return total\n```", "extracted_code": "\nclass Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        n = len(nums1)\n        diffs = [(a - b) ** 2 for a, b in zip(nums1, nums2)]\n        diffs.sort()\n\n        total = sum(diffs)\n        for i in range(min(k1, k2)):\n            total -= 2 * diffs[i]\n\n        return total\n", "difficulty": 2.0}
{"task_id": "LeetCode/2328", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD\n        return dp[-1][-1]\n```\n\nThis function uses dynamic programming to solve the problem. It initializes a 2D dp array with the same dimensions as the input grid, and sets the initial value at dp[0][0] to 1. Then, for each cell in the grid, it adds the number of paths to reach that cell from the cell above it and the cell to its left, if they exist. The result is the value at the last cell in the dp array, which represents the total number of strictly increasing paths in the grid. The result is computed modulo 10^9 + 7 to prevent integer overflow.", "extracted_code": "\nclass Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD\n        return dp[-1][-1]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2325", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        key_order = {ch: i for i, ch in enumerate(key) if ch not in key_order}\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        table = {alphabet[i]: alphabet[(i - key_order[ch]) % 26] for ch, i in key_order.items()}\n        return ''.join(table[ch] if ch in table else ch for ch in message)\n```", "extracted_code": "\nclass Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        key_order = {ch: i for i, ch in enumerate(key) if ch not in key_order}\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        table = {alphabet[i]: alphabet[(i - key_order[ch]) % 26] for ch, i in key_order.items()}\n        return ''.join(table[ch] if ch in table else ch for ch in message)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2322", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node, parent):\n            xor = nums[node]\n            for child in graph[node]:\n                if child != parent:\n                    xor ^= dfs(child, node)\n            return xor\n\n        min_score = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                score = dfs(i, -1) ^ dfs(j, -1)\n                min_score = min(min_score, score)\n\n        return min_score\n```\n\nThis solution first builds an adjacency list representation of the tree. Then, it defines a depth-first search (DFS) function that computes the XOR of all nodes in a subtree rooted at a given node. The DFS function is then used to find all possible pairs of edges to remove, and the minimum score is computed by taking the difference between the largest and smallest XOR values of the three resulting subtrees.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node, parent):\n            xor = nums[node]\n            for child in graph[node]:\n                if child != parent:\n                    xor ^= dfs(child, node)\n            return xor\n\n        min_score = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                score = dfs(i, -1) ^ dfs(j, -1)\n                min_score = min(min_score, score)\n\n        return min_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2320", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 2\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] * (i - 1)) % MOD\n        return dp[n] * 2 - dp[n - 1]\n```\n\nThis function uses dynamic programming to calculate the number of ways to place houses. The dp array stores the number of ways to place houses for each number of plots. The base cases are dp[0] = 1 (no plots, so only one arrangement) and dp[1] = 2 (one plot, so two arrangements - house on this side or house on the other side). For each plot from 2 to n, the number of ways to place a house is the sum of the number of ways to place a house for the previous plot (i.e., dp[i - 1]) and the product of the number of ways to place a house for the previous plot and the number of plots on the other side of the street (i.e., dp[i - 2] * (i - 1)). The result is then taken modulo MOD to prevent overflow.\n\nFinally, the total number of ways to place houses is doubled (since there are n plots on each side of the street), but we subtract the number of ways to place houses for n - 1 plots to account for the case", "extracted_code": "\nclass Solution:\n    def countHousePlacements(self, n: int) -> int:\n        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 2\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] * (i - 1)) % MOD\n        return dp[n] * 2 - dp[n - 1]\n", "difficulty": 2.0}
{"task_id": "LeetCode/2318", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        mod = 10**9 + 7\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            dp[i] = (dp[i-1]*6)%mod\n            if i>=2:\n                dp[i] = (dp[i] - dp[i-2]*5)%mod\n            if i>=3:\n                dp[i] = (dp[i] + dp[i-3]*5)%mod\n            if i>=4:\n                dp[i] = (dp[i] - dp[i-4]*4)%mod\n        return dp[n]\n```\n\nThis function uses dynamic programming to calculate the number of distinct sequences. The dp array stores the number of distinct sequences of length i. The base case is dp[0] = 1, representing the empty sequence.\n\nFor each i from 1 to n, we calculate dp[i] as 6 times dp[i-1], because we can append any number from 1 to 6 to the end of a sequence of length i-1.\n\nThen we subtract dp[i-2]*5 from dp[i], because we have overcounted the sequences that end with two equal numbers.\n\nNext, we add dp[i-3]*5 to dp[i], because we have undercounted the sequences that end with two different numbers and a pair.\n\nAfter that, we subtract dp[i-4]*4 from d", "extracted_code": "\nclass Solution:\n    def distinctSequences(self, n: int) -> int:\n        mod = 10**9 + 7\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            dp[i] = (dp[i-1]*6)%mod\n            if i>=2:\n                dp[i] = (dp[i] - dp[i-2]*5)%mod\n            if i>=3:\n                dp[i] = (dp[i] + dp[i-3]*5)%mod\n            if i>=4:\n                dp[i] = (dp[i] - dp[i-4]*4)%mod\n        return dp[n]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2317", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        nums = [num & 0xFFFF for num in nums]\n        trie = {}\n        for num in nums:\n            node = trie\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if curr_bit not in node:\n                    node[curr_bit] = {}\n                node = node[curr_bit]\n                if 1 - curr_bit not in node:\n                    node[1 - curr_bit] = {}\n        best = 0\n        for num in nums:\n            node = trie\n            curr_max = 0\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if 1 - curr_bit in node:\n                    curr_max |= (1 << bit)\n                    node = node[1 - curr_bit]\n                else:\n                    node = node[curr_bit]\n            best = max(best, curr_max)\n        return best\n```", "extracted_code": "\nclass Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        nums = [num & 0xFFFF for num in nums]\n        trie = {}\n        for num in nums:\n            node = trie\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if curr_bit not in node:\n                    node[curr_bit] = {}\n                node = node[curr_bit]\n                if 1 - curr_bit not in node:\n                    node[1 - curr_bit] = {}\n        best = 0\n        for num in nums:\n            node = trie\n            curr_max = 0\n            for bit in range(15, -1, -1):\n                curr_bit = (num >> bit) & 1\n                if 1 - curr_bit in node:\n                    curr_max |= (1 << bit)\n                    node = node[1 - curr_bit]\n                else:\n                    node = node[curr_bit]\n            best = max(best, curr_max)\n        return best\n", "difficulty": 2.0}
{"task_id": "LeetCode/2306", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        valid_names = set()\n        for i in range(n):\n            for j in range(i+1, n):\n                name_A, name_B = ideas[i], ideas[j]\n                new_name_A, new_name_B = name_A[0] + name_B[1:], name_B[0] + name_A[1:]\n                if new_name_A not in ideas and new_name_B not in ideas:\n                    valid_names.add(new_name_A + ' ' + new_name_B)\n        return len(valid_names)\n```\n\nThis function works by iterating over all pairs of distinct names in the input list. For each pair, it swaps the first letters of the two names and checks if the new names are not present in the original list. If they are not, it adds the concatenated string of the new names to a set. The function finally returns the size of this set, which represents the number of distinct valid company names.", "extracted_code": "\nclass Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        valid_names = set()\n        for i in range(n):\n            for j in range(i+1, n):\n                name_A, name_B = ideas[i], ideas[j]\n                new_name_A, new_name_B = name_A[0] + name_B[1:], name_B[0] + name_A[1:]\n                if new_name_A not in ideas and new_name_B not in ideas:\n                    valid_names.add(new_name_A + ' ' + new_name_B)\n        return len(valid_names)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2302", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                score = (prefix_sum[j] - prefix_sum[i]) * (j - i)\n                if score < k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                score = (prefix_sum[j] - prefix_sum[i]) * (j - i)\n                if score < k:\n                    count += 1\n        return count\n", "difficulty": 3.0}
{"task_id": "LeetCode/2301", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        mapping_dict = {old: new for old, new in mappings}\n        sub_new = ''.join(mapping_dict.get(c, c) for c in sub)\n        return sub_new in s\n```", "extracted_code": "\nclass Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        mapping_dict = {old: new for old, new in mappings}\n        sub_new = ''.join(mapping_dict.get(c, c) for c in sub)\n        return sub_new in s\n", "difficulty": 3.0}
{"task_id": "LeetCode/2296", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass TextEditor:\n    def __init__(self):\n        self.text = ''\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        count = min(k, self.cursor)\n        self.text = self.text[:self.cursor - count] + self.text[self.cursor:]\n        self.cursor -= count\n        return count\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor = max(0, self.cursor - k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor = min(len(self.text), self.cursor + k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n```", "extracted_code": "\nclass TextEditor:\n    def __init__(self):\n        self.text = ''\n        self.cursor = 0\n\n    def addText(self, text: str) -> None:\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self, k: int) -> int:\n        count = min(k, self.cursor)\n        self.text = self.text[:self.cursor - count] + self.text[self.cursor:]\n        self.cursor -= count\n        return count\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor = max(0, self.cursor - k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n\n    def cursorRight(self, k: int) -> str:\n        self.cursor = min(len(self.text), self.cursor + k)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2294", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        j = 0\n        count = 1\n        for i in range(1, n):\n            if nums[i] - nums[j] > k:\n                j = i\n                count += 1\n        return count\n```\n\nThis function first sorts the input array. Then it iterates through the sorted array, and for each element, it checks if the difference between the current element and the first element in the current subsequence (nums[j]) is greater than k. If it is, it starts a new subsequence by updating j to the current index and increments the count of subsequences. The count of subsequences is incremented because each element in the input array appears in exactly one subsequence. The function returns the count of subsequences as the result.", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        j = 0\n        count = 1\n        for i in range(1, n):\n            if nums[i] - nums[j] > k:\n                j = i\n                count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2290", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        while heap:\n            cost, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                return cost\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    heapq.heappush(heap, (cost + grid[nx][ny], nx, ny))\n        return -1\n```\n\nThis solution uses a priority queue to find the minimum cost path from the top-left corner to the bottom-right corner. The priority queue is implemented using Python's built-in heapq library. The cost of a path is determined by the sum of the values of the cells in the path. The algorithm iteratively expands the path with the minimum cost, and stops when it reaches the bottom-right corner. If there is no path from the top-left corner to the bottom-right corner, the function returns -1.", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0]*n for _ in range(m)]\n        heap = [(grid[0][0], 0, 0)]\n        visited[0][0] = 1\n        while heap:\n            cost, x, y = heapq.heappop(heap)\n            if x == m-1 and y == n-1:\n                return cost\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    heapq.heappush(heap, (cost + grid[nx][ny], nx, ny))\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2286", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        self.n = n\n        self.m = m\n        self.rows = [[-1]*m for _ in range(n)]\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for r in range(min(maxRow+1, self.n)):\n            for c in range(self.m-k+1):\n                if all(self.rows[r][c+i] == -1 for i in range(k)):\n                    for i in range(k):\n                        self.rows[r][c+i] = 1\n                    return [r, c]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        for r in range(min(maxRow+1, self.n)):\n            cnt, c = 0, 0\n            while cnt < k and c < self.m:\n                if self.rows[r][c] == -1:\n                    cnt += 1\n                else:\n                    cnt, c = 0, c+1\n            if cnt == k:\n                for i in range(c-cnt, c):\n                    self.rows[r][i] = 1\n                return True\n        return False\n```", "extracted_code": "\nclass BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        self.n = n\n        self.m = m\n        self.rows = [[-1]*m for _ in range(n)]\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        for r in range(min(maxRow+1, self.n)):\n            for c in range(self.m-k+1):\n                if all(self.rows[r][c+i] == -1 for i in range(k)):\n                    for i in range(k):\n                        self.rows[r][c+i] = 1\n                    return [r, c]\n        return []\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        for r in range(min(maxRow+1, self.n)):\n            cnt, c = 0, 0\n            while cnt < k and c < self.m:\n                if self.rows[r][c] == -1:\n                    cnt += 1\n                else:\n                    cnt, c = 0, c+1\n            if cnt == k:\n                for i in range(c-cnt, c):\n                    self.rows[r][i] = 1\n                return True\n        return False\n", "difficulty": 3.0}
{"task_id": "LeetCode/2284", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_counts = {}\n        for sender, message in zip(senders, messages):\n            word_counts[sender] = word_counts.get(sender, 0) + len(message.split())\n        max_count = max(word_counts.values())\n        max_senders = [sender for sender, count in word_counts.items() if count == max_count]\n        return min(max_senders)\n```", "extracted_code": "\nclass Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        word_counts = {}\n        for sender, message in zip(senders, messages):\n            word_counts[sender] = word_counts.get(sender, 0) + len(message.split())\n        max_count = max(word_counts.values())\n        max_senders = [sender for sender, count in word_counts.items() if count == max_count]\n        return min(max_senders)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2281", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(strength)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + strength[i]\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                min_val = min(strength[i:j])\n                total_strength = min_val * (prefix_sum[j] - prefix_sum[i])\n                ans = (ans + total_strength) % MOD\n        return ans\n```", "extracted_code": "\nclass Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(strength)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + strength[i]\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                min_val = min(strength[i:j])\n                total_strength = min_val * (prefix_sum[j] - prefix_sum[i])\n                ans = (ans + total_strength) % MOD\n        return ans\n", "difficulty": 3.0}
{"task_id": "LeetCode/2279", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        n = len(capacity)\n        remaining_capacity = [capacity[i] - rocks[i] for i in range(n)]\n        remaining_capacity.sort(reverse=True)\n        count = 0\n        for i in range(n):\n            if additionalRocks >= remaining_capacity[i]:\n                additionalRocks -= remaining_capacity[i]\n                count += 1\n            else:\n                break\n        if additionalRocks > 0:\n            count += additionalRocks // capacity[remaining_capacity.index(max(remaining_capacity))]\n        return count\n```", "extracted_code": "\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        n = len(capacity)\n        remaining_capacity = [capacity[i] - rocks[i] for i in range(n)]\n        remaining_capacity.sort(reverse=True)\n        count = 0\n        for i in range(n):\n            if additionalRocks >= remaining_capacity[i]:\n                additionalRocks -= remaining_capacity[i]\n                count += 1\n            else:\n                break\n        if additionalRocks > 0:\n            count += additionalRocks // capacity[remaining_capacity.index(max(remaining_capacity))]\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2276", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        self.intervals.sort()\n        count = 0\n        i = 0\n        while i < len(self.intervals):\n            start, end = self.intervals[i]\n            count += end - start + 1\n            while i + 1 < len(self.intervals) and self.intervals[i + 1][0] <= end:\n                i += 1\n                start, end = self.intervals[i]\n                count += end - start + 1\n            i += 1\n        return count", "extracted_code": "\nclass CountIntervals:\n\n    def __init__(self):\n        self.intervals = []\n\n    def add(self, left: int, right: int) -> None:\n        self.intervals.append((left, right))\n\n    def count(self) -> int:\n        self.intervals.sort()\n        count = 0\n        i = 0\n        while i < len(self.intervals):\n            start, end = self.intervals[i]\n            count += end - start + 1\n            while i + 1 < len(self.intervals) and self.intervals[i + 1][0] <= end:\n                i += 1\n                start, end = self.intervals[i]\n                count += end - start + 1\n            i += 1\n        return count", "difficulty": 3.0}
{"task_id": "LeetCode/2275", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        bit_counts = [bin(x).count('1') for x in candidates]\n        max_count = max(bit_counts)\n        return sum(x == max_count for x in bit_counts)\n```\n\nThis function works by first converting each number in the candidates list to its binary representation and counting the number of 1's (bits) in each representation. It then finds the maximum count of bits, which represents the largest possible bitwise AND. Finally, it counts the number of elements in the candidates list that have this maximum count of bits, which represents the size of the largest combination.\n\nThe time complexity of this function is O(n), where n is the number of elements in the candidates list, because it needs to iterate over each element once to calculate the binary representation and count the bits. The space complexity is also O(n), because it needs to store the bit counts for each element.", "extracted_code": "\nclass Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        bit_counts = [bin(x).count('1') for x in candidates]\n        max_count = max(bit_counts)\n        return sum(x == max_count for x in bit_counts)\n", "difficulty": 2.0}
{"task_id": "LeetCode/2272", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        from collections import Counter\n        n = len(s)\n        cnt = Counter(s)\n        vals = list(cnt.values())\n        max_val = max(vals)\n        min_val = min(vals)\n        if max_val == min_val:\n            return 0\n        else:\n            return max_val - min_val\n```", "extracted_code": "\nclass Solution:\n    def largestVariance(self, s: str) -> int:\n        from collections import Counter\n        n = len(s)\n        cnt = Counter(s)\n        vals = list(cnt.values())\n        max_val = max(vals)\n        min_val = min(vals)\n        if max_val == min_val:\n            return 0\n        else:\n            return max_val - min_val\n", "difficulty": 3.0}
{"task_id": "LeetCode/2271", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort(key=lambda x: x[0])\n        max_covered = 0\n        left, right = 0, 0\n        while right < len(tiles):\n            if tiles[right][0] - carpetLen < tiles[left][1]:\n                max_covered = max(max_covered, tiles[right][1] - tiles[left][0] + 1)\n                right += 1\n            else:\n                left += 1\n        return max_covered\n```\n\nThis function works by first sorting the tiles by their leftmost position. Then, it iterates through the tiles and tries to place the carpet at the rightmost possible position such that it still covers the leftmost tile. If the carpet can be placed further to the right, it does so and updates the maximum number of covered white tiles. If the carpet cannot be placed further to the right, it moves to the next tile from the left and repeats the process. The function returns the maximum number of white tiles that can be covered by the carpet.", "extracted_code": "\nclass Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort(key=lambda x: x[0])\n        max_covered = 0\n        left, right = 0, 0\n        while right < len(tiles):\n            if tiles[right][0] - carpetLen < tiles[left][1]:\n                max_covered = max(max_covered, tiles[right][1] - tiles[left][0] + 1)\n                right += 1\n            else:\n                left += 1\n        return max_covered\n", "difficulty": 2.0}
{"task_id": "LeetCode/2270", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            if prefix_sum[i] >= prefix_sum[n] - prefix_sum[i + 1]:\n                count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        count = 0\n        for i in range(n):\n            if prefix_sum[i] >= prefix_sum[n] - prefix_sum[i + 1]:\n                count += 1\n        return count\n", "difficulty": 2.0}
{"task_id": "LeetCode/2269", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        num_str = str(num)\n        n = len(num_str)\n        beauty = 0\n        for i in range(n - k + 1):\n            sub = int(num_str[i:i+k])\n            if num % sub == 0:\n                beauty += 1\n        return beauty\n```", "extracted_code": "\nclass Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        num_str = str(num)\n        n = len(num_str)\n        beauty = 0\n        for i in range(n - k + 1):\n            sub = int(num_str[i:i+k])\n            if num % sub == 0:\n                beauty += 1\n        return beauty\n", "difficulty": 1.0}
{"task_id": "LeetCode/2267", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 if grid[0][0] == '(' else -1\n\n        for i in range(1, m):\n            if grid[i][0] == '(':\n                dp[i][0] = dp[i-1][0] + 1\n            elif grid[i][0] == ')':\n                dp[i][0] = dp[i-1][0] - 1\n            if dp[i][0] < 0:\n                return False\n\n        for j in range(1, n):\n            if grid[0][j] == '(':\n                dp[0][j] = dp[0][j-1] + 1\n            elif grid[0][j] == ')':\n                dp[0][j] = dp[0][j-1] - 1\n            if dp[0][j] < 0:\n                return False\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] == '(':\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n                elif grid[i][j] == ')':\n                    dp[i][j] = min(dp[i-1][j],", "extracted_code": "\nclass Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 if grid[0][0] == '(' else -1\n\n        for i in range(1, m):\n            if grid[i][0] == '(':\n                dp[i][0] = dp[i-1][0] + 1\n            elif grid[i][0] == ')':\n                dp[i][0] = dp[i-1][0] - 1\n            if dp[i][0] < 0:\n                return False\n\n        for j in range(1, n):\n            if grid[0][j] == '(':\n                dp[0][j] = dp[0][j-1] + 1\n            elif grid[0][j] == ')':\n                dp[0][j] = dp[0][j-1] - 1\n            if dp[0][j] < 0:\n                return False\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] == '(':\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n                elif grid[i][j] == ')':\n                    dp[i][j] = min(dp[i-1][j],", "difficulty": 3.0}
{"task_id": "LeetCode/2262", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        n = len(s)\n        total_appeal = 0\n        for i in range(n):\n            appeal = set()\n            for j in range(i, n):\n                appeal.add(s[j])\n                total_appeal += len(appeal)\n        return total_appeal\n```", "extracted_code": "\nclass Solution:\n    def appealSum(self, s: str) -> int:\n        n = len(s)\n        total_appeal = 0\n        for i in range(n):\n            appeal = set()\n            for j in range(i, n):\n                appeal.add(s[j])\n                total_appeal += len(appeal)\n        return total_appeal\n", "difficulty": 3.0}
{"task_id": "LeetCode/2259", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        index = number.find(digit)\n        if index == 0:\n            while number[index] == digit:\n                index += 1\n            return number[:index] + number[index+1:]\n        else:\n            while number[index-1] == digit:\n                index -= 1\n            return number[:index] + number[index+1:]\n```", "extracted_code": "\nclass Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        index = number.find(digit)\n        if index == 0:\n            while number[index] == digit:\n                index += 1\n            return number[:index] + number[index+1:]\n        else:\n            while number[index-1] == digit:\n                index -= 1\n            return number[:index] + number[index+1:]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2258", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        fire_cells = [(grid[i][j], i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n        heapq.heapify(fire_cells)\n        visited = [[0]*n for _ in range(m)]\n        visited[0][0] = 1\n        min_minutes = 0\n\n        while fire_cells:\n            fire, i, j = heapq.heappop(fire_cells)\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = 1\n                    if (x, y) == (m-1, n-1):\n                        return min_minutes + 1\n                    heapq.heappush(fire_cells, (fire+1, x, y))\n            min_minutes += 1\n\n        return -1\n```\n\nThis solution uses a priority queue to keep track of the cells that are on fire. The priority queue is ordered by the time it takes for the fire to reach a cell. The algorithm iterates over the grid and for each cell that is on fire, it checks its adjacent cells. If an adjacent cell is not visited, it is", "extracted_code": "\nfrom typing import List\nimport heapq\n\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        fire_cells = [(grid[i][j], i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n        heapq.heapify(fire_cells)\n        visited = [[0]*n for _ in range(m)]\n        visited[0][0] = 1\n        min_minutes = 0\n\n        while fire_cells:\n            fire, i, j = heapq.heappop(fire_cells)\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = 1\n                    if (x, y) == (m-1, n-1):\n                        return min_minutes + 1\n                    heapq.heappush(fire_cells, (fire+1, x, y))\n            min_minutes += 1\n\n        return -1\n", "difficulty": 3.0}
{"task_id": "LeetCode/2251", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        flower_times = []\n        for flower in flowers:\n            flower_times.append((flower[0], 1))\n            flower_times.append((flower[1], -1))\n        flower_times.sort()\n\n        current_flowers, ans = 0, []\n        for time, change in flower_times:\n            current_flowers += change\n            if current_flowers > len(ans):\n                ans.append(time)\n\n        return [bisect.bisect_right(ans, person) for person in people]\n```", "extracted_code": "\nclass Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        flower_times = []\n        for flower in flowers:\n            flower_times.append((flower[0], 1))\n            flower_times.append((flower[1], -1))\n        flower_times.sort()\n\n        current_flowers, ans = 0, []\n        for time, change in flower_times:\n            current_flowers += change\n            if current_flowers > len(ans):\n                ans.append(time)\n\n        return [bisect.bisect_right(ans, person) for person in people]\n", "difficulty": 3.0}
{"task_id": "LeetCode/2248", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        intersection_set = set(nums[0])\n        for num in nums[1:]:\n            intersection_set.intersection_update(num)\n        return sorted(list(intersection_set))\n```", "extracted_code": "\nclass Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        intersection_set = set(nums[0])\n        for num in nums[1:]:\n            intersection_set.intersection_update(num)\n        return sorted(list(intersection_set))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2246", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        depth = [0] * n\n        dp = [0] * n\n        child = [[] for _ in range(n)]\n        \n        for i in range(1, n):\n            p = parent[i]\n            child[p].append(i)\n            depth[i] = depth[p] + 1\n        \n        def dfs(node):\n            for child_node in child[node]:\n                dp[child_node] = max(dp[child_node], dp[node] + (s[child_node] != s[node]))\n                dfs(child_node)\n        \n        dp[0] = depth[0]\n        dfs(0)\n        return max(dp)\n```\n\nThis solution uses depth-first search (DFS) to traverse the tree and dynamic programming (DP) to store the longest path for each node. The DP array `dp` stores the longest path that ends at each node, and the `depth` array stores the depth of each node. The `child` array stores the children of each node.\n\nThe `dfs` function is a recursive function that traverses the tree in a depth-first manner. For each node, it updates the `dp` array with the maximum of its current value and the value of the parent node plus one if the characters of the parent and child nodes are different. Then, it recursively calls `dfs` for each child node.\n\nFinally, the function returns the maximum value in the `dp` array, which is the length of the longest path", "extracted_code": "\nclass Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        depth = [0] * n\n        dp = [0] * n\n        child = [[] for _ in range(n)]\n        \n        for i in range(1, n):\n            p = parent[i]\n            child[p].append(i)\n            depth[i] = depth[p] + 1\n        \n        def dfs(node):\n            for child_node in child[node]:\n                dp[child_node] = max(dp[child_node], dp[node] + (s[child_node] != s[node]))\n                dfs(child_node)\n        \n        dp[0] = depth[0]\n        dfs(0)\n        return max(dp)\n", "difficulty": 3.0}
{"task_id": "LeetCode/2245", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_zeros = 0\n\n        def dfs(x, y, dx, dy):\n            nonlocal max_zeros\n            count = 0\n            while 0 <= x < m and 0 <= y < n:\n                count += grid[x][y]\n                max_zeros = max(max_zeros, count)\n                x, y = x + dx, y + dy\n                dx, dy = dy, -dx\n            return count\n\n        for i in range(m):\n            for j in range(n):\n                for dx, dy in directions:\n                    x, y = i, j\n                    while 0 <= x < m and 0 <= y < n:\n                        dp[x][y] += grid[x][y]\n                        x, y = x + dx, y + dy\n                        dx, dy = dy, -dx\n                        if x == i and y == j:\n                            break\n                        else:\n                            max_zeros = max(max_zeros, dp[x][y])\n        return max_zeros\n```\n\nThis function uses a depth-first search (DFS) approach to find all possible cornered paths in the grid. It", "extracted_code": "\nfrom typing import List\nimport numpy as np\n\nclass Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_zeros = 0\n\n        def dfs(x, y, dx, dy):\n            nonlocal max_zeros\n            count = 0\n            while 0 <= x < m and 0 <= y < n:\n                count += grid[x][y]\n                max_zeros = max(max_zeros, count)\n                x, y = x + dx, y + dy\n                dx, dy = dy, -dx\n            return count\n\n        for i in range(m):\n            for j in range(n):\n                for dx, dy in directions:\n                    x, y = i, j\n                    while 0 <= x < m and 0 <= y < n:\n                        dp[x][y] += grid[x][y]\n                        x, y = x + dx, y + dy\n                        dx, dy = dy, -dx\n                        if x == i and y == j:\n                            break\n                        else:\n                            max_zeros = max(max_zeros, dp[x][y])\n        return max_zeros\n", "difficulty": 2.0}
{"task_id": "LeetCode/2242", "status": "Submission Timed-Out", "reward": 0, "done": false, "raw_completion": "```python\nimport itertools\nimport heapq\n\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(len(scores))]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        best_score = -1\n        for node_sequence in itertools.permutations(range(len(scores)), 4):\n            if all(node_sequence[i] in graph[node_sequence[i - 1]] for i in range(1, 4)):\n                score = sum(scores[i] for i in node_sequence)\n                best_score = max(best_score, score)\n        return best_score\n```\n\nThis solution works by first building an adjacency list representation of the graph. Then, it generates all possible permutations of length 4 of the nodes. For each permutation, it checks if there is an edge between every pair of adjacent nodes. If there is, it adds the score of the nodes in the sequence to the running total of the best score. Finally, it returns the best score.\n\nThe time complexity of this solution is O(n^4), where n is the number of nodes. This is because it generates all possible permutations of length 4 of the nodes, which takes O(n^4) time. The space complexity is O(n + m), where m is the number of edges, due to the storage required for the adjacency list and the permutations.", "extracted_code": "\nimport itertools\nimport heapq\n\nclass Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(len(scores))]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        best_score = -1\n        for node_sequence in itertools.permutations(range(len(scores)), 4):\n            if all(node_sequence[i] in graph[node_sequence[i - 1]] for i in range(1, 4)):\n                score = sum(scores[i] for i in node_sequence)\n                best_score = max(best_score, score)\n        return best_score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2241", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount: List[int]) -> None:\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount: int) -> List[int]:\n        notes = [0, 0, 0, 0, 0]\n        if amount % 20 != 0 or amount > 500 * self.banknotes[4] + 200 * self.banknotes[3] + 100 * self.banknotes[2] + 50 * self.banknotes[1] + 20 * self.banknotes[0]:\n            return [-1]\n        else:\n            amount -= self.banknotes[4] * 500\n            notes[4] = self.banknotes[4]\n            self.banknotes[4] = 0\n            if amount > 200 * self.banknotes[3]:\n                amount -= self.banknotes[3] * 200\n                notes[3] = self.banknotes[3]\n                self.banknotes[3] = 0\n            if amount > 100 * self.banknotes[2]:\n                amount -= self.banknotes[2] * 100\n                notes[2] = self.banknotes[2]\n                self.banknotes[2] = 0\n            if amount > 50 * self.banknotes[1]:\n                amount", "extracted_code": "\nclass ATM:\n\n    def __init__(self):\n        self.banknotes = [0, 0, 0, 0, 0]\n\n    def deposit(self, banknotesCount: List[int]) -> None:\n        for i in range(5):\n            self.banknotes[i] += banknotesCount[i]\n\n    def withdraw(self, amount: int) -> List[int]:\n        notes = [0, 0, 0, 0, 0]\n        if amount % 20 != 0 or amount > 500 * self.banknotes[4] + 200 * self.banknotes[3] + 100 * self.banknotes[2] + 50 * self.banknotes[1] + 20 * self.banknotes[0]:\n            return [-1]\n        else:\n            amount -= self.banknotes[4] * 500\n            notes[4] = self.banknotes[4]\n            self.banknotes[4] = 0\n            if amount > 200 * self.banknotes[3]:\n                amount -= self.banknotes[3] * 200\n                notes[3] = self.banknotes[3]\n                self.banknotes[3] = 0\n            if amount > 100 * self.banknotes[2]:\n                amount -= self.banknotes[2] * 100\n                notes[2] = self.banknotes[2]\n                self.banknotes[2] = 0\n            if amount > 50 * self.banknotes[1]:\n                amount", "difficulty": 2.0}
{"task_id": "LeetCode/2234", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        incomplete = [i for i in range(len(flowers)) if flowers[i] < target]\n        incomplete.sort(key=lambda i: flowers[i])\n        total_beauty = 0\n        complete_gardens = 0\n        for i in incomplete:\n            if newFlowers == 0:\n                break\n            to_plant = min(newFlowers, target - flowers[i])\n            newFlowers -= to_plant\n            flowers[i] += to_plant\n            if flowers[i] >= target:\n                complete_gardens += 1\n        total_beauty += complete_gardens * full\n        if incomplete:\n            total_beauty += min(flowers[i] for i in incomplete) * partial\n        return total_beauty\n```", "extracted_code": "\nclass Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        incomplete = [i for i in range(len(flowers)) if flowers[i] < target]\n        incomplete.sort(key=lambda i: flowers[i])\n        total_beauty = 0\n        complete_gardens = 0\n        for i in incomplete:\n            if newFlowers == 0:\n                break\n            to_plant = min(newFlowers, target - flowers[i])\n            newFlowers -= to_plant\n            flowers[i] += to_plant\n            if flowers[i] >= target:\n                complete_gardens += 1\n        total_beauty += complete_gardens * full\n        if incomplete:\n            total_beauty += min(flowers[i] for i in incomplete) * partial\n        return total_beauty\n", "difficulty": 3.0}
{"task_id": "LeetCode/2223", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        score = 0\n        for i in range(n):\n            score += min(i + 1, n - i)\n        return score\n```", "extracted_code": "\nclass Solution:\n    def sumScores(self, s: str) -> int:\n        n = len(s)\n        score = 0\n        for i in range(n):\n            score += min(i + 1, n - i)\n        return score\n", "difficulty": 3.0}
{"task_id": "LeetCode/2215", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        set1, set2 = set(nums1), set(nums2)\n        return [[i for i in set1 if i not in set2], [i for i in set2 if i not in set1]]\n```", "extracted_code": "\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        set1, set2 = set(nums1), set(nums2)\n        return [[i for i in set1 if i not in set2], [i for i in set2 if i not in set1]]\n", "difficulty": 1.0}
{"task_id": "LeetCode/2206", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        from collections import Counter\n        n = len(nums) // 2\n        count = Counter(nums)\n        return all(x % 2 == 0 for x in count.values()) and all(x // 2 == n for x in count.values())\n```", "extracted_code": "\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        from collections import Counter\n        n = len(nums) // 2\n        count = Counter(nums)\n        return all(x % 2 == 0 for x in count.values()) and all(x // 2 == n for x in count.values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/2160", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        digits = list(map(int, str(num)))\n        digits.sort()\n        new1 = int(''.join(map(str, digits[:2])))\n        new2 = int(''.join(map(str, digits[2:])))\n        return new1 + new2\n```", "extracted_code": "\nclass Solution:\n    def minimumSum(self, num: int) -> int:\n        digits = list(map(int, str(num)))\n        digits.sort()\n        new1 = int(''.join(map(str, digits[:2])))\n        new2 = int(''.join(map(str, digits[2:])))\n        return new1 + new2\n", "difficulty": 1.0}
{"task_id": "LeetCode/2148", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        nums = set(nums)\n        return sum(nums.__contains__(x - 1) and nums.__contains__(x + 1) for x in nums)\n```", "extracted_code": "\nclass Solution:\n    def countElements(self, nums: List[int]) -> int:\n        nums = set(nums)\n        return sum(nums.__contains__(x - 1) and nums.__contains__(x + 1) for x in nums)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2068", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        diff = [0]*26\n        for i in range(26):\n            diff[i] = abs(word1.count(chr(97+i)) - word2.count(chr(97+i)))\n        return all(x<=3 for x in diff)\n```", "extracted_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        diff = [0]*26\n        for i in range(26):\n            diff[i] = abs(word1.count(chr(97+i)) - word2.count(chr(97+i)))\n        return all(x<=3 for x in diff)\n", "difficulty": 1.0}
{"task_id": "LeetCode/2053", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = list(dict.fromkeys(arr))\n        return distinct_strings[k - 1] if k <= len(distinct_strings) else \"\"\n```", "extracted_code": "\nclass Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        distinct_strings = list(dict.fromkeys(arr))\n        return distinct_strings[k - 1] if k <= len(distinct_strings) else \"\"\n", "difficulty": 1.0}
{"task_id": "LeetCode/2032", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        return list(set(nums1 + nums2 + nums3) - set(nums1) - set(nums2) - set(nums3))\n```", "extracted_code": "\nclass Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        return list(set(nums1 + nums2 + nums3) - set(nums1) - set(nums2) - set(nums3))\n", "difficulty": 1.0}
{"task_id": "LeetCode/2027", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        return sum(c == 'X' for c in s) // 3\n```", "extracted_code": "\nclass Solution:\n    def minimumMoves(self, s: str) -> int:\n        return sum(c == 'X' for c in s) // 3\n", "difficulty": 1.0}
{"task_id": "LeetCode/2006", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1995", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for a in range(n):\n            for b in range(a+1, n):\n                for c in range(b+1, n):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for a in range(n):\n            for b in range(a+1, n):\n                for c in range(b+1, n):\n                    for d in range(c+1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1974", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        # Calculate the time to move from character 'a' to character 'b'\n        def time_to_move(a: str, b: str) -> int:\n            return min(abs(ord(a) - ord(b)), 26 - abs(ord(a) - ord(b)))\n\n        # Calculate the total time to type the word\n        def total_time(word: str) -> int:\n            time = 0\n            for i in range(1, len(word)):\n                time += time_to_move(word[i - 1], word[i])\n            return time + len(word)\n\n        return total_time(word)\n```\n\nThis function calculates the minimum number of seconds to type out the characters in the given word. It uses a helper function `time_to_move` to calculate the time to move from one character to another and a helper function `total_time` to calculate the total time to type the word. The function assumes that the pointer is initially pointing to the character 'a'.", "extracted_code": "\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        # Calculate the time to move from character 'a' to character 'b'\n        def time_to_move(a: str, b: str) -> int:\n            return min(abs(ord(a) - ord(b)), 26 - abs(ord(a) - ord(b)))\n\n        # Calculate the total time to type the word\n        def total_time(word: str) -> int:\n            time = 0\n            for i in range(1, len(word)):\n                time += time_to_move(word[i - 1], word[i])\n            return time + len(word)\n\n        return total_time(word)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1971", "status": "Runtime Error", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import defaultdict\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        \n        def dfs(node):\n            if node == destination:\n                return True\n            if node in visited:\n                return False\n            visited.add(node)\n            return any(dfs(neighbour) for neighbour in graph[node])\n        \n        return dfs(source)\n```\n\nThis function uses a depth-first search (DFS) algorithm to check if there is a valid path from the source to the destination. It first builds a graph from the given edges, then it performs a DFS starting from the source. If it encounters the destination during the DFS, it returns True. If it encounters a node that it has already visited (except for the source), it returns False to avoid cycles. Otherwise, it continues the DFS with all unvisited neighbours of the current node.", "extracted_code": "\nfrom collections import defaultdict\n\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        \n        def dfs(node):\n            if node == destination:\n                return True\n            if node in visited:\n                return False\n            visited.add(node)\n            return any(dfs(neighbour) for neighbour in graph[node])\n        \n        return dfs(source)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1925", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a**2 + b**2)**0.5\n                if c.is_integer() and c <= n:\n                    count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countTriples(self, n: int) -> int:\n        count = 0\n        for a in range(1, n+1):\n            for b in range(a, n+1):\n                c = (a**2 + b**2)**0.5\n                if c.is_integer() and c <= n:\n                    count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1920", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n```", "extracted_code": "\nclass Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1886", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = list(zip(*mat[::-1]))\n        return False\n```", "extracted_code": "\nclass Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4):\n            if mat == target:\n                return True\n            mat = list(zip(*mat[::-1]))\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1880", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def str_to_num(s: str) -> int:\n            return int(''.join(str(ord(c) - ord('a')) for c in s))\n\n        return str_to_num(firstWord) + str_to_num(secondWord) == str_to_num(targetWord)\n```", "extracted_code": "\nclass Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def str_to_num(s: str) -> int:\n            return int(''.join(str(ord(c) - ord('a')) for c in s))\n\n        return str_to_num(firstWord) + str_to_num(secondWord) == str_to_num(targetWord)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1854", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom typing import List\n\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        years = [0] * 101\n        for log in logs:\n            years[log[0]-1950:log[1]-1950] = [1]*(log[1]-log[0])\n        return 1950 + years.index(max(years))\n```", "extracted_code": "\nfrom typing import List\n\nclass Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        years = [0] * 101\n        for log in logs:\n            years[log[0]-1950:log[1]-1950] = [1]*(log[1]-log[0])\n        return 1950 + years.index(max(years))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1837", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        return sum(int(digit) for digit in str(n))\n```", "extracted_code": "\nclass Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        return sum(int(digit) for digit in str(n))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1800", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = 0\n        curr_sum = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                curr_sum += nums[i]\n            else:\n                max_sum = max(max_sum, curr_sum)\n                curr_sum = nums[i]\n        return max(max_sum, curr_sum)\n```", "extracted_code": "\nclass Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        max_sum = 0\n        curr_sum = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                curr_sum += nums[i]\n            else:\n                max_sum = max(max_sum, curr_sum)\n                curr_sum = nums[i]\n        return max(max_sum, curr_sum)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1768", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = ''\n        i, j = 0, 0\n        while i < len(word1) and j < len(word2):\n            merged += word1[i] + word2[j]\n            i += 1\n            j += 1\n        if i < len(word1):\n            merged += word1[i:]\n        if j < len(word2):\n            merged += word2[j:]\n        return merged\n```", "extracted_code": "\nclass Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        merged = ''\n        i, j = 0, 0\n        while i < len(word1) and j < len(word2):\n            merged += word1[i] + word2[j]\n            i += 1\n            j += 1\n        if i < len(word1):\n            merged += word1[i:]\n        if j < len(word2):\n            merged += word2[j:]\n        return merged\n", "difficulty": 1.0}
{"task_id": "LeetCode/1758", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        # Initialize variables\n        n = len(s)\n        zero_count = 0\n        one_count = 0\n        min_operations = 0\n\n        # Iterate through the string\n        for i in range(n):\n            # Count the number of 0s and 1s\n            if s[i] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n\n            # Update the minimum number of operations\n            min_operations = min(min_operations, zero_count, one_count)\n\n        # Return the minimum number of operations\n        return min_operations\n```\n\nThis function works by iterating through the string and counting the number of 0s and 1s. It keeps track of the minimum number of operations needed to make the string alternating. The minimum number of operations is either the current minimum, the number of 0s encountered so far, or the number of 1s encountered so far. This is because to make the string alternating, we can either keep the current minimum number of operations, or change all the previous characters to the opposite digit (0 to 1 or 1 to 0) which will result in the minimum number of operations being either the number of 0s or the number of 1s encountered so far.", "extracted_code": "\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        # Initialize variables\n        n = len(s)\n        zero_count = 0\n        one_count = 0\n        min_operations = 0\n\n        # Iterate through the string\n        for i in range(n):\n            # Count the number of 0s and 1s\n            if s[i] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n\n            # Update the minimum number of operations\n            min_operations = min(min_operations, zero_count, one_count)\n\n        # Return the minimum number of operations\n        return min_operations\n", "difficulty": 1.0}
{"task_id": "LeetCode/1748", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        unique_nums = set(nums)\n        return sum(unique_num for unique_num in unique_nums if nums.count(unique_num) == 1)\n```", "extracted_code": "\nclass Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        unique_nums = set(nums)\n        return sum(unique_num for unique_num in unique_nums if nums.count(unique_num) == 1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1656", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.values = [None]*n\n        self.ptr = 0\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        self.values[idKey-1] = value\n        result = []\n        while self.ptr < len(self.values) and self.values[self.ptr] is not None:\n            result.append(self.values[self.ptr])\n            self.ptr += 1\n        return result\n```", "extracted_code": "\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.values = [None]*n\n        self.ptr = 0\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        self.values[idKey-1] = value\n        result = []\n        while self.ptr < len(self.values) and self.values[self.ptr] is not None:\n            result.append(self.values[self.ptr])\n            self.ptr += 1\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1640", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        pieces_dict = {pieces[i][0]: pieces[i] for i in range(len(pieces))}\n        for i in range(len(arr)):\n            if arr[i] not in pieces_dict:\n                return False\n            if pieces_dict[arr[i]][0] != arr[i]:\n                return False\n            pieces_dict[arr[i]].pop(0)\n            if not pieces_dict[arr[i]]:\n                del pieces_dict[arr[i]]\n        return True\n```", "extracted_code": "\nclass Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        pieces_dict = {pieces[i][0]: pieces[i] for i in range(len(pieces))}\n        for i in range(len(arr)):\n            if arr[i] not in pieces_dict:\n                return False\n            if pieces_dict[arr[i]][0] != arr[i]:\n                return False\n            pieces_dict[arr[i]].pop(0)\n            if not pieces_dict[arr[i]]:\n                del pieces_dict[arr[i]]\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/1619", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        five_percent = int(n * 0.05)\n        return sum(arr[five_percent:-five_percent]) / (n - 2 * five_percent)\n```", "extracted_code": "\nclass Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n        n = len(arr)\n        five_percent = int(n * 0.05)\n        return sum(arr[five_percent:-five_percent]) / (n - 2 * five_percent)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1614", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n```", "extracted_code": "\nclass Solution:\n    def maxDepth(self, s: str) -> int:\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n", "difficulty": 1.0}
{"task_id": "LeetCode/1582", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        rows, cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    rows[i] += 1\n                    cols[j] += 1\n        return sum(mat[i][j] == 1 and rows[i] == 1 and cols[j] == 1 for i in range(m) for j in range(n))\n```", "extracted_code": "\nclass Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        rows, cols = [0]*m, [0]*n\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    rows[i] += 1\n                    cols[j] += 1\n        return sum(mat[i][j] == 1 and rows[i] == 1 and cols[j] == 1 for i in range(m) for j in range(n))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1566", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        for i in range(len(arr) - m * k + 1):\n            if all(arr[i+j] == arr[i+j+m] for j in range(m) for _ in range(k-1)):\n                return True\n        return False\n```\n\nThis function works by iterating over the array with a step size of `m * k - m`. This is because we are looking for a pattern of length `m` that is repeated `k` or more times, without overlapping. So, we need to move by `m * k` in each iteration to check the next non-overlapping sequence.\n\nInside the loop, we use a nested list comprehension to compare each element in the current sequence with the corresponding element in the next sequence. If all elements are equal, it means the pattern of length `m` is repeated `k` or more times.\n\nIf the loop finishes without finding a matching pattern, we return `False`.", "extracted_code": "\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        for i in range(len(arr) - m * k + 1):\n            if all(arr[i+j] == arr[i+j+m] for j in range(m) for _ in range(k-1)):\n                return True\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1556", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        return '{:,}'.format(n).replace(',', '.')\n```", "extracted_code": "\nclass Solution:\n    def thousandSeparator(self, n: int) -> str:\n        return '{:,}'.format(n).replace(',', '.')\n", "difficulty": 1.0}
{"task_id": "LeetCode/1534", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        n = len(arr)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(arr[i] - arr[j]) > a:\n                    continue\n                for k in range(j+1, n):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n```", "extracted_code": "\nclass Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        n = len(arr)\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if abs(arr[i] - arr[j]) > a:\n                    continue\n                for k in range(j+1, n):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n", "difficulty": 1.0}
{"task_id": "LeetCode/1496", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y, visited = 0, 0, set()\n        visited.add((x, y))\n        for direction in path:\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            else:\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False\n```", "extracted_code": "\nclass Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        x, y, visited = 0, 0, set()\n        visited.add((x, y))\n        for direction in path:\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            else:\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False\n", "difficulty": 1.0}
{"task_id": "LeetCode/1486", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = nums[0]\n        for num in nums[1:]:\n            result ^= num\n        return result\n```", "extracted_code": "\nclass Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        nums = [start + 2 * i for i in range(n)]\n        result = nums[0]\n        for num in nums[1:]:\n            result ^= num\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1464", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        return (nums[-1]-1) * (nums[-2]-1)\n```", "extracted_code": "\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        return (nums[-1]-1) * (nums[-2]-1)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1431", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candy = max(candies)\n        return [candy + extraCandies >= max_candy for candy in candies]\n```", "extracted_code": "\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        max_candy = max(candies)\n        return [candy + extraCandies >= max_candy for candy in candies]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1422", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        left_zeros = 0\n        right_ones = 0\n        max_score = 0\n        for i in range(len(s) - 1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                right_ones += 1\n            max_score = max(max_score, left_zeros + right_ones)\n        return max_score\n```", "extracted_code": "\nclass Solution:\n    def maxScore(self, s: str) -> int:\n        left_zeros = 0\n        right_ones = 0\n        max_score = 0\n        for i in range(len(s) - 1):\n            if s[i] == '0':\n                left_zeros += 1\n            else:\n                right_ones += 1\n            max_score = max(max_score, left_zeros + right_ones)\n        return max_score\n", "difficulty": 1.0}
{"task_id": "LeetCode/1408", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        words.sort(key=len)\n        result = []\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if words[i] in words[j]:\n                    result.append(words[i])\n                    break\n        return result\n```\n\nThis function works by first sorting the words by their length. Then, it iterates through the list of words and checks if the current word is a substring of any other word that comes after it in the sorted list. If it is, the word is added to the result list. The function finally returns the result list, which contains all the words that are substrings of another word.", "extracted_code": "\nclass Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        words.sort(key=len)\n        result = []\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if words[i] in words[j]:\n                    result.append(words[i])\n                    break\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1399", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i in range(1, n+1):\n            digit_sums[sum(int(digit) for digit in str(i))].append(i)\n        max_group_size = max(len(group) for group in digit_sums.values())\n        return sum(1 for group in digit_sums.values() if len(group) == max_group_size)\n```", "extracted_code": "\nclass Solution:\n    def countLargestGroup(self, n: int) -> int:\n        from collections import defaultdict\n        digit_sums = defaultdict(list)\n        for i in range(1, n+1):\n            digit_sums[sum(int(digit) for digit in str(i))].append(i)\n        max_group_size = max(len(group) for group in digit_sums.values())\n        return sum(1 for group in digit_sums.values() if len(group) == max_group_size)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1360", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        date_format = \"%Y-%m-%d\"\n        a = datetime.strptime(date1, date_format)\n        b = datetime.strptime(date2, date_format)\n        return abs((a - b).days)\n```", "extracted_code": "\nfrom datetime import datetime\n\nclass Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        date_format = \"%Y-%m-%d\"\n        a = datetime.strptime(date1, date_format)\n        b = datetime.strptime(date2, date_format)\n        return abs((a - b).days)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1323", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num_str = str(num)\n        for i in range(len(num_str)):\n            if num_str[i] == '6':\n                num_str = num_str[:i] + '9' + num_str[i+1:]\n                break\n        return int(num_str)\n```", "extracted_code": "\nclass Solution:\n    def maximum69Number (self, num: int) -> int:\n        num_str = str(num)\n        for i in range(len(num_str)):\n            if num_str[i] == '6':\n                num_str = num_str[:i] + '9' + num_str[i+1:]\n                break\n        return int(num_str)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1304", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        if n % 2 == 1:\n            return [0] + list(range(1, n, 2)) + list(range(-1, -n, -2))\n        else:\n            return list(range(-n//2, 0)) + list(range(1, n//2+1))\n```", "extracted_code": "\nclass Solution:\n    def sumZero(self, n: int) -> List[int]:\n        if n % 2 == 1:\n            return [0] + list(range(1, n, 2)) + list(range(-1, -n, -2))\n        else:\n            return list(range(-n//2, 0)) + list(range(1, n//2+1))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1266", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time = 0\n        for i in range(1, len(points)):\n            x_diff = abs(points[i][0] - points[i-1][0])\n            y_diff = abs(points[i][1] - points[i-1][1])\n            time += max(x_diff, y_diff)\n        return time\n```", "extracted_code": "\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        time = 0\n        for i in range(1, len(points)):\n            x_diff = abs(points[i][0] - points[i-1][0])\n            y_diff = abs(points[i][1] - points[i-1][1])\n            time += max(x_diff, y_diff)\n        return time\n", "difficulty": 1.0}
{"task_id": "LeetCode/1252", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        matrix = [[0]*n for _ in range(m)]\n        for r, c in indices:\n            for i in range(n):\n                matrix[r][i] += 1\n            for i in range(m):\n                matrix[i][c] += 1\n        return sum(row[i] % 2 for row in matrix for i in range(n))\n```", "extracted_code": "\nclass Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        matrix = [[0]*n for _ in range(m)]\n        for r, c in indices:\n            for i in range(n):\n                matrix[r][i] += 1\n            for i in range(m):\n                matrix[i][c] += 1\n        return sum(row[i] % 2 for row in matrix for i in range(n))\n", "difficulty": 1.0}
{"task_id": "LeetCode/1207", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        return len(set(arr)) == len(Counter(arr).values())\n```\n\nIn this solution, we use Python's built-in `Counter` function from the `collections` module to count the occurrences of each value in the array. This returns a dictionary where the keys are the unique values in the array and the values are the number of occurrences of each value.\n\nWe then convert the values of this dictionary to a set, which removes any duplicates. If the length of this set is equal to the length of the values in the original dictionary (i.e., the number of unique occurrences), then all occurrences are unique and the function returns `True`. Otherwise, it returns `False`.", "extracted_code": "\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        return len(set(arr)) == len(Counter(arr).values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/1200", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        min_diff = float('inf')\n        for i in range(1, len(arr)):\n            min_diff = min(min_diff, arr[i] - arr[i-1])\n        result = [[arr[i], arr[i+1]] for i in range(len(arr)-1) if arr[i+1] - arr[i] == min_diff]\n        return result\n```\n\nThis function first sorts the input array. Then it iterates through the sorted array to find the minimum absolute difference between consecutive elements. Finally, it constructs the result list by iterating through the sorted array again and checking if the difference between consecutive elements is equal to the minimum absolute difference. If it is, the pair of elements is added to the result list.", "extracted_code": "\nclass Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        min_diff = float('inf')\n        for i in range(1, len(arr)):\n            min_diff = min(min_diff, arr[i] - arr[i-1])\n        result = [[arr[i], arr[i+1]] for i in range(len(arr)-1) if arr[i+1] - arr[i] == min_diff]\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1175", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        mod = 10**9 + 7\n        def factorial(n):\n            f = [1]*(n+1)\n            for i in range(2, n+1):\n                f[i] = f[i-1]*i % mod\n            return f\n        def is_prime(n):\n            if n < 2: return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0: return False\n            return True\n        f = factorial(n)\n        primes = sum(is_prime(i) for i in range(1, n+1))\n        composites = n - primes\n        return f[primes] * f[composites] % mod\n```\n\nThis function first calculates the factorial of all numbers up to `n` and stores them in the `f` list. Then it counts the number of prime and composite numbers from 1 to `n`. Finally, it returns the product of the factorials of the number of prime and composite numbers, modulo `10^9 + 7`. The factorials are precomputed to reduce the time complexity of the function. The `is_prime` function checks if a number is prime by trying to divide it by all numbers up to its square root. The `factorial` function calculates the factorial of a number by multiplying it by all smaller numbers.", "extracted_code": "\nclass Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        mod = 10**9 + 7\n        def factorial(n):\n            f = [1]*(n+1)\n            for i in range(2, n+1):\n                f[i] = f[i-1]*i % mod\n            return f\n        def is_prime(n):\n            if n < 2: return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0: return False\n            return True\n        f = factorial(n)\n        primes = sum(is_prime(i) for i in range(1, n+1))\n        composites = n - primes\n        return f[primes] * f[composites] % mod\n", "difficulty": 1.0}
{"task_id": "LeetCode/1128", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        dominoes_dict = {}\n        for domino in dominoes:\n            domino.sort()\n            domino_tuple = tuple(domino)\n            if domino_tuple in dominoes_dict:\n                dominoes_dict[domino_tuple] += 1\n            else:\n                dominoes_dict[domino_tuple] = 1\n        return sum(n * (n - 1) // 2 for n in dominoes_dict.values())\n```\n\nThis function works by first creating a dictionary `dominoes_dict` where the keys are the sorted dominoes and the values are the counts of each domino. The sorted dominoes ensures that each equivalent pair of dominoes will have the same key.\n\nThen, it iterates over the values in the dictionary and calculates the number of pairs for each count using the formula `n * (n - 1) // 2`. This formula is derived from the mathematical combination formula for choosing 2 elements from a set of `n` elements, which is the number of pairs that can be formed.\n\nFinally, it returns the sum of all these pair counts, which gives the total number of equivalent pairs in the dominoes list.", "extracted_code": "\nclass Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        dominoes_dict = {}\n        for domino in dominoes:\n            domino.sort()\n            domino_tuple = tuple(domino)\n            if domino_tuple in dominoes_dict:\n                dominoes_dict[domino_tuple] += 1\n            else:\n                dominoes_dict[domino_tuple] = 1\n        return sum(n * (n - 1) // 2 for n in dominoes_dict.values())\n", "difficulty": 1.0}
{"task_id": "LeetCode/1108", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n```", "extracted_code": "\nclass Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n", "difficulty": 1.0}
{"task_id": "LeetCode/1103", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        result = [0] * num_people\n        current_candy = 0\n        while candies > 0:\n            for i in range(num_people):\n                give_candy = min(candies, current_candy + i + 1)\n                result[i] += give_candy\n                candies -= give_candy\n                if candies == 0:\n                    break\n            current_candy += num_people\n        return result\n```", "extracted_code": "\nclass Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        result = [0] * num_people\n        current_candy = 0\n        while candies > 0:\n            for i in range(num_people):\n                give_candy = min(candies, current_candy + i + 1)\n                result[i] += give_candy\n                candies -= give_candy\n                if candies == 0:\n                    break\n            current_candy += num_people\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/1071", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        if not str1.startswith(str2):\n            return ''\n        if str1 == str2:\n            return str2\n        return self.gcdOfStrings(str1[len(str2):], str2)\n```", "extracted_code": "\nclass Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        if not str1.startswith(str2):\n            return ''\n        if str1 == str2:\n            return str2\n        return self.gcdOfStrings(str1[len(str2):], str2)\n", "difficulty": 1.0}
{"task_id": "LeetCode/1025", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if i % j == 0 and not dp[i - j]:\n                    dp[i] = True\n                    break\n        return dp[n]\n```", "extracted_code": "\nclass Solution:\n    def divisorGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if i % j == 0 and not dp[i - j]:\n                    dp[i] = True\n                    break\n        return dp[n]\n", "difficulty": 1.0}
{"task_id": "LeetCode/1009", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        return (2**len(bin(n)[2:]) - 1) ^ n\n```", "extracted_code": "\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        return (2**len(bin(n)[2:]) - 1) ^ n\n", "difficulty": 1.0}
{"task_id": "LeetCode/993", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        def dfs(node, parent, depth):\n            if node:\n                if node.val == x or node.val == y:\n                    if node.val == x: \n                        nonlocal x_parent, x_depth\n                        x_parent, x_depth = parent, depth\n                    else: \n                        nonlocal y_parent, y_depth\n                        y_parent, y_depth = parent, depth\n                else:\n                    dfs(node.left, node.val, depth + 1)\n                    dfs(node.right, node.val, depth + 1)\n\n        x_parent = y_parent = x_depth = y_depth = None\n        dfs(root, None, 0)\n        return x_depth == y_depth and x_parent != y_parent\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        def dfs(node, parent, depth):\n            if node:\n                if node.val == x or node.val == y:\n                    if node.val == x: \n                        nonlocal x_parent, x_depth\n                        x_parent, x_depth = parent, depth\n                    else: \n                        nonlocal y_parent, y_depth\n                        y_parent, y_depth = parent, depth\n                else:\n                    dfs(node.left, node.val, depth + 1)\n                    dfs(node.right, node.val, depth + 1)\n\n        x_parent = y_parent = x_depth = y_depth = None\n        dfs(root, None, 0)\n        return x_depth == y_depth and x_parent != y_parent\n", "difficulty": 1.0}
{"task_id": "LeetCode/965", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        if root.left and root.val != root.left.val:\n            return False\n        if root.right and root.val != root.right.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        if root.left and root.val != root.left.val:\n            return False\n        if root.right and root.val != root.right.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/953", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        order_dict = {char: i for i, char in enumerate(order)}\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i + 1]\n            for j in range(min(len(word1), len(word2))):\n                if word1[j] != word2[j]:\n                    if order_dict[word1[j]] > order_dict[word2[j]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        order_dict = {char: i for i, char in enumerate(order)}\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i + 1]\n            for j in range(min(len(word1), len(word2))):\n                if word1[j] != word2[j]:\n                    if order_dict[word1[j]] > order_dict[word2[j]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/944", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        num_cols = len(strs[0])\n        num_rows = len(strs)\n        num_delete = 0\n\n        for j in range(num_cols):\n            for i in range(num_rows - 1):\n                if strs[i][j] > strs[i+1][j]:\n                    num_delete += 1\n                    break\n\n        return num_delete\n```", "extracted_code": "\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        num_cols = len(strs[0])\n        num_rows = len(strs)\n        num_delete = 0\n\n        for j in range(num_cols):\n            for i in range(num_rows - 1):\n                if strs[i][j] > strs[i+1][j]:\n                    num_delete += 1\n                    break\n\n        return num_delete\n", "difficulty": 1.0}
{"task_id": "LeetCode/933", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)", "extracted_code": "\nclass RecentCounter:\n\n    def __init__(self):\n        self.requests = []\n\n    def ping(self, t: int) -> int:\n        self.requests.append(t)\n        while self.requests[0] < t - 3000:\n            self.requests.pop(0)\n        return len(self.requests)", "difficulty": 1.0}
{"task_id": "LeetCode/914", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nfrom collections import Counter\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = Counter(deck)\n        return reduce(lambda x, y: x * y // math.gcd(x, y), count.values()) >= 2\n```\n\nThis function works by first counting the occurrence of each number in the deck using the Counter class from the collections library. Then, it computes the greatest common divisor (gcd) of all the counts using the reduce function from the functools library. If the gcd is greater than or equal to 2, it means that it's possible to partition the deck into groups of size x, where x > 1, and all cards in one group have the same integer written on them. Otherwise, it returns false.", "extracted_code": "\nfrom collections import Counter\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = Counter(deck)\n        return reduce(lambda x, y: x * y // math.gcd(x, y), count.values()) >= 2\n", "difficulty": 1.0}
{"task_id": "LeetCode/892", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        area = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    area += 2  # for each cube, there are two faces on the top and bottom\n                if i > 0:\n                    area += max(grid[i][j] - grid[i - 1][j], 0)\n                if j > 0:\n                    area += max(grid[i][j] - grid[i][j - 1], 0)\n        return area\n```\n\nThis function works by iterating through each cell in the grid and calculating the contribution to the surface area of the resulting shape. For each cell, there are two faces on the top and bottom, so we add 2 to the total surface area. If the cell is not on the boundary, we also add the difference between the current cell's height and the adjacent cell's height to the total surface area, but only if the adjacent cell's height is less than the current cell's height. This accounts for the faces that are shared between the two cubes.", "extracted_code": "\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        area = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    area += 2  # for each cube, there are two faces on the top and bottom\n                if i > 0:\n                    area += max(grid[i][j] - grid[i - 1][j], 0)\n                if j > 0:\n                    area += max(grid[i][j] - grid[i][j - 1], 0)\n        return area\n", "difficulty": 1.0}
{"task_id": "LeetCode/888", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        alice_sum = sum(aliceSizes)\n        bob_sum = sum(bobSizes)\n        delta = (bob_sum - alice_sum) // 2\n\n        alice_set = set(aliceSizes)\n        for bob_candy in bobSizes:\n            if bob_candy - delta in alice_set:\n                return [bob_candy - delta, bob_candy]\n```\n\nThis function works by first calculating the total number of candies that Alice and Bob have. The difference between the total number of candies that Alice and Bob have is then divided by 2, which gives the difference in the number of candies that Alice and Bob need to exchange to have the same total amount of candy.\n\nThen, for each box of candy that Bob has, we check if there is a box of candy with the same number of candies in Alice's collection that, when subtracted from the current box of candy that Bob has, gives the difference in the number of candies that Alice and Bob need to exchange to have the same total amount of candy. If we find such a box of candy, we return the number of candies in that box and the current box of candy that Bob has as the answer.\n\nThe time complexity of this function is O(n), where n is the total number of boxes of candy that Alice and Bob have. This is because we need to iterate over each box of candy that Bob has and check if there is a corresponding", "extracted_code": "\nclass Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        alice_sum = sum(aliceSizes)\n        bob_sum = sum(bobSizes)\n        delta = (bob_sum - alice_sum) // 2\n\n        alice_set = set(aliceSizes)\n        for bob_candy in bobSizes:\n            if bob_candy - delta in alice_set:\n                return [bob_candy - delta, bob_candy]\n", "difficulty": 1.0}
{"task_id": "LeetCode/867", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n```", "extracted_code": "\nclass Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n", "difficulty": 1.0}
{"task_id": "LeetCode/844", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        i, j = len(s) - 1, len(t) - 1\n        backspace_s, backspace_t = 0, 0\n\n        while i >= 0 or j >= 0:\n            while i >= 0:\n                if s[i] == '#':\n                    backspace_s += 1\n                    i -= 1\n                elif backspace_s > 0:\n                    backspace_s -= 1\n                    i -= 1\n                else:\n                    break\n\n            while j >= 0:\n                if t[j] == '#':\n                    backspace_t += 1\n                    j -= 1\n                elif backspace_t > 0:\n                    backspace_t -= 1\n                    j -= 1\n                else:\n                    break\n\n            if i >= 0 and j >= 0 and s[i] != t[j]:\n                return False\n\n            if (i >= 0) != (j >= 0):\n                return False\n\n            i -= 1\n            j -= 1\n\n        return True\n```", "extracted_code": "\nclass Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        i, j = len(s) - 1, len(t) - 1\n        backspace_s, backspace_t = 0, 0\n\n        while i >= 0 or j >= 0:\n            while i >= 0:\n                if s[i] == '#':\n                    backspace_s += 1\n                    i -= 1\n                elif backspace_s > 0:\n                    backspace_s -= 1\n                    i -= 1\n                else:\n                    break\n\n            while j >= 0:\n                if t[j] == '#':\n                    backspace_t += 1\n                    j -= 1\n                elif backspace_t > 0:\n                    backspace_t -= 1\n                    j -= 1\n                else:\n                    break\n\n            if i >= 0 and j >= 0 and s[i] != t[j]:\n                return False\n\n            if (i >= 0) != (j >= 0):\n                return False\n\n            i -= 1\n            j -= 1\n\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/830", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        res = []\n        i = 0\n        for j in range(len(s)):\n            if j == len(s) - 1 or s[j] != s[j+1]:\n                if j - i + 1 >= 3:\n                    res.append([i, j])\n                i = j + 1\n        return res\n```", "extracted_code": "\nclass Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        res = []\n        i = 0\n        for j in range(len(s)):\n            if j == len(s) - 1 or s[j] != s[j+1]:\n                if j - i + 1 >= 3:\n                    res.append([i, j])\n                i = j + 1\n        return res\n", "difficulty": 1.0}
{"task_id": "LeetCode/804", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        morse_words = set()\n        for word in words:\n            morse_word = \"\"\n            for c in word:\n                morse_word += morse[ord(c) - ord('a')]\n            morse_words.add(morse_word)\n        return len(morse_words)\n```", "extracted_code": "\nclass Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        morse_words = set()\n        for word in words:\n            morse_word = \"\"\n            for c in word:\n                morse_word += morse[ord(c) - ord('a')]\n            morse_words.add(morse_word)\n        return len(morse_words)\n", "difficulty": 1.0}
{"task_id": "LeetCode/762", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))\n```", "extracted_code": "\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n\n        return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))\n", "difficulty": 1.0}
{"task_id": "LeetCode/728", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        result = []\n        for num in range(left, right + 1):\n            if all(int(digit) != 0 and num % int(digit) == 0 for digit in str(num)):\n                result.append(num)\n        return result\n```", "extracted_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        result = []\n        for num in range(left, right + 1):\n            if all(int(digit) != 0 and num % int(digit) == 0 for digit in str(num)):\n                result.append(num)\n        return result\n", "difficulty": 1.0}
{"task_id": "LeetCode/706", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass MyHashMap:\n\n    def __init__(self):\n        self.map = []\n\n    def put(self, key: int, value: int) -> None:\n        for i, kv in enumerate(self.map):\n            if kv[0] == key:\n                self.map[i] = (key, value)\n                return\n        self.map.append((key, value))\n\n    def get(self, key: int) -> int:\n        for kv in self.map:\n            if kv[0] == key:\n                return kv[1]\n        return -1\n\n    def remove(self, key: int) -> None:\n        for i, kv in enumerate(self.map):\n            if kv[0] == key:\n                del self.map[i]\n                return\n```", "extracted_code": "\nclass MyHashMap:\n\n    def __init__(self):\n        self.map = []\n\n    def put(self, key: int, value: int) -> None:\n        for i, kv in enumerate(self.map):\n            if kv[0] == key:\n                self.map[i] = (key, value)\n                return\n        self.map.append((key, value))\n\n    def get(self, key: int) -> int:\n        for kv in self.map:\n            if kv[0] == key:\n                return kv[1]\n        return -1\n\n    def remove(self, key: int) -> None:\n        for i, kv in enumerate(self.map):\n            if kv[0] == key:\n                del self.map[i]\n                return\n", "difficulty": 1.0}
{"task_id": "LeetCode/704", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n```", "extracted_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/682", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack = []\n        for op in operations:\n            if op == '+':\n                stack.append(stack[-1] + stack[-2])\n            elif op == 'C':\n                stack.pop()\n            elif op == 'D':\n                stack.append(2 * stack[-1])\n            else:\n                stack.append(int(op))\n        return sum(stack)\n```", "extracted_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack = []\n        for op in operations:\n            if op == '+':\n                stack.append(stack[-1] + stack[-2])\n            elif op == 'C':\n                stack.pop()\n            elif op == 'D':\n                stack.append(2 * stack[-1])\n            else:\n                stack.append(int(op))\n        return sum(stack)\n", "difficulty": 1.0}
{"task_id": "LeetCode/680", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return s[left + 1:right + 1] == s[left + 1:right + 1][::-1] or s[left:right] == s[left:right][::-1]\n            left += 1\n            right -= 1\n        return True\n```", "extracted_code": "\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return s[left + 1:right + 1] == s[left + 1:right + 1][::-1] or s[left:right] == s[left:right][::-1]\n            left += 1\n            right -= 1\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/674", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        max_length = 1\n        current_length = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n        return max(max_length, current_length)\n```", "extracted_code": "\nclass Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        max_length = 1\n        current_length = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n        return max(max_length, current_length)\n", "difficulty": 1.0}
{"task_id": "LeetCode/671", "status": "Wrong Answer", "reward": 0, "done": false, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        min_val = root.val\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if min_val < node.val < float('inf'):\n                return node.val\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return -1\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        min_val = root.val\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if min_val < node.val < float('inf'):\n                return node.val\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return -1\n", "difficulty": 1.0}
{"task_id": "LeetCode/645", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        duplicate = -1\n        missing = -1\n        for num in nums:\n            if nums[abs(num) - 1] < 0:\n                duplicate = abs(num)\n            else:\n                nums[abs(num) - 1] *= -1\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                missing = i + 1\n        return [duplicate, missing]\n```", "extracted_code": "\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        duplicate = -1\n        missing = -1\n        for num in nums:\n            if nums[abs(num) - 1] < 0:\n                duplicate = abs(num)\n            else:\n                nums[abs(num) - 1] *= -1\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                missing = i + 1\n        return [duplicate, missing]\n", "difficulty": 1.0}
{"task_id": "LeetCode/617", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n        return root1\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n        return root1\n", "difficulty": 1.0}
{"task_id": "LeetCode/599", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        index_sum = float('inf')\n        common_strings = []\n        map1 = {v: i for i, v in enumerate(list1)}\n        for j, v in enumerate(list2):\n            if v in map1:\n                if map1[v] + j < index_sum:\n                    index_sum = map1[v] + j\n                    common_strings = [v]\n                elif map1[v] + j == index_sum:\n                    common_strings.append(v)\n        return common_strings\n```\n\nThis function works by first creating a dictionary `map1` that maps each string in `list1` to its index. Then, it iterates over each string in `list2` and checks if it is in `map1`. If it is, it calculates the sum of its index in `list1` and its index in `list2`. If this sum is smaller than the current smallest sum `index_sum`, it updates `index_sum` and sets `common_strings` to a list containing just the current string. If the sum is equal to `index_sum`, it appends the current string to `common_strings`. Finally, it returns `common_strings`.", "extracted_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        index_sum = float('inf')\n        common_strings = []\n        map1 = {v: i for i, v in enumerate(list1)}\n        for j, v in enumerate(list2):\n            if v in map1:\n                if map1[v] + j < index_sum:\n                    index_sum = map1[v] + j\n                    common_strings = [v]\n                elif map1[v] + j == index_sum:\n                    common_strings.append(v)\n        return common_strings\n", "difficulty": 1.0}
{"task_id": "LeetCode/572", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root:\n            return False\n        if self.isSame(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def isSame(self, root, subRoot):\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        if root.val != subRoot.val:\n            return False\n        return self.isSame(root.left, subRoot.left) and self.isSame(root.right, subRoot.right)\n```", "extracted_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root:\n            return False\n        if self.isSame(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def isSame(self, root, subRoot):\n        if not root and not subRoot:\n            return True\n        if not root or not subRoot:\n            return False\n        if root.val != subRoot.val:\n            return False\n        return self.isSame(root.left, subRoot.left) and self.isSame(root.right, subRoot.right)\n", "difficulty": 1.0}
{"task_id": "LeetCode/551", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        if s.count('A') >= 2:\n            return False\n        for i in range(len(s) - 2):\n            if s[i:i+3].count('L') >= 3:\n                return False\n        return True\n```", "extracted_code": "\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        if s.count('A') >= 2:\n            return False\n        for i in range(len(s) - 2):\n            if s[i:i+3].count('L') >= 3:\n                return False\n        return True\n", "difficulty": 1.0}
{"task_id": "LeetCode/509", "status": "Accepted", "reward": 1, "done": true, "raw_completion": "```python\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n```", "extracted_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n", "difficulty": 1.0}
